/* tslint:disable */
/* eslint-disable */
//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v12.3.1.0 (NJsonSchema v9.14.1.0 (Newtonsoft.Json v11.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------
// ReSharper disable InconsistentNaming

import { mergeMap as _observableMergeMap, catchError as _observableCatch } from 'rxjs/operators';
import { Observable, throwError as _observableThrow, of as _observableOf } from 'rxjs';
import { Injectable, Inject, Optional, InjectionToken } from '@angular/core';
import { HttpClient, HttpHeaders, HttpResponse, HttpResponseBase } from '@angular/common/http';

import * as moment from 'moment';

export const API_BASE_URL = new InjectionToken<string>('API_BASE_URL');

@Injectable()
export class CategoryServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param body (optional)
     * @return Success
     */
    getList(body: CategoryGuidGetDto | undefined): Observable<CategoryOutputDto[]> {
        let url_ = this.baseUrl + "/api/services/DATA/read/Category/GetList";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetList(<any>response_);
                } catch (e) {
                    return <Observable<CategoryOutputDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<CategoryOutputDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetList(response: HttpResponseBase): Observable<CategoryOutputDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(CategoryOutputDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CategoryOutputDto[]>(<any>null);
    }

    /**
     * @param body (optional)
     * @return Success
     */
    get(body: GuidEntityDto | undefined): Observable<CategoryOutputDto> {
        let url_ = this.baseUrl + "/api/services/DATA/read/Category/Get";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(<any>response_);
                } catch (e) {
                    return <Observable<CategoryOutputDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<CategoryOutputDto>><any>_observableThrow(response_);
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<CategoryOutputDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CategoryOutputDto.fromJS(resultData200) : new CategoryOutputDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CategoryOutputDto>(<any>null);
    }

    /**
     * @param body (optional)
     * @return Success
     */
    create(body: CategoryInputDto | undefined): Observable<CategoryOutputDto> {
        let url_ = this.baseUrl + "/api/services/DATA/write/Category/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(<any>response_);
                } catch (e) {
                    return <Observable<CategoryOutputDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<CategoryOutputDto>><any>_observableThrow(response_);
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<CategoryOutputDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CategoryOutputDto.fromJS(resultData200) : new CategoryOutputDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CategoryOutputDto>(<any>null);
    }

    /**
     * @param body (optional)
     * @return Success
     */
    update(body: CategoryInputDto | undefined): Observable<CategoryOutputDto> {
        let url_ = this.baseUrl + "/api/services/DATA/write/Category/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(<any>response_);
                } catch (e) {
                    return <Observable<CategoryOutputDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<CategoryOutputDto>><any>_observableThrow(response_);
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<CategoryOutputDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CategoryOutputDto.fromJS(resultData200) : new CategoryOutputDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CategoryOutputDto>(<any>null);
    }

    /**
     * @param body (optional)
     * @return Success
     */
    delete(body: GuidEntityDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/DATA/write/Category/Delete";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class CategoryClientServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param body (optional)
     * @return Success
     */
    getList(body: CategoryGuidGetDto | undefined): Observable<CategoryOutputDto[]> {
        let url_ = this.baseUrl + "/api/services/DATA/read/CategoryClient/GetList";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetList(<any>response_);
                } catch (e) {
                    return <Observable<CategoryOutputDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<CategoryOutputDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetList(response: HttpResponseBase): Observable<CategoryOutputDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(CategoryOutputDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CategoryOutputDto[]>(<any>null);
    }
}

@Injectable()
export class ContactServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param body (optional)
     * @return Success
     */
    getAll(body: ContactGuidGetDto | undefined): Observable<ContactDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/CMS/read/Contact/GetAll";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<ContactDtoPagedResultDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ContactDtoPagedResultDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<ContactDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ContactDtoPagedResultDto.fromJS(resultData200) : new ContactDtoPagedResultDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ContactDtoPagedResultDto>(<any>null);
    }

    /**
     * @param body (optional)
     * @return Success
     */
    getContact(body: GuidEntityDto | undefined): Observable<ContactOutputDto> {
        let url_ = this.baseUrl + "/api/services/CMS/read/Contact/GetContact";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetContact(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetContact(<any>response_);
                } catch (e) {
                    return <Observable<ContactOutputDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ContactOutputDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetContact(response: HttpResponseBase): Observable<ContactOutputDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ContactOutputDto.fromJS(resultData200) : new ContactOutputDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ContactOutputDto>(<any>null);
    }

    /**
     * @param body (optional)
     * @return Success
     */
    update(body: ContactInputDto | undefined): Observable<ContactOutputDto> {
        let url_ = this.baseUrl + "/api/services/CMS/write/Contact/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(<any>response_);
                } catch (e) {
                    return <Observable<ContactOutputDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ContactOutputDto>><any>_observableThrow(response_);
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<ContactOutputDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ContactOutputDto.fromJS(resultData200) : new ContactOutputDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ContactOutputDto>(<any>null);
    }

    /**
     * @param body (optional)
     * @return Success
     */
    delete(body: GuidEntityDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/CMS/write/Contact/Delete";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class ContactClientServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param body (optional)
     * @return Success
     */
    create(body: ContactInputDto | undefined): Observable<ContactOutputDto> {
        let url_ = this.baseUrl + "/api/services/CMS/write/ContactClient/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(<any>response_);
                } catch (e) {
                    return <Observable<ContactOutputDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ContactOutputDto>><any>_observableThrow(response_);
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<ContactOutputDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ContactOutputDto.fromJS(resultData200) : new ContactOutputDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ContactOutputDto>(<any>null);
    }
}

@Injectable()
export class FileClientServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param body (optional)
     * @return Success
     */
    getFile(body: StringEntityDto | undefined): Observable<FileEntity> {
        let url_ = this.baseUrl + "/api/services/DATA/read/FileClient/GetFile";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetFile(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetFile(<any>response_);
                } catch (e) {
                    return <Observable<FileEntity>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileEntity>><any>_observableThrow(response_);
        }));
    }

    protected processGetFile(response: HttpResponseBase): Observable<FileEntity> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? FileEntity.fromJS(resultData200) : new FileEntity();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileEntity>(<any>null);
    }
}

@Injectable()
export class PostServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param body (optional)
     * @return Success
     */
    getAll(body: PostGuidGetDto | undefined): Observable<PostDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/CMS/read/Post/GetAll";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<PostDtoPagedResultDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PostDtoPagedResultDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<PostDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PostDtoPagedResultDto.fromJS(resultData200) : new PostDtoPagedResultDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PostDtoPagedResultDto>(<any>null);
    }

    /**
     * @param body (optional)
     * @return Success
     */
    getPost(body: GuidEntityDto | undefined): Observable<PostOutputDto> {
        let url_ = this.baseUrl + "/api/services/CMS/read/Post/GetPost";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPost(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPost(<any>response_);
                } catch (e) {
                    return <Observable<PostOutputDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PostOutputDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetPost(response: HttpResponseBase): Observable<PostOutputDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PostOutputDto.fromJS(resultData200) : new PostOutputDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PostOutputDto>(<any>null);
    }

    /**
     * @param body (optional)
     * @return Success
     */
    create(body: PostInputDto | undefined): Observable<PostOutputDto> {
        let url_ = this.baseUrl + "/api/services/CMS/write/Post/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(<any>response_);
                } catch (e) {
                    return <Observable<PostOutputDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PostOutputDto>><any>_observableThrow(response_);
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<PostOutputDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PostOutputDto.fromJS(resultData200) : new PostOutputDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PostOutputDto>(<any>null);
    }

    /**
     * @param body (optional)
     * @return Success
     */
    update(body: PostInputDto | undefined): Observable<PostOutputDto> {
        let url_ = this.baseUrl + "/api/services/CMS/write/Post/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(<any>response_);
                } catch (e) {
                    return <Observable<PostOutputDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PostOutputDto>><any>_observableThrow(response_);
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<PostOutputDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PostOutputDto.fromJS(resultData200) : new PostOutputDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PostOutputDto>(<any>null);
    }

    /**
     * @param body (optional)
     * @return Success
     */
    delete(body: GuidEntityDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/CMS/write/Post/Delete";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class PostClientServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param body (optional)
     * @return Success
     */
    getAll(body: PostGuidGetDto | undefined): Observable<ValuePostDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/CMS/read/PostClient/GetAll";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<ValuePostDtoPagedResultDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ValuePostDtoPagedResultDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<ValuePostDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ValuePostDtoPagedResultDto.fromJS(resultData200) : new ValuePostDtoPagedResultDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ValuePostDtoPagedResultDto>(<any>null);
    }

    /**
     * @param body (optional)
     * @return Success
     */
    getPost(body: PostGuidGetDto | undefined): Observable<PostOutputDto> {
        let url_ = this.baseUrl + "/api/services/CMS/read/PostClient/GetPost";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPost(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPost(<any>response_);
                } catch (e) {
                    return <Observable<PostOutputDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PostOutputDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetPost(response: HttpResponseBase): Observable<PostOutputDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PostOutputDto.fromJS(resultData200) : new PostOutputDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PostOutputDto>(<any>null);
    }

    /**
     * @param body (optional)
     * @return Success
     */
    getPostByCode(body: PostGuidGetDto | undefined): Observable<PostOutputDto> {
        let url_ = this.baseUrl + "/api/services/CMS/read/PostClient/GetPostByCode";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPostByCode(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPostByCode(<any>response_);
                } catch (e) {
                    return <Observable<PostOutputDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PostOutputDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetPostByCode(response: HttpResponseBase): Observable<PostOutputDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PostOutputDto.fromJS(resultData200) : new PostOutputDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PostOutputDto>(<any>null);
    }
}

@Injectable()
export class SettingServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param body (optional)
     * @return Success
     */
    getList(body: SettingEntityGuidGetDto | undefined): Observable<SettingOutputDto[]> {
        let url_ = this.baseUrl + "/api/services/DATA/read/Setting/GetList";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetList(<any>response_);
                } catch (e) {
                    return <Observable<SettingOutputDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<SettingOutputDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetList(response: HttpResponseBase): Observable<SettingOutputDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(SettingOutputDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SettingOutputDto[]>(<any>null);
    }

    /**
     * @param body (optional)
     * @return Success
     */
    getSetting(body: GuidEntityDto | undefined): Observable<SettingOutputDto> {
        let url_ = this.baseUrl + "/api/services/DATA/read/Setting/GetSetting";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSetting(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSetting(<any>response_);
                } catch (e) {
                    return <Observable<SettingOutputDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<SettingOutputDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetSetting(response: HttpResponseBase): Observable<SettingOutputDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? SettingOutputDto.fromJS(resultData200) : new SettingOutputDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SettingOutputDto>(<any>null);
    }

    /**
     * @param body (optional)
     * @return Success
     */
    set(body: SettingInputDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/DATA/write/Setting/Set";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSet(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processSet(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param body (optional)
     * @return Success
     */
    delete(body: SettingInputDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/DATA/write/Setting/Delete";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class SettingClientServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param body (optional)
     * @return Success
     */
    getSetting(body: GetSettingDto | undefined): Observable<string> {
        let url_ = this.baseUrl + "/api/services/DATA/read/SettingClient/GetSetting";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSetting(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSetting(<any>response_);
                } catch (e) {
                    return <Observable<string>><any>_observableThrow(e);
                }
            } else
                return <Observable<string>><any>_observableThrow(response_);
        }));
    }

    protected processGetSetting(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(<any>null);
    }

    /**
     * @param body (optional)
     * @return Success
     */
    getUserSetting(body: GetSettingDto | undefined): Observable<string> {
        let url_ = this.baseUrl + "/api/services/DATA/read/SettingClient/GetUserSetting";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetUserSetting(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUserSetting(<any>response_);
                } catch (e) {
                    return <Observable<string>><any>_observableThrow(e);
                }
            } else
                return <Observable<string>><any>_observableThrow(response_);
        }));
    }

    protected processGetUserSetting(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(<any>null);
    }

    /**
     * @param body (optional)
     * @return Success
     */
    getSettings(body: GetSettingDto | undefined): Observable<string[]> {
        let url_ = this.baseUrl + "/api/services/DATA/read/SettingClient/GetSettings";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSettings(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSettings(<any>response_);
                } catch (e) {
                    return <Observable<string[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<string[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetSettings(response: HttpResponseBase): Observable<string[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(item);
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string[]>(<any>null);
    }

    /**
     * @param body (optional)
     * @return Success
     */
    getUserSettings(body: GetSettingDto | undefined): Observable<string[]> {
        let url_ = this.baseUrl + "/api/services/DATA/read/SettingClient/GetUserSettings";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetUserSettings(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUserSettings(<any>response_);
                } catch (e) {
                    return <Observable<string[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<string[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetUserSettings(response: HttpResponseBase): Observable<string[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(item);
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string[]>(<any>null);
    }
}

export enum OperationCriteria {
    _0 = 0,
    _1 = 1,
    _2 = 2,
    _3 = 3,
    _4 = 4,
    _5 = 5,
    _6 = 6,
    _7 = 7,
    _8 = 8,
    _9 = 9,
    _10 = 10,
}

export class CriteriaRequestDto implements ICriteriaRequestDto {
    propertyName: string | undefined;
    operation: OperationCriteria;
    value: string | undefined;

    constructor(data?: ICriteriaRequestDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.propertyName = data["propertyName"];
            this.operation = data["operation"];
            this.value = data["value"];
        }
    }

    static fromJS(data: any): CriteriaRequestDto {
        data = typeof data === 'object' ? data : {};
        let result = new CriteriaRequestDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["propertyName"] = this.propertyName;
        data["operation"] = this.operation;
        data["value"] = this.value;
        return data;
    }

    clone(): CriteriaRequestDto {
        const json = this.toJSON();
        let result = new CriteriaRequestDto();
        result.init(json);
        return result;
    }
}

export interface ICriteriaRequestDto {
    propertyName: string | undefined;
    operation: OperationCriteria;
    value: string | undefined;
}

export class CategoryGuidGetDto implements ICategoryGuidGetDto {
    maxResultCount: number;
    skipCount: number;
    sorting: string | undefined;
    criterias: CriteriaRequestDto[] | undefined;
    tenantId: number | undefined;
    userId: number | undefined;
    id: string;
    language: string | undefined;
    option: string | undefined;
    search: string | undefined;
    status: string | undefined;
    from: moment.Moment | undefined;
    to: moment.Moment | undefined;
    sValue: string[] | undefined;
    lValue: number[] | undefined;
    gValue: string[] | undefined;
    dValue: number[] | undefined;
    tValue: moment.Moment[] | undefined;

    constructor(data?: ICategoryGuidGetDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.maxResultCount = data["maxResultCount"];
            this.skipCount = data["skipCount"];
            this.sorting = data["sorting"];
            if (data["criterias"] && data["criterias"].constructor === Array) {
                this.criterias = [] as any;
                for (let item of data["criterias"])
                    this.criterias.push(CriteriaRequestDto.fromJS(item));
            }
            this.tenantId = data["tenantId"];
            this.userId = data["userId"];
            this.id = data["id"];
            this.language = data["language"];
            this.option = data["option"];
            this.search = data["search"];
            this.status = data["status"];
            this.from = data["from"] ? moment(data["from"].toString()) : <any>undefined;
            this.to = data["to"] ? moment(data["to"].toString()) : <any>undefined;
            if (data["sValue"] && data["sValue"].constructor === Array) {
                this.sValue = [] as any;
                for (let item of data["sValue"])
                    this.sValue.push(item);
            }
            if (data["lValue"] && data["lValue"].constructor === Array) {
                this.lValue = [] as any;
                for (let item of data["lValue"])
                    this.lValue.push(item);
            }
            if (data["gValue"] && data["gValue"].constructor === Array) {
                this.gValue = [] as any;
                for (let item of data["gValue"])
                    this.gValue.push(item);
            }
            if (data["dValue"] && data["dValue"].constructor === Array) {
                this.dValue = [] as any;
                for (let item of data["dValue"])
                    this.dValue.push(item);
            }
            if (data["tValue"] && data["tValue"].constructor === Array) {
                this.tValue = [] as any;
                for (let item of data["tValue"])
                    this.tValue.push(moment(item));
            }
        }
    }

    static fromJS(data: any): CategoryGuidGetDto {
        data = typeof data === 'object' ? data : {};
        let result = new CategoryGuidGetDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["maxResultCount"] = this.maxResultCount;
        data["skipCount"] = this.skipCount;
        data["sorting"] = this.sorting;
        if (this.criterias && this.criterias.constructor === Array) {
            data["criterias"] = [];
            for (let item of this.criterias)
                data["criterias"].push(item.toJSON());
        }
        data["tenantId"] = this.tenantId;
        data["userId"] = this.userId;
        data["id"] = this.id;
        data["language"] = this.language;
        data["option"] = this.option;
        data["search"] = this.search;
        data["status"] = this.status;
        data["from"] = this.from ? this.from.toISOString() : <any>undefined;
        data["to"] = this.to ? this.to.toISOString() : <any>undefined;
        if (this.sValue && this.sValue.constructor === Array) {
            data["sValue"] = [];
            for (let item of this.sValue)
                data["sValue"].push(item);
        }
        if (this.lValue && this.lValue.constructor === Array) {
            data["lValue"] = [];
            for (let item of this.lValue)
                data["lValue"].push(item);
        }
        if (this.gValue && this.gValue.constructor === Array) {
            data["gValue"] = [];
            for (let item of this.gValue)
                data["gValue"].push(item);
        }
        if (this.dValue && this.dValue.constructor === Array) {
            data["dValue"] = [];
            for (let item of this.dValue)
                data["dValue"].push(item);
        }
        if (this.tValue && this.tValue.constructor === Array) {
            data["tValue"] = [];
            for (let item of this.tValue)
                data["tValue"].push(item.toISOString());
        }
        return data;
    }

    clone(): CategoryGuidGetDto {
        const json = this.toJSON();
        let result = new CategoryGuidGetDto();
        result.init(json);
        return result;
    }
}

export interface ICategoryGuidGetDto {
    maxResultCount: number;
    skipCount: number;
    sorting: string | undefined;
    criterias: CriteriaRequestDto[] | undefined;
    tenantId: number | undefined;
    userId: number | undefined;
    id: string;
    language: string | undefined;
    option: string | undefined;
    search: string | undefined;
    status: string | undefined;
    from: moment.Moment | undefined;
    to: moment.Moment | undefined;
    sValue: string[] | undefined;
    lValue: number[] | undefined;
    gValue: string[] | undefined;
    dValue: number[] | undefined;
    tValue: moment.Moment[] | undefined;
}

export class CategoryOutputDto implements ICategoryOutputDto {
    id: string;
    tenantId: number | undefined;
    status: string | undefined;
    search: string | undefined;
    hideValue: string | undefined;
    creatorUserId: number | undefined;
    creationTime: moment.Moment;
    name: string | undefined;
    code: string | undefined;
    codeData: string | undefined;
    valueData: string | undefined;
    category: string | undefined;
    permissions: string | undefined;
    language: string | undefined;
    value1: string | undefined;
    value2: string | undefined;
    value3: string | undefined;
    value4: string | undefined;
    value5: string | undefined;
    value6: string | undefined;
    value7: string | undefined;
    value8: string | undefined;
    value9: string | undefined;
    value10: string | undefined;
    number1: number;
    number2: number;
    number3: number;
    number4: number;
    number5: number;
    number6: number;
    number7: number;
    number8: number;
    number9: number;
    number10: number;
    parentId: string | undefined;
    index: number;
    order: number;
    groupCode: string | undefined;
    hashCode: string | undefined;
    group: string | undefined;
    parentCode: string | undefined;
    parentName: string | undefined;

    constructor(data?: ICategoryOutputDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.tenantId = data["tenantId"];
            this.status = data["status"];
            this.search = data["search"];
            this.hideValue = data["hideValue"];
            this.creatorUserId = data["creatorUserId"];
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.name = data["name"];
            this.code = data["code"];
            this.codeData = data["codeData"];
            this.valueData = data["valueData"];
            this.category = data["category"];
            this.permissions = data["permissions"];
            this.language = data["language"];
            this.value1 = data["value1"];
            this.value2 = data["value2"];
            this.value3 = data["value3"];
            this.value4 = data["value4"];
            this.value5 = data["value5"];
            this.value6 = data["value6"];
            this.value7 = data["value7"];
            this.value8 = data["value8"];
            this.value9 = data["value9"];
            this.value10 = data["value10"];
            this.number1 = data["number1"];
            this.number2 = data["number2"];
            this.number3 = data["number3"];
            this.number4 = data["number4"];
            this.number5 = data["number5"];
            this.number6 = data["number6"];
            this.number7 = data["number7"];
            this.number8 = data["number8"];
            this.number9 = data["number9"];
            this.number10 = data["number10"];
            this.parentId = data["parentId"];
            this.index = data["index"];
            this.order = data["order"];
            this.groupCode = data["groupCode"];
            this.hashCode = data["hashCode"];
            this.group = data["group"];
            this.parentCode = data["parentCode"];
            this.parentName = data["parentName"];
        }
    }

    static fromJS(data: any): CategoryOutputDto {
        data = typeof data === 'object' ? data : {};
        let result = new CategoryOutputDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["tenantId"] = this.tenantId;
        data["status"] = this.status;
        data["search"] = this.search;
        data["hideValue"] = this.hideValue;
        data["creatorUserId"] = this.creatorUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["name"] = this.name;
        data["code"] = this.code;
        data["codeData"] = this.codeData;
        data["valueData"] = this.valueData;
        data["category"] = this.category;
        data["permissions"] = this.permissions;
        data["language"] = this.language;
        data["value1"] = this.value1;
        data["value2"] = this.value2;
        data["value3"] = this.value3;
        data["value4"] = this.value4;
        data["value5"] = this.value5;
        data["value6"] = this.value6;
        data["value7"] = this.value7;
        data["value8"] = this.value8;
        data["value9"] = this.value9;
        data["value10"] = this.value10;
        data["number1"] = this.number1;
        data["number2"] = this.number2;
        data["number3"] = this.number3;
        data["number4"] = this.number4;
        data["number5"] = this.number5;
        data["number6"] = this.number6;
        data["number7"] = this.number7;
        data["number8"] = this.number8;
        data["number9"] = this.number9;
        data["number10"] = this.number10;
        data["parentId"] = this.parentId;
        data["index"] = this.index;
        data["order"] = this.order;
        data["groupCode"] = this.groupCode;
        data["hashCode"] = this.hashCode;
        data["group"] = this.group;
        data["parentCode"] = this.parentCode;
        data["parentName"] = this.parentName;
        return data;
    }

    clone(): CategoryOutputDto {
        const json = this.toJSON();
        let result = new CategoryOutputDto();
        result.init(json);
        return result;
    }
}

export interface ICategoryOutputDto {
    id: string;
    tenantId: number | undefined;
    status: string | undefined;
    search: string | undefined;
    hideValue: string | undefined;
    creatorUserId: number | undefined;
    creationTime: moment.Moment;
    name: string | undefined;
    code: string | undefined;
    codeData: string | undefined;
    valueData: string | undefined;
    category: string | undefined;
    permissions: string | undefined;
    language: string | undefined;
    value1: string | undefined;
    value2: string | undefined;
    value3: string | undefined;
    value4: string | undefined;
    value5: string | undefined;
    value6: string | undefined;
    value7: string | undefined;
    value8: string | undefined;
    value9: string | undefined;
    value10: string | undefined;
    number1: number;
    number2: number;
    number3: number;
    number4: number;
    number5: number;
    number6: number;
    number7: number;
    number8: number;
    number9: number;
    number10: number;
    parentId: string | undefined;
    index: number;
    order: number;
    groupCode: string | undefined;
    hashCode: string | undefined;
    group: string | undefined;
    parentCode: string | undefined;
    parentName: string | undefined;
}

export class GuidEntityDto implements IGuidEntityDto {
    id: string;

    constructor(data?: IGuidEntityDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
        }
    }

    static fromJS(data: any): GuidEntityDto {
        data = typeof data === 'object' ? data : {};
        let result = new GuidEntityDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        return data;
    }

    clone(): GuidEntityDto {
        const json = this.toJSON();
        let result = new GuidEntityDto();
        result.init(json);
        return result;
    }
}

export interface IGuidEntityDto {
    id: string;
}

export class CategoryInputDto implements ICategoryInputDto {
    id: string;
    tenantId: number | undefined;
    status: string | undefined;
    search: string | undefined;
    hideValue: string | undefined;
    creatorUserId: number | undefined;
    creationTime: moment.Moment;
    name: string | undefined;
    code: string | undefined;
    codeData: string | undefined;
    valueData: string | undefined;
    category: string | undefined;
    permissions: string | undefined;
    language: string | undefined;
    value1: string | undefined;
    value2: string | undefined;
    value3: string | undefined;
    value4: string | undefined;
    value5: string | undefined;
    value6: string | undefined;
    value7: string | undefined;
    value8: string | undefined;
    value9: string | undefined;
    value10: string | undefined;
    number1: number;
    number2: number;
    number3: number;
    number4: number;
    number5: number;
    number6: number;
    number7: number;
    number8: number;
    number9: number;
    number10: number;
    parentId: string | undefined;
    index: number;
    order: number;
    groupCode: string | undefined;
    hashCode: string | undefined;
    group: string | undefined;

    constructor(data?: ICategoryInputDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.tenantId = data["tenantId"];
            this.status = data["status"];
            this.search = data["search"];
            this.hideValue = data["hideValue"];
            this.creatorUserId = data["creatorUserId"];
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.name = data["name"];
            this.code = data["code"];
            this.codeData = data["codeData"];
            this.valueData = data["valueData"];
            this.category = data["category"];
            this.permissions = data["permissions"];
            this.language = data["language"];
            this.value1 = data["value1"];
            this.value2 = data["value2"];
            this.value3 = data["value3"];
            this.value4 = data["value4"];
            this.value5 = data["value5"];
            this.value6 = data["value6"];
            this.value7 = data["value7"];
            this.value8 = data["value8"];
            this.value9 = data["value9"];
            this.value10 = data["value10"];
            this.number1 = data["number1"];
            this.number2 = data["number2"];
            this.number3 = data["number3"];
            this.number4 = data["number4"];
            this.number5 = data["number5"];
            this.number6 = data["number6"];
            this.number7 = data["number7"];
            this.number8 = data["number8"];
            this.number9 = data["number9"];
            this.number10 = data["number10"];
            this.parentId = data["parentId"];
            this.index = data["index"];
            this.order = data["order"];
            this.groupCode = data["groupCode"];
            this.hashCode = data["hashCode"];
            this.group = data["group"];
        }
    }

    static fromJS(data: any): CategoryInputDto {
        data = typeof data === 'object' ? data : {};
        let result = new CategoryInputDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["tenantId"] = this.tenantId;
        data["status"] = this.status;
        data["search"] = this.search;
        data["hideValue"] = this.hideValue;
        data["creatorUserId"] = this.creatorUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["name"] = this.name;
        data["code"] = this.code;
        data["codeData"] = this.codeData;
        data["valueData"] = this.valueData;
        data["category"] = this.category;
        data["permissions"] = this.permissions;
        data["language"] = this.language;
        data["value1"] = this.value1;
        data["value2"] = this.value2;
        data["value3"] = this.value3;
        data["value4"] = this.value4;
        data["value5"] = this.value5;
        data["value6"] = this.value6;
        data["value7"] = this.value7;
        data["value8"] = this.value8;
        data["value9"] = this.value9;
        data["value10"] = this.value10;
        data["number1"] = this.number1;
        data["number2"] = this.number2;
        data["number3"] = this.number3;
        data["number4"] = this.number4;
        data["number5"] = this.number5;
        data["number6"] = this.number6;
        data["number7"] = this.number7;
        data["number8"] = this.number8;
        data["number9"] = this.number9;
        data["number10"] = this.number10;
        data["parentId"] = this.parentId;
        data["index"] = this.index;
        data["order"] = this.order;
        data["groupCode"] = this.groupCode;
        data["hashCode"] = this.hashCode;
        data["group"] = this.group;
        return data;
    }

    clone(): CategoryInputDto {
        const json = this.toJSON();
        let result = new CategoryInputDto();
        result.init(json);
        return result;
    }
}

export interface ICategoryInputDto {
    id: string;
    tenantId: number | undefined;
    status: string | undefined;
    search: string | undefined;
    hideValue: string | undefined;
    creatorUserId: number | undefined;
    creationTime: moment.Moment;
    name: string | undefined;
    code: string | undefined;
    codeData: string | undefined;
    valueData: string | undefined;
    category: string | undefined;
    permissions: string | undefined;
    language: string | undefined;
    value1: string | undefined;
    value2: string | undefined;
    value3: string | undefined;
    value4: string | undefined;
    value5: string | undefined;
    value6: string | undefined;
    value7: string | undefined;
    value8: string | undefined;
    value9: string | undefined;
    value10: string | undefined;
    number1: number;
    number2: number;
    number3: number;
    number4: number;
    number5: number;
    number6: number;
    number7: number;
    number8: number;
    number9: number;
    number10: number;
    parentId: string | undefined;
    index: number;
    order: number;
    groupCode: string | undefined;
    hashCode: string | undefined;
    group: string | undefined;
}

export class ContactGuidGetDto implements IContactGuidGetDto {
    maxResultCount: number;
    skipCount: number;
    sorting: string | undefined;
    criterias: CriteriaRequestDto[] | undefined;
    tenantId: number | undefined;
    userId: number | undefined;
    id: string;
    language: string | undefined;
    option: string | undefined;
    search: string | undefined;
    status: string | undefined;
    from: moment.Moment | undefined;
    to: moment.Moment | undefined;
    sValue: string[] | undefined;
    lValue: number[] | undefined;
    gValue: string[] | undefined;
    dValue: number[] | undefined;
    tValue: moment.Moment[] | undefined;

    constructor(data?: IContactGuidGetDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.maxResultCount = data["maxResultCount"];
            this.skipCount = data["skipCount"];
            this.sorting = data["sorting"];
            if (data["criterias"] && data["criterias"].constructor === Array) {
                this.criterias = [] as any;
                for (let item of data["criterias"])
                    this.criterias.push(CriteriaRequestDto.fromJS(item));
            }
            this.tenantId = data["tenantId"];
            this.userId = data["userId"];
            this.id = data["id"];
            this.language = data["language"];
            this.option = data["option"];
            this.search = data["search"];
            this.status = data["status"];
            this.from = data["from"] ? moment(data["from"].toString()) : <any>undefined;
            this.to = data["to"] ? moment(data["to"].toString()) : <any>undefined;
            if (data["sValue"] && data["sValue"].constructor === Array) {
                this.sValue = [] as any;
                for (let item of data["sValue"])
                    this.sValue.push(item);
            }
            if (data["lValue"] && data["lValue"].constructor === Array) {
                this.lValue = [] as any;
                for (let item of data["lValue"])
                    this.lValue.push(item);
            }
            if (data["gValue"] && data["gValue"].constructor === Array) {
                this.gValue = [] as any;
                for (let item of data["gValue"])
                    this.gValue.push(item);
            }
            if (data["dValue"] && data["dValue"].constructor === Array) {
                this.dValue = [] as any;
                for (let item of data["dValue"])
                    this.dValue.push(item);
            }
            if (data["tValue"] && data["tValue"].constructor === Array) {
                this.tValue = [] as any;
                for (let item of data["tValue"])
                    this.tValue.push(moment(item));
            }
        }
    }

    static fromJS(data: any): ContactGuidGetDto {
        data = typeof data === 'object' ? data : {};
        let result = new ContactGuidGetDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["maxResultCount"] = this.maxResultCount;
        data["skipCount"] = this.skipCount;
        data["sorting"] = this.sorting;
        if (this.criterias && this.criterias.constructor === Array) {
            data["criterias"] = [];
            for (let item of this.criterias)
                data["criterias"].push(item.toJSON());
        }
        data["tenantId"] = this.tenantId;
        data["userId"] = this.userId;
        data["id"] = this.id;
        data["language"] = this.language;
        data["option"] = this.option;
        data["search"] = this.search;
        data["status"] = this.status;
        data["from"] = this.from ? this.from.toISOString() : <any>undefined;
        data["to"] = this.to ? this.to.toISOString() : <any>undefined;
        if (this.sValue && this.sValue.constructor === Array) {
            data["sValue"] = [];
            for (let item of this.sValue)
                data["sValue"].push(item);
        }
        if (this.lValue && this.lValue.constructor === Array) {
            data["lValue"] = [];
            for (let item of this.lValue)
                data["lValue"].push(item);
        }
        if (this.gValue && this.gValue.constructor === Array) {
            data["gValue"] = [];
            for (let item of this.gValue)
                data["gValue"].push(item);
        }
        if (this.dValue && this.dValue.constructor === Array) {
            data["dValue"] = [];
            for (let item of this.dValue)
                data["dValue"].push(item);
        }
        if (this.tValue && this.tValue.constructor === Array) {
            data["tValue"] = [];
            for (let item of this.tValue)
                data["tValue"].push(item.toISOString());
        }
        return data;
    }

    clone(): ContactGuidGetDto {
        const json = this.toJSON();
        let result = new ContactGuidGetDto();
        result.init(json);
        return result;
    }
}

export interface IContactGuidGetDto {
    maxResultCount: number;
    skipCount: number;
    sorting: string | undefined;
    criterias: CriteriaRequestDto[] | undefined;
    tenantId: number | undefined;
    userId: number | undefined;
    id: string;
    language: string | undefined;
    option: string | undefined;
    search: string | undefined;
    status: string | undefined;
    from: moment.Moment | undefined;
    to: moment.Moment | undefined;
    sValue: string[] | undefined;
    lValue: number[] | undefined;
    gValue: string[] | undefined;
    dValue: number[] | undefined;
    tValue: moment.Moment[] | undefined;
}

export class ContactDto implements IContactDto {
    id: string;
    tenantId: number | undefined;
    status: string | undefined;
    search: string | undefined;
    hideValue: string | undefined;
    creatorUserId: number | undefined;
    creationTime: moment.Moment;
    name: string | undefined;
    code: string | undefined;
    codeData: string | undefined;
    valueData: string | undefined;
    category: string | undefined;
    permissions: string | undefined;
    language: string | undefined;
    value1: string | undefined;
    value2: string | undefined;
    value3: string | undefined;
    value4: string | undefined;
    value5: string | undefined;
    value6: string | undefined;
    value7: string | undefined;
    value8: string | undefined;
    value9: string | undefined;
    value10: string | undefined;
    number1: number;
    number2: number;
    number3: number;
    number4: number;
    number5: number;
    number6: number;
    number7: number;
    number8: number;
    number9: number;
    number10: number;
    content: string | undefined;

    constructor(data?: IContactDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.tenantId = data["tenantId"];
            this.status = data["status"];
            this.search = data["search"];
            this.hideValue = data["hideValue"];
            this.creatorUserId = data["creatorUserId"];
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.name = data["name"];
            this.code = data["code"];
            this.codeData = data["codeData"];
            this.valueData = data["valueData"];
            this.category = data["category"];
            this.permissions = data["permissions"];
            this.language = data["language"];
            this.value1 = data["value1"];
            this.value2 = data["value2"];
            this.value3 = data["value3"];
            this.value4 = data["value4"];
            this.value5 = data["value5"];
            this.value6 = data["value6"];
            this.value7 = data["value7"];
            this.value8 = data["value8"];
            this.value9 = data["value9"];
            this.value10 = data["value10"];
            this.number1 = data["number1"];
            this.number2 = data["number2"];
            this.number3 = data["number3"];
            this.number4 = data["number4"];
            this.number5 = data["number5"];
            this.number6 = data["number6"];
            this.number7 = data["number7"];
            this.number8 = data["number8"];
            this.number9 = data["number9"];
            this.number10 = data["number10"];
            this.content = data["content"];
        }
    }

    static fromJS(data: any): ContactDto {
        data = typeof data === 'object' ? data : {};
        let result = new ContactDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["tenantId"] = this.tenantId;
        data["status"] = this.status;
        data["search"] = this.search;
        data["hideValue"] = this.hideValue;
        data["creatorUserId"] = this.creatorUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["name"] = this.name;
        data["code"] = this.code;
        data["codeData"] = this.codeData;
        data["valueData"] = this.valueData;
        data["category"] = this.category;
        data["permissions"] = this.permissions;
        data["language"] = this.language;
        data["value1"] = this.value1;
        data["value2"] = this.value2;
        data["value3"] = this.value3;
        data["value4"] = this.value4;
        data["value5"] = this.value5;
        data["value6"] = this.value6;
        data["value7"] = this.value7;
        data["value8"] = this.value8;
        data["value9"] = this.value9;
        data["value10"] = this.value10;
        data["number1"] = this.number1;
        data["number2"] = this.number2;
        data["number3"] = this.number3;
        data["number4"] = this.number4;
        data["number5"] = this.number5;
        data["number6"] = this.number6;
        data["number7"] = this.number7;
        data["number8"] = this.number8;
        data["number9"] = this.number9;
        data["number10"] = this.number10;
        data["content"] = this.content;
        return data;
    }

    clone(): ContactDto {
        const json = this.toJSON();
        let result = new ContactDto();
        result.init(json);
        return result;
    }
}

export interface IContactDto {
    id: string;
    tenantId: number | undefined;
    status: string | undefined;
    search: string | undefined;
    hideValue: string | undefined;
    creatorUserId: number | undefined;
    creationTime: moment.Moment;
    name: string | undefined;
    code: string | undefined;
    codeData: string | undefined;
    valueData: string | undefined;
    category: string | undefined;
    permissions: string | undefined;
    language: string | undefined;
    value1: string | undefined;
    value2: string | undefined;
    value3: string | undefined;
    value4: string | undefined;
    value5: string | undefined;
    value6: string | undefined;
    value7: string | undefined;
    value8: string | undefined;
    value9: string | undefined;
    value10: string | undefined;
    number1: number;
    number2: number;
    number3: number;
    number4: number;
    number5: number;
    number6: number;
    number7: number;
    number8: number;
    number9: number;
    number10: number;
    content: string | undefined;
}

export class ContactDtoPagedResultDto implements IContactDtoPagedResultDto {
    items: ContactDto[] | undefined;
    totalCount: number;

    constructor(data?: IContactDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items.push(ContactDto.fromJS(item));
            }
            this.totalCount = data["totalCount"];
        }
    }

    static fromJS(data: any): ContactDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new ContactDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data;
    }

    clone(): ContactDtoPagedResultDto {
        const json = this.toJSON();
        let result = new ContactDtoPagedResultDto();
        result.init(json);
        return result;
    }
}

export interface IContactDtoPagedResultDto {
    items: ContactDto[] | undefined;
    totalCount: number;
}

export class ContactOutputDto implements IContactOutputDto {
    id: string;
    tenantId: number | undefined;
    status: string | undefined;
    search: string | undefined;
    hideValue: string | undefined;
    creatorUserId: number | undefined;
    creationTime: moment.Moment;
    name: string | undefined;
    code: string | undefined;
    codeData: string | undefined;
    valueData: string | undefined;
    category: string | undefined;
    permissions: string | undefined;
    language: string | undefined;
    value1: string | undefined;
    value2: string | undefined;
    value3: string | undefined;
    value4: string | undefined;
    value5: string | undefined;
    value6: string | undefined;
    value7: string | undefined;
    value8: string | undefined;
    value9: string | undefined;
    value10: string | undefined;
    number1: number;
    number2: number;
    number3: number;
    number4: number;
    number5: number;
    number6: number;
    number7: number;
    number8: number;
    number9: number;
    number10: number;
    content: string | undefined;

    constructor(data?: IContactOutputDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.tenantId = data["tenantId"];
            this.status = data["status"];
            this.search = data["search"];
            this.hideValue = data["hideValue"];
            this.creatorUserId = data["creatorUserId"];
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.name = data["name"];
            this.code = data["code"];
            this.codeData = data["codeData"];
            this.valueData = data["valueData"];
            this.category = data["category"];
            this.permissions = data["permissions"];
            this.language = data["language"];
            this.value1 = data["value1"];
            this.value2 = data["value2"];
            this.value3 = data["value3"];
            this.value4 = data["value4"];
            this.value5 = data["value5"];
            this.value6 = data["value6"];
            this.value7 = data["value7"];
            this.value8 = data["value8"];
            this.value9 = data["value9"];
            this.value10 = data["value10"];
            this.number1 = data["number1"];
            this.number2 = data["number2"];
            this.number3 = data["number3"];
            this.number4 = data["number4"];
            this.number5 = data["number5"];
            this.number6 = data["number6"];
            this.number7 = data["number7"];
            this.number8 = data["number8"];
            this.number9 = data["number9"];
            this.number10 = data["number10"];
            this.content = data["content"];
        }
    }

    static fromJS(data: any): ContactOutputDto {
        data = typeof data === 'object' ? data : {};
        let result = new ContactOutputDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["tenantId"] = this.tenantId;
        data["status"] = this.status;
        data["search"] = this.search;
        data["hideValue"] = this.hideValue;
        data["creatorUserId"] = this.creatorUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["name"] = this.name;
        data["code"] = this.code;
        data["codeData"] = this.codeData;
        data["valueData"] = this.valueData;
        data["category"] = this.category;
        data["permissions"] = this.permissions;
        data["language"] = this.language;
        data["value1"] = this.value1;
        data["value2"] = this.value2;
        data["value3"] = this.value3;
        data["value4"] = this.value4;
        data["value5"] = this.value5;
        data["value6"] = this.value6;
        data["value7"] = this.value7;
        data["value8"] = this.value8;
        data["value9"] = this.value9;
        data["value10"] = this.value10;
        data["number1"] = this.number1;
        data["number2"] = this.number2;
        data["number3"] = this.number3;
        data["number4"] = this.number4;
        data["number5"] = this.number5;
        data["number6"] = this.number6;
        data["number7"] = this.number7;
        data["number8"] = this.number8;
        data["number9"] = this.number9;
        data["number10"] = this.number10;
        data["content"] = this.content;
        return data;
    }

    clone(): ContactOutputDto {
        const json = this.toJSON();
        let result = new ContactOutputDto();
        result.init(json);
        return result;
    }
}

export interface IContactOutputDto {
    id: string;
    tenantId: number | undefined;
    status: string | undefined;
    search: string | undefined;
    hideValue: string | undefined;
    creatorUserId: number | undefined;
    creationTime: moment.Moment;
    name: string | undefined;
    code: string | undefined;
    codeData: string | undefined;
    valueData: string | undefined;
    category: string | undefined;
    permissions: string | undefined;
    language: string | undefined;
    value1: string | undefined;
    value2: string | undefined;
    value3: string | undefined;
    value4: string | undefined;
    value5: string | undefined;
    value6: string | undefined;
    value7: string | undefined;
    value8: string | undefined;
    value9: string | undefined;
    value10: string | undefined;
    number1: number;
    number2: number;
    number3: number;
    number4: number;
    number5: number;
    number6: number;
    number7: number;
    number8: number;
    number9: number;
    number10: number;
    content: string | undefined;
}

export class ContactInputDto implements IContactInputDto {
    id: string;
    tenantId: number | undefined;
    status: string | undefined;
    search: string | undefined;
    hideValue: string | undefined;
    creatorUserId: number | undefined;
    creationTime: moment.Moment;
    name: string | undefined;
    code: string | undefined;
    codeData: string | undefined;
    valueData: string | undefined;
    category: string | undefined;
    permissions: string | undefined;
    language: string | undefined;
    value1: string | undefined;
    value2: string | undefined;
    value3: string | undefined;
    value4: string | undefined;
    value5: string | undefined;
    value6: string | undefined;
    value7: string | undefined;
    value8: string | undefined;
    value9: string | undefined;
    value10: string | undefined;
    number1: number;
    number2: number;
    number3: number;
    number4: number;
    number5: number;
    number6: number;
    number7: number;
    number8: number;
    number9: number;
    number10: number;
    content: string | undefined;

    constructor(data?: IContactInputDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.tenantId = data["tenantId"];
            this.status = data["status"];
            this.search = data["search"];
            this.hideValue = data["hideValue"];
            this.creatorUserId = data["creatorUserId"];
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.name = data["name"];
            this.code = data["code"];
            this.codeData = data["codeData"];
            this.valueData = data["valueData"];
            this.category = data["category"];
            this.permissions = data["permissions"];
            this.language = data["language"];
            this.value1 = data["value1"];
            this.value2 = data["value2"];
            this.value3 = data["value3"];
            this.value4 = data["value4"];
            this.value5 = data["value5"];
            this.value6 = data["value6"];
            this.value7 = data["value7"];
            this.value8 = data["value8"];
            this.value9 = data["value9"];
            this.value10 = data["value10"];
            this.number1 = data["number1"];
            this.number2 = data["number2"];
            this.number3 = data["number3"];
            this.number4 = data["number4"];
            this.number5 = data["number5"];
            this.number6 = data["number6"];
            this.number7 = data["number7"];
            this.number8 = data["number8"];
            this.number9 = data["number9"];
            this.number10 = data["number10"];
            this.content = data["content"];
        }
    }

    static fromJS(data: any): ContactInputDto {
        data = typeof data === 'object' ? data : {};
        let result = new ContactInputDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["tenantId"] = this.tenantId;
        data["status"] = this.status;
        data["search"] = this.search;
        data["hideValue"] = this.hideValue;
        data["creatorUserId"] = this.creatorUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["name"] = this.name;
        data["code"] = this.code;
        data["codeData"] = this.codeData;
        data["valueData"] = this.valueData;
        data["category"] = this.category;
        data["permissions"] = this.permissions;
        data["language"] = this.language;
        data["value1"] = this.value1;
        data["value2"] = this.value2;
        data["value3"] = this.value3;
        data["value4"] = this.value4;
        data["value5"] = this.value5;
        data["value6"] = this.value6;
        data["value7"] = this.value7;
        data["value8"] = this.value8;
        data["value9"] = this.value9;
        data["value10"] = this.value10;
        data["number1"] = this.number1;
        data["number2"] = this.number2;
        data["number3"] = this.number3;
        data["number4"] = this.number4;
        data["number5"] = this.number5;
        data["number6"] = this.number6;
        data["number7"] = this.number7;
        data["number8"] = this.number8;
        data["number9"] = this.number9;
        data["number10"] = this.number10;
        data["content"] = this.content;
        return data;
    }

    clone(): ContactInputDto {
        const json = this.toJSON();
        let result = new ContactInputDto();
        result.init(json);
        return result;
    }
}

export interface IContactInputDto {
    id: string;
    tenantId: number | undefined;
    status: string | undefined;
    search: string | undefined;
    hideValue: string | undefined;
    creatorUserId: number | undefined;
    creationTime: moment.Moment;
    name: string | undefined;
    code: string | undefined;
    codeData: string | undefined;
    valueData: string | undefined;
    category: string | undefined;
    permissions: string | undefined;
    language: string | undefined;
    value1: string | undefined;
    value2: string | undefined;
    value3: string | undefined;
    value4: string | undefined;
    value5: string | undefined;
    value6: string | undefined;
    value7: string | undefined;
    value8: string | undefined;
    value9: string | undefined;
    value10: string | undefined;
    number1: number;
    number2: number;
    number3: number;
    number4: number;
    number5: number;
    number6: number;
    number7: number;
    number8: number;
    number9: number;
    number10: number;
    content: string | undefined;
}

export class StringEntityDto implements IStringEntityDto {
    id: string | undefined;

    constructor(data?: IStringEntityDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
        }
    }

    static fromJS(data: any): StringEntityDto {
        data = typeof data === 'object' ? data : {};
        let result = new StringEntityDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        return data;
    }

    clone(): StringEntityDto {
        const json = this.toJSON();
        let result = new StringEntityDto();
        result.init(json);
        return result;
    }
}

export interface IStringEntityDto {
    id: string | undefined;
}

export class FileEntity implements IFileEntity {
    id: string | undefined;
    tenantId: number | undefined;
    userId: number | undefined;
    name: string | undefined;
    type: string | undefined;
    data: string | undefined;
    fileUrl: string | undefined;
    typeFile: string | undefined;

    constructor(data?: IFileEntity) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.tenantId = data["tenantId"];
            this.userId = data["userId"];
            this.name = data["name"];
            this.type = data["type"];
            this.data = data["data"];
            this.fileUrl = data["fileUrl"];
            this.typeFile = data["typeFile"];
        }
    }

    static fromJS(data: any): FileEntity {
        data = typeof data === 'object' ? data : {};
        let result = new FileEntity();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["tenantId"] = this.tenantId;
        data["userId"] = this.userId;
        data["name"] = this.name;
        data["type"] = this.type;
        data["data"] = this.data;
        data["fileUrl"] = this.fileUrl;
        data["typeFile"] = this.typeFile;
        return data;
    }

    clone(): FileEntity {
        const json = this.toJSON();
        let result = new FileEntity();
        result.init(json);
        return result;
    }
}

export interface IFileEntity {
    id: string | undefined;
    tenantId: number | undefined;
    userId: number | undefined;
    name: string | undefined;
    type: string | undefined;
    data: string | undefined;
    fileUrl: string | undefined;
    typeFile: string | undefined;
}

export class PostGuidGetDto implements IPostGuidGetDto {
    maxResultCount: number;
    skipCount: number;
    sorting: string | undefined;
    criterias: CriteriaRequestDto[] | undefined;
    tenantId: number | undefined;
    userId: number | undefined;
    id: string;
    language: string | undefined;
    option: string | undefined;
    search: string | undefined;
    status: string | undefined;
    from: moment.Moment | undefined;
    to: moment.Moment | undefined;
    sValue: string[] | undefined;
    lValue: number[] | undefined;
    gValue: string[] | undefined;
    dValue: number[] | undefined;
    tValue: moment.Moment[] | undefined;

    constructor(data?: IPostGuidGetDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.maxResultCount = data["maxResultCount"];
            this.skipCount = data["skipCount"];
            this.sorting = data["sorting"];
            if (data["criterias"] && data["criterias"].constructor === Array) {
                this.criterias = [] as any;
                for (let item of data["criterias"])
                    this.criterias.push(CriteriaRequestDto.fromJS(item));
            }
            this.tenantId = data["tenantId"];
            this.userId = data["userId"];
            this.id = data["id"];
            this.language = data["language"];
            this.option = data["option"];
            this.search = data["search"];
            this.status = data["status"];
            this.from = data["from"] ? moment(data["from"].toString()) : <any>undefined;
            this.to = data["to"] ? moment(data["to"].toString()) : <any>undefined;
            if (data["sValue"] && data["sValue"].constructor === Array) {
                this.sValue = [] as any;
                for (let item of data["sValue"])
                    this.sValue.push(item);
            }
            if (data["lValue"] && data["lValue"].constructor === Array) {
                this.lValue = [] as any;
                for (let item of data["lValue"])
                    this.lValue.push(item);
            }
            if (data["gValue"] && data["gValue"].constructor === Array) {
                this.gValue = [] as any;
                for (let item of data["gValue"])
                    this.gValue.push(item);
            }
            if (data["dValue"] && data["dValue"].constructor === Array) {
                this.dValue = [] as any;
                for (let item of data["dValue"])
                    this.dValue.push(item);
            }
            if (data["tValue"] && data["tValue"].constructor === Array) {
                this.tValue = [] as any;
                for (let item of data["tValue"])
                    this.tValue.push(moment(item));
            }
        }
    }

    static fromJS(data: any): PostGuidGetDto {
        data = typeof data === 'object' ? data : {};
        let result = new PostGuidGetDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["maxResultCount"] = this.maxResultCount;
        data["skipCount"] = this.skipCount;
        data["sorting"] = this.sorting;
        if (this.criterias && this.criterias.constructor === Array) {
            data["criterias"] = [];
            for (let item of this.criterias)
                data["criterias"].push(item.toJSON());
        }
        data["tenantId"] = this.tenantId;
        data["userId"] = this.userId;
        data["id"] = this.id;
        data["language"] = this.language;
        data["option"] = this.option;
        data["search"] = this.search;
        data["status"] = this.status;
        data["from"] = this.from ? this.from.toISOString() : <any>undefined;
        data["to"] = this.to ? this.to.toISOString() : <any>undefined;
        if (this.sValue && this.sValue.constructor === Array) {
            data["sValue"] = [];
            for (let item of this.sValue)
                data["sValue"].push(item);
        }
        if (this.lValue && this.lValue.constructor === Array) {
            data["lValue"] = [];
            for (let item of this.lValue)
                data["lValue"].push(item);
        }
        if (this.gValue && this.gValue.constructor === Array) {
            data["gValue"] = [];
            for (let item of this.gValue)
                data["gValue"].push(item);
        }
        if (this.dValue && this.dValue.constructor === Array) {
            data["dValue"] = [];
            for (let item of this.dValue)
                data["dValue"].push(item);
        }
        if (this.tValue && this.tValue.constructor === Array) {
            data["tValue"] = [];
            for (let item of this.tValue)
                data["tValue"].push(item.toISOString());
        }
        return data;
    }

    clone(): PostGuidGetDto {
        const json = this.toJSON();
        let result = new PostGuidGetDto();
        result.init(json);
        return result;
    }
}

export interface IPostGuidGetDto {
    maxResultCount: number;
    skipCount: number;
    sorting: string | undefined;
    criterias: CriteriaRequestDto[] | undefined;
    tenantId: number | undefined;
    userId: number | undefined;
    id: string;
    language: string | undefined;
    option: string | undefined;
    search: string | undefined;
    status: string | undefined;
    from: moment.Moment | undefined;
    to: moment.Moment | undefined;
    sValue: string[] | undefined;
    lValue: number[] | undefined;
    gValue: string[] | undefined;
    dValue: number[] | undefined;
    tValue: moment.Moment[] | undefined;
}

export class PostDto implements IPostDto {
    id: string;
    tenantId: number | undefined;
    status: string | undefined;
    search: string | undefined;
    hideValue: string | undefined;
    creatorUserId: number | undefined;
    creationTime: moment.Moment;
    name: string | undefined;
    code: string | undefined;
    codeData: string | undefined;
    valueData: string | undefined;
    category: string | undefined;
    permissions: string | undefined;
    language: string | undefined;
    value1: string | undefined;
    value2: string | undefined;
    value3: string | undefined;
    value4: string | undefined;
    value5: string | undefined;
    value6: string | undefined;
    value7: string | undefined;
    value8: string | undefined;
    value9: string | undefined;
    value10: string | undefined;
    number1: number;
    number2: number;
    number3: number;
    number4: number;
    number5: number;
    number6: number;
    number7: number;
    number8: number;
    number9: number;
    number10: number;
    categoryId: string | undefined;
    description: string | undefined;
    content: string | undefined;
    files: string | undefined;

    constructor(data?: IPostDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.tenantId = data["tenantId"];
            this.status = data["status"];
            this.search = data["search"];
            this.hideValue = data["hideValue"];
            this.creatorUserId = data["creatorUserId"];
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.name = data["name"];
            this.code = data["code"];
            this.codeData = data["codeData"];
            this.valueData = data["valueData"];
            this.category = data["category"];
            this.permissions = data["permissions"];
            this.language = data["language"];
            this.value1 = data["value1"];
            this.value2 = data["value2"];
            this.value3 = data["value3"];
            this.value4 = data["value4"];
            this.value5 = data["value5"];
            this.value6 = data["value6"];
            this.value7 = data["value7"];
            this.value8 = data["value8"];
            this.value9 = data["value9"];
            this.value10 = data["value10"];
            this.number1 = data["number1"];
            this.number2 = data["number2"];
            this.number3 = data["number3"];
            this.number4 = data["number4"];
            this.number5 = data["number5"];
            this.number6 = data["number6"];
            this.number7 = data["number7"];
            this.number8 = data["number8"];
            this.number9 = data["number9"];
            this.number10 = data["number10"];
            this.categoryId = data["categoryId"];
            this.description = data["description"];
            this.content = data["content"];
            this.files = data["files"];
        }
    }

    static fromJS(data: any): PostDto {
        data = typeof data === 'object' ? data : {};
        let result = new PostDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["tenantId"] = this.tenantId;
        data["status"] = this.status;
        data["search"] = this.search;
        data["hideValue"] = this.hideValue;
        data["creatorUserId"] = this.creatorUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["name"] = this.name;
        data["code"] = this.code;
        data["codeData"] = this.codeData;
        data["valueData"] = this.valueData;
        data["category"] = this.category;
        data["permissions"] = this.permissions;
        data["language"] = this.language;
        data["value1"] = this.value1;
        data["value2"] = this.value2;
        data["value3"] = this.value3;
        data["value4"] = this.value4;
        data["value5"] = this.value5;
        data["value6"] = this.value6;
        data["value7"] = this.value7;
        data["value8"] = this.value8;
        data["value9"] = this.value9;
        data["value10"] = this.value10;
        data["number1"] = this.number1;
        data["number2"] = this.number2;
        data["number3"] = this.number3;
        data["number4"] = this.number4;
        data["number5"] = this.number5;
        data["number6"] = this.number6;
        data["number7"] = this.number7;
        data["number8"] = this.number8;
        data["number9"] = this.number9;
        data["number10"] = this.number10;
        data["categoryId"] = this.categoryId;
        data["description"] = this.description;
        data["content"] = this.content;
        data["files"] = this.files;
        return data;
    }

    clone(): PostDto {
        const json = this.toJSON();
        let result = new PostDto();
        result.init(json);
        return result;
    }
}

export interface IPostDto {
    id: string;
    tenantId: number | undefined;
    status: string | undefined;
    search: string | undefined;
    hideValue: string | undefined;
    creatorUserId: number | undefined;
    creationTime: moment.Moment;
    name: string | undefined;
    code: string | undefined;
    codeData: string | undefined;
    valueData: string | undefined;
    category: string | undefined;
    permissions: string | undefined;
    language: string | undefined;
    value1: string | undefined;
    value2: string | undefined;
    value3: string | undefined;
    value4: string | undefined;
    value5: string | undefined;
    value6: string | undefined;
    value7: string | undefined;
    value8: string | undefined;
    value9: string | undefined;
    value10: string | undefined;
    number1: number;
    number2: number;
    number3: number;
    number4: number;
    number5: number;
    number6: number;
    number7: number;
    number8: number;
    number9: number;
    number10: number;
    categoryId: string | undefined;
    description: string | undefined;
    content: string | undefined;
    files: string | undefined;
}

export class PostDtoPagedResultDto implements IPostDtoPagedResultDto {
    items: PostDto[] | undefined;
    totalCount: number;

    constructor(data?: IPostDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items.push(PostDto.fromJS(item));
            }
            this.totalCount = data["totalCount"];
        }
    }

    static fromJS(data: any): PostDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new PostDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data;
    }

    clone(): PostDtoPagedResultDto {
        const json = this.toJSON();
        let result = new PostDtoPagedResultDto();
        result.init(json);
        return result;
    }
}

export interface IPostDtoPagedResultDto {
    items: PostDto[] | undefined;
    totalCount: number;
}

export class FileDto implements IFileDto {
    id: string | undefined;
    tenantId: number | undefined;
    userId: number | undefined;
    name: string | undefined;
    type: string | undefined;
    data: string | undefined;
    fileUrl: string | undefined;
    typeFile: string | undefined;

    constructor(data?: IFileDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.tenantId = data["tenantId"];
            this.userId = data["userId"];
            this.name = data["name"];
            this.type = data["type"];
            this.data = data["data"];
            this.fileUrl = data["fileUrl"];
            this.typeFile = data["typeFile"];
        }
    }

    static fromJS(data: any): FileDto {
        data = typeof data === 'object' ? data : {};
        let result = new FileDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["tenantId"] = this.tenantId;
        data["userId"] = this.userId;
        data["name"] = this.name;
        data["type"] = this.type;
        data["data"] = this.data;
        data["fileUrl"] = this.fileUrl;
        data["typeFile"] = this.typeFile;
        return data;
    }

    clone(): FileDto {
        const json = this.toJSON();
        let result = new FileDto();
        result.init(json);
        return result;
    }
}

export interface IFileDto {
    id: string | undefined;
    tenantId: number | undefined;
    userId: number | undefined;
    name: string | undefined;
    type: string | undefined;
    data: string | undefined;
    fileUrl: string | undefined;
    typeFile: string | undefined;
}

export class PostOutputDto implements IPostOutputDto {
    id: string;
    tenantId: number | undefined;
    status: string | undefined;
    search: string | undefined;
    hideValue: string | undefined;
    creatorUserId: number | undefined;
    creationTime: moment.Moment;
    name: string | undefined;
    code: string | undefined;
    codeData: string | undefined;
    valueData: string | undefined;
    category: string | undefined;
    permissions: string | undefined;
    language: string | undefined;
    value1: string | undefined;
    value2: string | undefined;
    value3: string | undefined;
    value4: string | undefined;
    value5: string | undefined;
    value6: string | undefined;
    value7: string | undefined;
    value8: string | undefined;
    value9: string | undefined;
    value10: string | undefined;
    number1: number;
    number2: number;
    number3: number;
    number4: number;
    number5: number;
    number6: number;
    number7: number;
    number8: number;
    number9: number;
    number10: number;
    categoryId: string | undefined;
    description: string | undefined;
    content: string | undefined;
    files: string | undefined;
    listFile: FileDto[] | undefined;

    constructor(data?: IPostOutputDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.tenantId = data["tenantId"];
            this.status = data["status"];
            this.search = data["search"];
            this.hideValue = data["hideValue"];
            this.creatorUserId = data["creatorUserId"];
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.name = data["name"];
            this.code = data["code"];
            this.codeData = data["codeData"];
            this.valueData = data["valueData"];
            this.category = data["category"];
            this.permissions = data["permissions"];
            this.language = data["language"];
            this.value1 = data["value1"];
            this.value2 = data["value2"];
            this.value3 = data["value3"];
            this.value4 = data["value4"];
            this.value5 = data["value5"];
            this.value6 = data["value6"];
            this.value7 = data["value7"];
            this.value8 = data["value8"];
            this.value9 = data["value9"];
            this.value10 = data["value10"];
            this.number1 = data["number1"];
            this.number2 = data["number2"];
            this.number3 = data["number3"];
            this.number4 = data["number4"];
            this.number5 = data["number5"];
            this.number6 = data["number6"];
            this.number7 = data["number7"];
            this.number8 = data["number8"];
            this.number9 = data["number9"];
            this.number10 = data["number10"];
            this.categoryId = data["categoryId"];
            this.description = data["description"];
            this.content = data["content"];
            this.files = data["files"];
            if (data["listFile"] && data["listFile"].constructor === Array) {
                this.listFile = [] as any;
                for (let item of data["listFile"])
                    this.listFile.push(FileDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PostOutputDto {
        data = typeof data === 'object' ? data : {};
        let result = new PostOutputDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["tenantId"] = this.tenantId;
        data["status"] = this.status;
        data["search"] = this.search;
        data["hideValue"] = this.hideValue;
        data["creatorUserId"] = this.creatorUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["name"] = this.name;
        data["code"] = this.code;
        data["codeData"] = this.codeData;
        data["valueData"] = this.valueData;
        data["category"] = this.category;
        data["permissions"] = this.permissions;
        data["language"] = this.language;
        data["value1"] = this.value1;
        data["value2"] = this.value2;
        data["value3"] = this.value3;
        data["value4"] = this.value4;
        data["value5"] = this.value5;
        data["value6"] = this.value6;
        data["value7"] = this.value7;
        data["value8"] = this.value8;
        data["value9"] = this.value9;
        data["value10"] = this.value10;
        data["number1"] = this.number1;
        data["number2"] = this.number2;
        data["number3"] = this.number3;
        data["number4"] = this.number4;
        data["number5"] = this.number5;
        data["number6"] = this.number6;
        data["number7"] = this.number7;
        data["number8"] = this.number8;
        data["number9"] = this.number9;
        data["number10"] = this.number10;
        data["categoryId"] = this.categoryId;
        data["description"] = this.description;
        data["content"] = this.content;
        data["files"] = this.files;
        if (this.listFile && this.listFile.constructor === Array) {
            data["listFile"] = [];
            for (let item of this.listFile)
                data["listFile"].push(item.toJSON());
        }
        return data;
    }

    clone(): PostOutputDto {
        const json = this.toJSON();
        let result = new PostOutputDto();
        result.init(json);
        return result;
    }
}

export interface IPostOutputDto {
    id: string;
    tenantId: number | undefined;
    status: string | undefined;
    search: string | undefined;
    hideValue: string | undefined;
    creatorUserId: number | undefined;
    creationTime: moment.Moment;
    name: string | undefined;
    code: string | undefined;
    codeData: string | undefined;
    valueData: string | undefined;
    category: string | undefined;
    permissions: string | undefined;
    language: string | undefined;
    value1: string | undefined;
    value2: string | undefined;
    value3: string | undefined;
    value4: string | undefined;
    value5: string | undefined;
    value6: string | undefined;
    value7: string | undefined;
    value8: string | undefined;
    value9: string | undefined;
    value10: string | undefined;
    number1: number;
    number2: number;
    number3: number;
    number4: number;
    number5: number;
    number6: number;
    number7: number;
    number8: number;
    number9: number;
    number10: number;
    categoryId: string | undefined;
    description: string | undefined;
    content: string | undefined;
    files: string | undefined;
    listFile: FileDto[] | undefined;
}

export class PostInputDto implements IPostInputDto {
    id: string;
    tenantId: number | undefined;
    status: string | undefined;
    search: string | undefined;
    hideValue: string | undefined;
    creatorUserId: number | undefined;
    creationTime: moment.Moment;
    name: string | undefined;
    code: string | undefined;
    codeData: string | undefined;
    valueData: string | undefined;
    category: string | undefined;
    permissions: string | undefined;
    language: string | undefined;
    value1: string | undefined;
    value2: string | undefined;
    value3: string | undefined;
    value4: string | undefined;
    value5: string | undefined;
    value6: string | undefined;
    value7: string | undefined;
    value8: string | undefined;
    value9: string | undefined;
    value10: string | undefined;
    number1: number;
    number2: number;
    number3: number;
    number4: number;
    number5: number;
    number6: number;
    number7: number;
    number8: number;
    number9: number;
    number10: number;
    categoryId: string | undefined;
    description: string | undefined;
    content: string | undefined;
    files: string | undefined;
    listFile: FileDto[] | undefined;

    constructor(data?: IPostInputDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.tenantId = data["tenantId"];
            this.status = data["status"];
            this.search = data["search"];
            this.hideValue = data["hideValue"];
            this.creatorUserId = data["creatorUserId"];
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.name = data["name"];
            this.code = data["code"];
            this.codeData = data["codeData"];
            this.valueData = data["valueData"];
            this.category = data["category"];
            this.permissions = data["permissions"];
            this.language = data["language"];
            this.value1 = data["value1"];
            this.value2 = data["value2"];
            this.value3 = data["value3"];
            this.value4 = data["value4"];
            this.value5 = data["value5"];
            this.value6 = data["value6"];
            this.value7 = data["value7"];
            this.value8 = data["value8"];
            this.value9 = data["value9"];
            this.value10 = data["value10"];
            this.number1 = data["number1"];
            this.number2 = data["number2"];
            this.number3 = data["number3"];
            this.number4 = data["number4"];
            this.number5 = data["number5"];
            this.number6 = data["number6"];
            this.number7 = data["number7"];
            this.number8 = data["number8"];
            this.number9 = data["number9"];
            this.number10 = data["number10"];
            this.categoryId = data["categoryId"];
            this.description = data["description"];
            this.content = data["content"];
            this.files = data["files"];
            if (data["listFile"] && data["listFile"].constructor === Array) {
                this.listFile = [] as any;
                for (let item of data["listFile"])
                    this.listFile.push(FileDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PostInputDto {
        data = typeof data === 'object' ? data : {};
        let result = new PostInputDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["tenantId"] = this.tenantId;
        data["status"] = this.status;
        data["search"] = this.search;
        data["hideValue"] = this.hideValue;
        data["creatorUserId"] = this.creatorUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["name"] = this.name;
        data["code"] = this.code;
        data["codeData"] = this.codeData;
        data["valueData"] = this.valueData;
        data["category"] = this.category;
        data["permissions"] = this.permissions;
        data["language"] = this.language;
        data["value1"] = this.value1;
        data["value2"] = this.value2;
        data["value3"] = this.value3;
        data["value4"] = this.value4;
        data["value5"] = this.value5;
        data["value6"] = this.value6;
        data["value7"] = this.value7;
        data["value8"] = this.value8;
        data["value9"] = this.value9;
        data["value10"] = this.value10;
        data["number1"] = this.number1;
        data["number2"] = this.number2;
        data["number3"] = this.number3;
        data["number4"] = this.number4;
        data["number5"] = this.number5;
        data["number6"] = this.number6;
        data["number7"] = this.number7;
        data["number8"] = this.number8;
        data["number9"] = this.number9;
        data["number10"] = this.number10;
        data["categoryId"] = this.categoryId;
        data["description"] = this.description;
        data["content"] = this.content;
        data["files"] = this.files;
        if (this.listFile && this.listFile.constructor === Array) {
            data["listFile"] = [];
            for (let item of this.listFile)
                data["listFile"].push(item.toJSON());
        }
        return data;
    }

    clone(): PostInputDto {
        const json = this.toJSON();
        let result = new PostInputDto();
        result.init(json);
        return result;
    }
}

export interface IPostInputDto {
    id: string;
    tenantId: number | undefined;
    status: string | undefined;
    search: string | undefined;
    hideValue: string | undefined;
    creatorUserId: number | undefined;
    creationTime: moment.Moment;
    name: string | undefined;
    code: string | undefined;
    codeData: string | undefined;
    valueData: string | undefined;
    category: string | undefined;
    permissions: string | undefined;
    language: string | undefined;
    value1: string | undefined;
    value2: string | undefined;
    value3: string | undefined;
    value4: string | undefined;
    value5: string | undefined;
    value6: string | undefined;
    value7: string | undefined;
    value8: string | undefined;
    value9: string | undefined;
    value10: string | undefined;
    number1: number;
    number2: number;
    number3: number;
    number4: number;
    number5: number;
    number6: number;
    number7: number;
    number8: number;
    number9: number;
    number10: number;
    categoryId: string | undefined;
    description: string | undefined;
    content: string | undefined;
    files: string | undefined;
    listFile: FileDto[] | undefined;
}

export class ValuePostDto implements IValuePostDto {
    id: string;
    tenantId: number | undefined;
    status: string | undefined;
    search: string | undefined;
    hideValue: string | undefined;
    creatorUserId: number | undefined;
    creationTime: moment.Moment;
    name: string | undefined;
    code: string | undefined;
    codeData: string | undefined;
    valueData: string | undefined;
    category: string | undefined;
    permissions: string | undefined;
    language: string | undefined;
    value1: string | undefined;
    value2: string | undefined;
    value3: string | undefined;
    value4: string | undefined;
    value5: string | undefined;
    value6: string | undefined;
    value7: string | undefined;
    value8: string | undefined;
    value9: string | undefined;
    value10: string | undefined;
    number1: number;
    number2: number;
    number3: number;
    number4: number;
    number5: number;
    number6: number;
    number7: number;
    number8: number;
    number9: number;
    number10: number;
    categoryId: string | undefined;
    description: string | undefined;
    files: any;

    constructor(data?: IValuePostDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.tenantId = data["tenantId"];
            this.status = data["status"];
            this.search = data["search"];
            this.hideValue = data["hideValue"];
            this.creatorUserId = data["creatorUserId"];
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.name = data["name"];
            this.code = data["code"];
            this.codeData = data["codeData"];
            this.valueData = data["valueData"];
            this.category = data["category"];
            this.permissions = data["permissions"];
            this.language = data["language"];
            this.value1 = data["value1"];
            this.value2 = data["value2"];
            this.value3 = data["value3"];
            this.value4 = data["value4"];
            this.value5 = data["value5"];
            this.value6 = data["value6"];
            this.value7 = data["value7"];
            this.value8 = data["value8"];
            this.value9 = data["value9"];
            this.value10 = data["value10"];
            this.number1 = data["number1"];
            this.number2 = data["number2"];
            this.number3 = data["number3"];
            this.number4 = data["number4"];
            this.number5 = data["number5"];
            this.number6 = data["number6"];
            this.number7 = data["number7"];
            this.number8 = data["number8"];
            this.number9 = data["number9"];
            this.number10 = data["number10"];
            this.categoryId = data["categoryId"];
            this.description = data["description"];
            this.files = data["files"];
        }
    }

    static fromJS(data: any): ValuePostDto {
        data = typeof data === 'object' ? data : {};
        let result = new ValuePostDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["tenantId"] = this.tenantId;
        data["status"] = this.status;
        data["search"] = this.search;
        data["hideValue"] = this.hideValue;
        data["creatorUserId"] = this.creatorUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["name"] = this.name;
        data["code"] = this.code;
        data["codeData"] = this.codeData;
        data["valueData"] = this.valueData;
        data["category"] = this.category;
        data["permissions"] = this.permissions;
        data["language"] = this.language;
        data["value1"] = this.value1;
        data["value2"] = this.value2;
        data["value3"] = this.value3;
        data["value4"] = this.value4;
        data["value5"] = this.value5;
        data["value6"] = this.value6;
        data["value7"] = this.value7;
        data["value8"] = this.value8;
        data["value9"] = this.value9;
        data["value10"] = this.value10;
        data["number1"] = this.number1;
        data["number2"] = this.number2;
        data["number3"] = this.number3;
        data["number4"] = this.number4;
        data["number5"] = this.number5;
        data["number6"] = this.number6;
        data["number7"] = this.number7;
        data["number8"] = this.number8;
        data["number9"] = this.number9;
        data["number10"] = this.number10;
        data["categoryId"] = this.categoryId;
        data["description"] = this.description;
        return data;
    }

    clone(): ValuePostDto {
        const json = this.toJSON();
        let result = new ValuePostDto();
        result.init(json);
        return result;
    }
}

export interface IValuePostDto {
    id: string;
    tenantId: number | undefined;
    status: string | undefined;
    search: string | undefined;
    hideValue: string | undefined;
    creatorUserId: number | undefined;
    creationTime: moment.Moment;
    name: string | undefined;
    code: string | undefined;
    codeData: string | undefined;
    valueData: string | undefined;
    category: string | undefined;
    permissions: string | undefined;
    language: string | undefined;
    value1: string | undefined;
    value2: string | undefined;
    value3: string | undefined;
    value4: string | undefined;
    value5: string | undefined;
    value6: string | undefined;
    value7: string | undefined;
    value8: string | undefined;
    value9: string | undefined;
    value10: string | undefined;
    number1: number;
    number2: number;
    number3: number;
    number4: number;
    number5: number;
    number6: number;
    number7: number;
    number8: number;
    number9: number;
    number10: number;
    categoryId: string | undefined;
    description: string | undefined;
    files: any;
}

export class ValuePostDtoPagedResultDto implements IValuePostDtoPagedResultDto {
    items: ValuePostDto[] | undefined;
    totalCount: number;

    constructor(data?: IValuePostDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items.push(ValuePostDto.fromJS(item));
            }
            this.totalCount = data["totalCount"];
        }
    }

    static fromJS(data: any): ValuePostDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new ValuePostDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data;
    }

    clone(): ValuePostDtoPagedResultDto {
        const json = this.toJSON();
        let result = new ValuePostDtoPagedResultDto();
        result.init(json);
        return result;
    }
}

export interface IValuePostDtoPagedResultDto {
    items: ValuePostDto[] | undefined;
    totalCount: number;
}

export class SettingEntityGuidGetDto implements ISettingEntityGuidGetDto {
    maxResultCount: number;
    skipCount: number;
    sorting: string | undefined;
    criterias: CriteriaRequestDto[] | undefined;
    tenantId: number | undefined;
    userId: number | undefined;
    id: string;
    language: string | undefined;
    option: string | undefined;
    search: string | undefined;
    status: string | undefined;
    from: moment.Moment | undefined;
    to: moment.Moment | undefined;
    sValue: string[] | undefined;
    lValue: number[] | undefined;
    gValue: string[] | undefined;
    dValue: number[] | undefined;
    tValue: moment.Moment[] | undefined;

    constructor(data?: ISettingEntityGuidGetDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.maxResultCount = data["maxResultCount"];
            this.skipCount = data["skipCount"];
            this.sorting = data["sorting"];
            if (data["criterias"] && data["criterias"].constructor === Array) {
                this.criterias = [] as any;
                for (let item of data["criterias"])
                    this.criterias.push(CriteriaRequestDto.fromJS(item));
            }
            this.tenantId = data["tenantId"];
            this.userId = data["userId"];
            this.id = data["id"];
            this.language = data["language"];
            this.option = data["option"];
            this.search = data["search"];
            this.status = data["status"];
            this.from = data["from"] ? moment(data["from"].toString()) : <any>undefined;
            this.to = data["to"] ? moment(data["to"].toString()) : <any>undefined;
            if (data["sValue"] && data["sValue"].constructor === Array) {
                this.sValue = [] as any;
                for (let item of data["sValue"])
                    this.sValue.push(item);
            }
            if (data["lValue"] && data["lValue"].constructor === Array) {
                this.lValue = [] as any;
                for (let item of data["lValue"])
                    this.lValue.push(item);
            }
            if (data["gValue"] && data["gValue"].constructor === Array) {
                this.gValue = [] as any;
                for (let item of data["gValue"])
                    this.gValue.push(item);
            }
            if (data["dValue"] && data["dValue"].constructor === Array) {
                this.dValue = [] as any;
                for (let item of data["dValue"])
                    this.dValue.push(item);
            }
            if (data["tValue"] && data["tValue"].constructor === Array) {
                this.tValue = [] as any;
                for (let item of data["tValue"])
                    this.tValue.push(moment(item));
            }
        }
    }

    static fromJS(data: any): SettingEntityGuidGetDto {
        data = typeof data === 'object' ? data : {};
        let result = new SettingEntityGuidGetDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["maxResultCount"] = this.maxResultCount;
        data["skipCount"] = this.skipCount;
        data["sorting"] = this.sorting;
        if (this.criterias && this.criterias.constructor === Array) {
            data["criterias"] = [];
            for (let item of this.criterias)
                data["criterias"].push(item.toJSON());
        }
        data["tenantId"] = this.tenantId;
        data["userId"] = this.userId;
        data["id"] = this.id;
        data["language"] = this.language;
        data["option"] = this.option;
        data["search"] = this.search;
        data["status"] = this.status;
        data["from"] = this.from ? this.from.toISOString() : <any>undefined;
        data["to"] = this.to ? this.to.toISOString() : <any>undefined;
        if (this.sValue && this.sValue.constructor === Array) {
            data["sValue"] = [];
            for (let item of this.sValue)
                data["sValue"].push(item);
        }
        if (this.lValue && this.lValue.constructor === Array) {
            data["lValue"] = [];
            for (let item of this.lValue)
                data["lValue"].push(item);
        }
        if (this.gValue && this.gValue.constructor === Array) {
            data["gValue"] = [];
            for (let item of this.gValue)
                data["gValue"].push(item);
        }
        if (this.dValue && this.dValue.constructor === Array) {
            data["dValue"] = [];
            for (let item of this.dValue)
                data["dValue"].push(item);
        }
        if (this.tValue && this.tValue.constructor === Array) {
            data["tValue"] = [];
            for (let item of this.tValue)
                data["tValue"].push(item.toISOString());
        }
        return data;
    }

    clone(): SettingEntityGuidGetDto {
        const json = this.toJSON();
        let result = new SettingEntityGuidGetDto();
        result.init(json);
        return result;
    }
}

export interface ISettingEntityGuidGetDto {
    maxResultCount: number;
    skipCount: number;
    sorting: string | undefined;
    criterias: CriteriaRequestDto[] | undefined;
    tenantId: number | undefined;
    userId: number | undefined;
    id: string;
    language: string | undefined;
    option: string | undefined;
    search: string | undefined;
    status: string | undefined;
    from: moment.Moment | undefined;
    to: moment.Moment | undefined;
    sValue: string[] | undefined;
    lValue: number[] | undefined;
    gValue: string[] | undefined;
    dValue: number[] | undefined;
    tValue: moment.Moment[] | undefined;
}

export class SettingOutputDto implements ISettingOutputDto {
    id: string;
    tenantId: number | undefined;
    userId: number | undefined;
    key: string | undefined;
    type: string | undefined;
    value: string | undefined;
    language: string | undefined;

    constructor(data?: ISettingOutputDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.tenantId = data["tenantId"];
            this.userId = data["userId"];
            this.key = data["key"];
            this.type = data["type"];
            this.value = data["value"];
            this.language = data["language"];
        }
    }

    static fromJS(data: any): SettingOutputDto {
        data = typeof data === 'object' ? data : {};
        let result = new SettingOutputDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["tenantId"] = this.tenantId;
        data["userId"] = this.userId;
        data["key"] = this.key;
        data["type"] = this.type;
        data["value"] = this.value;
        data["language"] = this.language;
        return data;
    }

    clone(): SettingOutputDto {
        const json = this.toJSON();
        let result = new SettingOutputDto();
        result.init(json);
        return result;
    }
}

export interface ISettingOutputDto {
    id: string;
    tenantId: number | undefined;
    userId: number | undefined;
    key: string | undefined;
    type: string | undefined;
    value: string | undefined;
    language: string | undefined;
}

export class SettingInputDto implements ISettingInputDto {
    id: string;
    tenantId: number | undefined;
    userId: number | undefined;
    key: string | undefined;
    type: string | undefined;
    value: string | undefined;
    language: string | undefined;

    constructor(data?: ISettingInputDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.tenantId = data["tenantId"];
            this.userId = data["userId"];
            this.key = data["key"];
            this.type = data["type"];
            this.value = data["value"];
            this.language = data["language"];
        }
    }

    static fromJS(data: any): SettingInputDto {
        data = typeof data === 'object' ? data : {};
        let result = new SettingInputDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["tenantId"] = this.tenantId;
        data["userId"] = this.userId;
        data["key"] = this.key;
        data["type"] = this.type;
        data["value"] = this.value;
        data["language"] = this.language;
        return data;
    }

    clone(): SettingInputDto {
        const json = this.toJSON();
        let result = new SettingInputDto();
        result.init(json);
        return result;
    }
}

export interface ISettingInputDto {
    id: string;
    tenantId: number | undefined;
    userId: number | undefined;
    key: string | undefined;
    type: string | undefined;
    value: string | undefined;
    language: string | undefined;
}

export class GetSettingDto implements IGetSettingDto {
    tenantId: number | undefined;
    key: string | undefined;
    language: string | undefined;
    type: string | undefined;

    constructor(data?: IGetSettingDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.tenantId = data["tenantId"];
            this.key = data["key"];
            this.language = data["language"];
            this.type = data["type"];
        }
    }

    static fromJS(data: any): GetSettingDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetSettingDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantId"] = this.tenantId;
        data["key"] = this.key;
        data["language"] = this.language;
        data["type"] = this.type;
        return data;
    }

    clone(): GetSettingDto {
        const json = this.toJSON();
        let result = new GetSettingDto();
        result.init(json);
        return result;
    }
}

export interface IGetSettingDto {
    tenantId: number | undefined;
    key: string | undefined;
    language: string | undefined;
    type: string | undefined;
}

export class SwaggerException extends Error {
    message: string;
    status: number;
    response: string;
    headers: { [key: string]: any; };
    result: any;

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isSwaggerException = true;

    static isSwaggerException(obj: any): obj is SwaggerException {
        return obj.isSwaggerException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): Observable<any> {
    if(result !== null && result !== undefined)
        return _observableThrow(result);
    else
        return _observableThrow(new SwaggerException(message, status, response, headers, null));
}

function blobToText(blob: any): Observable<string> {
    return new Observable<string>((observer: any) => {
        if (!blob) {
            observer.next("");
            observer.complete();
        } else {
            let reader = new FileReader();
            reader.onload = event => {
                observer.next((<any>event.target).result);
                observer.complete();
            };
            reader.readAsText(blob);
        }
    });
}
