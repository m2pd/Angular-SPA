/* tslint:disable */
/* eslint-disable */
//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v12.3.1.0 (NJsonSchema v9.14.1.0 (Newtonsoft.Json v11.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------
// ReSharper disable InconsistentNaming

import { mergeMap as _observableMergeMap, catchError as _observableCatch } from 'rxjs/operators';
import { Observable, throwError as _observableThrow, of as _observableOf } from 'rxjs';
import { Injectable, Inject, Optional, InjectionToken } from '@angular/core';
import { HttpClient, HttpHeaders, HttpResponse, HttpResponseBase } from '@angular/common/http';

import * as moment from 'moment';

export const SSO_API_BASE_URL = new InjectionToken<string>('SSO_API_BASE_URL');

@Injectable()
export class SSOAbcServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(SSO_API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @return Success
     */
    test(): Observable<string> {
        let url_ = this.baseUrl + "/api/services/sso/read/Abc/Test";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processTest(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processTest(<any>response_);
                } catch (e) {
                    return <Observable<string>><any>_observableThrow(e);
                }
            } else
                return <Observable<string>><any>_observableThrow(response_);
        }));
    }

    protected processTest(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(<any>null);
    }
}

@Injectable()
export class SSOCategoryServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(SSO_API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    getList(body: SSOCategoryGuidGetDto | undefined): Observable<SSOCategoryOutputDto[]> {
        let url_ = this.baseUrl + "/api/services/sso/read/Category/GetList";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json", 
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetList(<any>response_);
                } catch (e) {
                    return <Observable<SSOCategoryOutputDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<SSOCategoryOutputDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetList(response: HttpResponseBase): Observable<SSOCategoryOutputDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(SSOCategoryOutputDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SSOCategoryOutputDto[]>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    get(body: GuidEntityDto | undefined): Observable<SSOCategoryOutputDto> {
        let url_ = this.baseUrl + "/api/services/sso/read/Category/Get";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json", 
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(<any>response_);
                } catch (e) {
                    return <Observable<SSOCategoryOutputDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<SSOCategoryOutputDto>><any>_observableThrow(response_);
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<SSOCategoryOutputDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? SSOCategoryOutputDto.fromJS(resultData200) : new SSOCategoryOutputDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SSOCategoryOutputDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    create(body: SSOCategoryInputDto | undefined): Observable<SSOCategoryOutputDto> {
        let url_ = this.baseUrl + "/api/services/sso/write/Category/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json", 
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(<any>response_);
                } catch (e) {
                    return <Observable<SSOCategoryOutputDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<SSOCategoryOutputDto>><any>_observableThrow(response_);
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<SSOCategoryOutputDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? SSOCategoryOutputDto.fromJS(resultData200) : new SSOCategoryOutputDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SSOCategoryOutputDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    update(body: SSOCategoryInputDto | undefined): Observable<SSOCategoryOutputDto> {
        let url_ = this.baseUrl + "/api/services/sso/write/Category/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json", 
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(<any>response_);
                } catch (e) {
                    return <Observable<SSOCategoryOutputDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<SSOCategoryOutputDto>><any>_observableThrow(response_);
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<SSOCategoryOutputDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? SSOCategoryOutputDto.fromJS(resultData200) : new SSOCategoryOutputDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SSOCategoryOutputDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    delete(body: GuidEntityDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/sso/write/Category/Delete";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    setPermissions(body: SSOCategoryPermissionsDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/sso/write/Category/SetPermissions";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSetPermissions(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSetPermissions(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processSetPermissions(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class SSOCategoryStateServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(SSO_API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    getListState(body: SSOCategoryGuidGetDto | undefined): Observable<SSOCategoryStateOutputDto[]> {
        let url_ = this.baseUrl + "/api/services/sso/read/CategoryState/GetListState";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json", 
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetListState(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetListState(<any>response_);
                } catch (e) {
                    return <Observable<SSOCategoryStateOutputDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<SSOCategoryStateOutputDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetListState(response: HttpResponseBase): Observable<SSOCategoryStateOutputDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(SSOCategoryStateOutputDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SSOCategoryStateOutputDto[]>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    getStateByCode(body: SSOCategoryGuidGetDto | undefined): Observable<SSOCategoryPermissionDto> {
        let url_ = this.baseUrl + "/api/services/sso/read/CategoryState/GetStateByCode";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json", 
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetStateByCode(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetStateByCode(<any>response_);
                } catch (e) {
                    return <Observable<SSOCategoryPermissionDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<SSOCategoryPermissionDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetStateByCode(response: HttpResponseBase): Observable<SSOCategoryPermissionDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? SSOCategoryPermissionDto.fromJS(resultData200) : new SSOCategoryPermissionDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SSOCategoryPermissionDto>(<any>null);
    }
}

@Injectable()
export class SSOOrganizationServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(SSO_API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    getList(body: OrganizationGuidGetDto | undefined): Observable<OrganizationOutputDto[]> {
        let url_ = this.baseUrl + "/api/services/sso/read/Organization/GetList";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json", 
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetList(<any>response_);
                } catch (e) {
                    return <Observable<OrganizationOutputDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<OrganizationOutputDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetList(response: HttpResponseBase): Observable<OrganizationOutputDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(OrganizationOutputDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<OrganizationOutputDto[]>(<any>null);
    }

    /**
     * @return Success
     */
    getCurrentOrganizations(): Observable<OrganizationOutputDto[]> {
        let url_ = this.baseUrl + "/api/services/sso/read/Organization/GetCurrentOrganizations";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCurrentOrganizations(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCurrentOrganizations(<any>response_);
                } catch (e) {
                    return <Observable<OrganizationOutputDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<OrganizationOutputDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetCurrentOrganizations(response: HttpResponseBase): Observable<OrganizationOutputDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(OrganizationOutputDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<OrganizationOutputDto[]>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    getOrganizationsByType(body: OrganizationGuidGetDto | undefined): Observable<OrganizationOutputDto[]> {
        let url_ = this.baseUrl + "/api/services/sso/read/Organization/GetOrganizationsByType";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json", 
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetOrganizationsByType(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetOrganizationsByType(<any>response_);
                } catch (e) {
                    return <Observable<OrganizationOutputDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<OrganizationOutputDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetOrganizationsByType(response: HttpResponseBase): Observable<OrganizationOutputDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(OrganizationOutputDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<OrganizationOutputDto[]>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    create(body: OrganizationInputDto | undefined): Observable<OrganizationOutputDto> {
        let url_ = this.baseUrl + "/api/services/sso/write/Organization/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json", 
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(<any>response_);
                } catch (e) {
                    return <Observable<OrganizationOutputDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<OrganizationOutputDto>><any>_observableThrow(response_);
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<OrganizationOutputDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? OrganizationOutputDto.fromJS(resultData200) : new OrganizationOutputDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<OrganizationOutputDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    update(body: OrganizationInputDto | undefined): Observable<OrganizationOutputDto> {
        let url_ = this.baseUrl + "/api/services/sso/write/Organization/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json", 
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(<any>response_);
                } catch (e) {
                    return <Observable<OrganizationOutputDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<OrganizationOutputDto>><any>_observableThrow(response_);
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<OrganizationOutputDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? OrganizationOutputDto.fromJS(resultData200) : new OrganizationOutputDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<OrganizationOutputDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    delete(body: GuidEntityDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/sso/write/Organization/Delete";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    setCategories(body: OrganizationategoryDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/sso/write/Organization/SetCategories";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSetCategories(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSetCategories(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processSetCategories(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class SSOOrganizationUserServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(SSO_API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    getList(body: OrganizationUserGuidGetDto | undefined): Observable<OrganizationUserOutputDto[]> {
        let url_ = this.baseUrl + "/api/services/sso/read/OrganizationUser/GetList";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json", 
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetList(<any>response_);
                } catch (e) {
                    return <Observable<OrganizationUserOutputDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<OrganizationUserOutputDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetList(response: HttpResponseBase): Observable<OrganizationUserOutputDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(OrganizationUserOutputDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<OrganizationUserOutputDto[]>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    getOrganizationUser(body: OrganizationUserGuidGetDto | undefined): Observable<OrganizationUserOutputDto[]> {
        let url_ = this.baseUrl + "/api/services/sso/read/OrganizationUser/GetOrganizationUser";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json", 
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetOrganizationUser(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetOrganizationUser(<any>response_);
                } catch (e) {
                    return <Observable<OrganizationUserOutputDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<OrganizationUserOutputDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetOrganizationUser(response: HttpResponseBase): Observable<OrganizationUserOutputDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(OrganizationUserOutputDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<OrganizationUserOutputDto[]>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    getClientOrganizationUser(body: OrganizationUserGuidGetDto | undefined): Observable<OrganizationUserOutputDto[]> {
        let url_ = this.baseUrl + "/api/services/sso/read/OrganizationUser/GetClientOrganizationUser";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json", 
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetClientOrganizationUser(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetClientOrganizationUser(<any>response_);
                } catch (e) {
                    return <Observable<OrganizationUserOutputDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<OrganizationUserOutputDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetClientOrganizationUser(response: HttpResponseBase): Observable<OrganizationUserOutputDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(OrganizationUserOutputDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<OrganizationUserOutputDto[]>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    getUserNotInOrganization(body: OrganizationUserGuidGetDto | undefined): Observable<UserOutputDto[]> {
        let url_ = this.baseUrl + "/api/services/sso/read/OrganizationUser/GetUserNotInOrganization";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json", 
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetUserNotInOrganization(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUserNotInOrganization(<any>response_);
                } catch (e) {
                    return <Observable<UserOutputDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<UserOutputDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetUserNotInOrganization(response: HttpResponseBase): Observable<UserOutputDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(UserOutputDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UserOutputDto[]>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    addOrganizationUser(body: OrganizationUserInputDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/sso/write/OrganizationUser/AddOrganizationUser";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddOrganizationUser(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddOrganizationUser(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processAddOrganizationUser(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    removeOrganizationUser(body: OrganizationUserInputDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/sso/write/OrganizationUser/RemoveOrganizationUser";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRemoveOrganizationUser(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRemoveOrganizationUser(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processRemoveOrganizationUser(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    setCategoriesOrganizationUser(body: OrganizationUserInputDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/sso/write/OrganizationUser/SetCategoriesOrganizationUser";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSetCategoriesOrganizationUser(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSetCategoriesOrganizationUser(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processSetCategoriesOrganizationUser(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class SSOPermissionServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(SSO_API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    getList(body: TenantPermissionGuidGetDto | undefined): Observable<PermissionOutputDto[]> {
        let url_ = this.baseUrl + "/api/services/sso/read/Permission/GetList";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json", 
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetList(<any>response_);
                } catch (e) {
                    return <Observable<PermissionOutputDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<PermissionOutputDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetList(response: HttpResponseBase): Observable<PermissionOutputDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(PermissionOutputDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PermissionOutputDto[]>(<any>null);
    }
}

@Injectable()
export class SSORegistrationServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(SSO_API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    checkValidTenant(body: CheckValidTenantDto | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/services/sso/read/Registration/CheckValidTenant";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json", 
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCheckValidTenant(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCheckValidTenant(<any>response_);
                } catch (e) {
                    return <Observable<boolean>><any>_observableThrow(e);
                }
            } else
                return <Observable<boolean>><any>_observableThrow(response_);
        }));
    }

    protected processCheckValidTenant(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<boolean>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    registerTenant(body: RegisterTenantDto | undefined): Observable<RegisterResultDto> {
        let url_ = this.baseUrl + "/api/services/sso/write/Registration/RegisterTenant";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json", 
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRegisterTenant(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRegisterTenant(<any>response_);
                } catch (e) {
                    return <Observable<RegisterResultDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<RegisterResultDto>><any>_observableThrow(response_);
        }));
    }

    protected processRegisterTenant(response: HttpResponseBase): Observable<RegisterResultDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? RegisterResultDto.fromJS(resultData200) : new RegisterResultDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<RegisterResultDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    registerUser(body: RegisterUserDto | undefined): Observable<RegisterResultDto> {
        let url_ = this.baseUrl + "/api/services/sso/write/Registration/RegisterUser";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json", 
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRegisterUser(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRegisterUser(<any>response_);
                } catch (e) {
                    return <Observable<RegisterResultDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<RegisterResultDto>><any>_observableThrow(response_);
        }));
    }

    protected processRegisterUser(response: HttpResponseBase): Observable<RegisterResultDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? RegisterResultDto.fromJS(resultData200) : new RegisterResultDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<RegisterResultDto>(<any>null);
    }
}

@Injectable()
export class SSOTitleServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(SSO_API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    getList(body: TitleGuidGetDto | undefined): Observable<TitleOutputDto[]> {
        let url_ = this.baseUrl + "/api/services/sso/read/Title/GetList";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json", 
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetList(<any>response_);
                } catch (e) {
                    return <Observable<TitleOutputDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<TitleOutputDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetList(response: HttpResponseBase): Observable<TitleOutputDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(TitleOutputDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TitleOutputDto[]>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    create(body: TitleInputDto | undefined): Observable<TitleOutputDto> {
        let url_ = this.baseUrl + "/api/services/sso/write/Title/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json", 
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(<any>response_);
                } catch (e) {
                    return <Observable<TitleOutputDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<TitleOutputDto>><any>_observableThrow(response_);
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<TitleOutputDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? TitleOutputDto.fromJS(resultData200) : new TitleOutputDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TitleOutputDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    update(body: TitleInputDto | undefined): Observable<TitleOutputDto> {
        let url_ = this.baseUrl + "/api/services/sso/write/Title/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json", 
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(<any>response_);
                } catch (e) {
                    return <Observable<TitleOutputDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<TitleOutputDto>><any>_observableThrow(response_);
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<TitleOutputDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? TitleOutputDto.fromJS(resultData200) : new TitleOutputDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TitleOutputDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    delete(body: GuidEntityDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/sso/write/Title/Delete";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    setPermissions(body: TitlePermissionDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/sso/write/Title/SetPermissions";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSetPermissions(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSetPermissions(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processSetPermissions(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class SSOTokenAuthServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(SSO_API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    authenticate(body: AuthenticateModel | undefined): Observable<AuthenticateResultModel> {
        let url_ = this.baseUrl + "/api/TokenAuth/Authenticate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json", 
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAuthenticate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAuthenticate(<any>response_);
                } catch (e) {
                    return <Observable<AuthenticateResultModel>><any>_observableThrow(e);
                }
            } else
                return <Observable<AuthenticateResultModel>><any>_observableThrow(response_);
        }));
    }

    protected processAuthenticate(response: HttpResponseBase): Observable<AuthenticateResultModel> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? AuthenticateResultModel.fromJS(resultData200) : new AuthenticateResultModel();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AuthenticateResultModel>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    getOTP(body: OTPModel | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/TokenAuth/GetOTP";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetOTP(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetOTP(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processGetOTP(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @return Success
     */
    getConfig(): Observable<string> {
        let url_ = this.baseUrl + "/api/TokenAuth/GetConfig";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetConfig(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetConfig(<any>response_);
                } catch (e) {
                    return <Observable<string>><any>_observableThrow(e);
                }
            } else
                return <Observable<string>><any>_observableThrow(response_);
        }));
    }

    protected processGetConfig(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    authenticateOTP(body: AuthenticateModel | undefined): Observable<AuthenticateResultModel> {
        let url_ = this.baseUrl + "/api/TokenAuth/AuthenticateOTP";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json", 
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAuthenticateOTP(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAuthenticateOTP(<any>response_);
                } catch (e) {
                    return <Observable<AuthenticateResultModel>><any>_observableThrow(e);
                }
            } else
                return <Observable<AuthenticateResultModel>><any>_observableThrow(response_);
        }));
    }

    protected processAuthenticateOTP(response: HttpResponseBase): Observable<AuthenticateResultModel> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? AuthenticateResultModel.fromJS(resultData200) : new AuthenticateResultModel();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AuthenticateResultModel>(<any>null);
    }
}

@Injectable()
export class SSOUserServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(SSO_API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getCurrentUser(): Observable<UserDto> {
        let url_ = this.baseUrl + "/api/services/sso/read/User/GetCurrentUser";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCurrentUser(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCurrentUser(<any>response_);
                } catch (e) {
                    return <Observable<UserDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<UserDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetCurrentUser(response: HttpResponseBase): Observable<UserDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? UserDto.fromJS(resultData200) : new UserDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UserDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    getUsers(body: UserInt64GetDto | undefined): Observable<UserOutputDto[]> {
        let url_ = this.baseUrl + "/api/services/sso/read/User/GetUsers";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json", 
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetUsers(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUsers(<any>response_);
                } catch (e) {
                    return <Observable<UserOutputDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<UserOutputDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetUsers(response: HttpResponseBase): Observable<UserOutputDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(UserOutputDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UserOutputDto[]>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    getPageUsers(body: UserInt64GetDto | undefined): Observable<UserOutputDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/sso/read/User/GetPageUsers";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json", 
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPageUsers(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPageUsers(<any>response_);
                } catch (e) {
                    return <Observable<UserOutputDtoPagedResultDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<UserOutputDtoPagedResultDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetPageUsers(response: HttpResponseBase): Observable<UserOutputDtoPagedResultDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? UserOutputDtoPagedResultDto.fromJS(resultData200) : new UserOutputDtoPagedResultDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UserOutputDtoPagedResultDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    changePassword(body: ChangePasswordDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/sso/write/User/ChangePassword";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processChangePassword(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processChangePassword(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processChangePassword(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    create(body: RegisterUserDto | undefined): Observable<UserDto> {
        let url_ = this.baseUrl + "/api/services/sso/write/User/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json", 
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(<any>response_);
                } catch (e) {
                    return <Observable<UserDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<UserDto>><any>_observableThrow(response_);
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<UserDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? UserDto.fromJS(resultData200) : new UserDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UserDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    update(body: UserInputDto | undefined): Observable<UserDto> {
        let url_ = this.baseUrl + "/api/services/sso/write/User/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json", 
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(<any>response_);
                } catch (e) {
                    return <Observable<UserDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<UserDto>><any>_observableThrow(response_);
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<UserDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? UserDto.fromJS(resultData200) : new UserDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UserDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    delete(body: Int64EntityDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/sso/write/User/Delete";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    setPassword(body: ChangePasswordDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/sso/write/User/SetPassword";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSetPassword(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSetPassword(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processSetPassword(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

export enum OperationCriteria {
    _0 = 0, 
    _1 = 1, 
    _2 = 2, 
    _3 = 3, 
    _4 = 4, 
    _5 = 5, 
    _6 = 6, 
    _7 = 7, 
    _8 = 8, 
    _9 = 9, 
    _10 = 10, 
}

export class CriteriaRequestDto implements ICriteriaRequestDto {
    propertyName: string | undefined;
    operation: OperationCriteria;
    value: string | undefined;

    constructor(data?: ICriteriaRequestDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.propertyName = data["propertyName"];
            this.operation = data["operation"];
            this.value = data["value"];
        }
    }

    static fromJS(data: any): CriteriaRequestDto {
        data = typeof data === 'object' ? data : {};
        let result = new CriteriaRequestDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["propertyName"] = this.propertyName;
        data["operation"] = this.operation;
        data["value"] = this.value;
        return data; 
    }

    clone(): CriteriaRequestDto {
        const json = this.toJSON();
        let result = new CriteriaRequestDto();
        result.init(json);
        return result;
    }
}

export interface ICriteriaRequestDto {
    propertyName: string | undefined;
    operation: OperationCriteria;
    value: string | undefined;
}

export class SSOCategoryGuidGetDto implements ISSOCategoryGuidGetDto {
    maxResultCount: number;
    skipCount: number;
    sorting: string | undefined;
    criterias: CriteriaRequestDto[] | undefined;
    tenantId: number | undefined;
    userId: number | undefined;
    id: string;
    language: string | undefined;
    option: string | undefined;
    search: string | undefined;
    status: string | undefined;
    from: moment.Moment | undefined;
    to: moment.Moment | undefined;
    sValue: string[] | undefined;
    lValue: number[] | undefined;
    gValue: string[] | undefined;
    dValue: number[] | undefined;
    tValue: moment.Moment[] | undefined;

    constructor(data?: ISSOCategoryGuidGetDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.maxResultCount = data["maxResultCount"];
            this.skipCount = data["skipCount"];
            this.sorting = data["sorting"];
            if (data["criterias"] && data["criterias"].constructor === Array) {
                this.criterias = [] as any;
                for (let item of data["criterias"])
                    this.criterias.push(CriteriaRequestDto.fromJS(item));
            }
            this.tenantId = data["tenantId"];
            this.userId = data["userId"];
            this.id = data["id"];
            this.language = data["language"];
            this.option = data["option"];
            this.search = data["search"];
            this.status = data["status"];
            this.from = data["from"] ? moment(data["from"].toString()) : <any>undefined;
            this.to = data["to"] ? moment(data["to"].toString()) : <any>undefined;
            if (data["sValue"] && data["sValue"].constructor === Array) {
                this.sValue = [] as any;
                for (let item of data["sValue"])
                    this.sValue.push(item);
            }
            if (data["lValue"] && data["lValue"].constructor === Array) {
                this.lValue = [] as any;
                for (let item of data["lValue"])
                    this.lValue.push(item);
            }
            if (data["gValue"] && data["gValue"].constructor === Array) {
                this.gValue = [] as any;
                for (let item of data["gValue"])
                    this.gValue.push(item);
            }
            if (data["dValue"] && data["dValue"].constructor === Array) {
                this.dValue = [] as any;
                for (let item of data["dValue"])
                    this.dValue.push(item);
            }
            if (data["tValue"] && data["tValue"].constructor === Array) {
                this.tValue = [] as any;
                for (let item of data["tValue"])
                    this.tValue.push(moment(item));
            }
        }
    }

    static fromJS(data: any): SSOCategoryGuidGetDto {
        data = typeof data === 'object' ? data : {};
        let result = new SSOCategoryGuidGetDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["maxResultCount"] = this.maxResultCount;
        data["skipCount"] = this.skipCount;
        data["sorting"] = this.sorting;
        if (this.criterias && this.criterias.constructor === Array) {
            data["criterias"] = [];
            for (let item of this.criterias)
                data["criterias"].push(item.toJSON());
        }
        data["tenantId"] = this.tenantId;
        data["userId"] = this.userId;
        data["id"] = this.id;
        data["language"] = this.language;
        data["option"] = this.option;
        data["search"] = this.search;
        data["status"] = this.status;
        data["from"] = this.from ? this.from.toISOString() : <any>undefined;
        data["to"] = this.to ? this.to.toISOString() : <any>undefined;
        if (this.sValue && this.sValue.constructor === Array) {
            data["sValue"] = [];
            for (let item of this.sValue)
                data["sValue"].push(item);
        }
        if (this.lValue && this.lValue.constructor === Array) {
            data["lValue"] = [];
            for (let item of this.lValue)
                data["lValue"].push(item);
        }
        if (this.gValue && this.gValue.constructor === Array) {
            data["gValue"] = [];
            for (let item of this.gValue)
                data["gValue"].push(item);
        }
        if (this.dValue && this.dValue.constructor === Array) {
            data["dValue"] = [];
            for (let item of this.dValue)
                data["dValue"].push(item);
        }
        if (this.tValue && this.tValue.constructor === Array) {
            data["tValue"] = [];
            for (let item of this.tValue)
                data["tValue"].push(item.toISOString());
        }
        return data; 
    }

    clone(): SSOCategoryGuidGetDto {
        const json = this.toJSON();
        let result = new SSOCategoryGuidGetDto();
        result.init(json);
        return result;
    }
}

export interface ISSOCategoryGuidGetDto {
    maxResultCount: number;
    skipCount: number;
    sorting: string | undefined;
    criterias: CriteriaRequestDto[] | undefined;
    tenantId: number | undefined;
    userId: number | undefined;
    id: string;
    language: string | undefined;
    option: string | undefined;
    search: string | undefined;
    status: string | undefined;
    from: moment.Moment | undefined;
    to: moment.Moment | undefined;
    sValue: string[] | undefined;
    lValue: number[] | undefined;
    gValue: string[] | undefined;
    dValue: number[] | undefined;
    tValue: moment.Moment[] | undefined;
}

export class CategoryPermissionOutputDto implements ICategoryPermissionOutputDto {
    id: string;
    categoryId: string;
    typeId: string | undefined;
    organizationId: string | undefined;
    permissionId: string | undefined;
    userId: number | undefined;
    access: string | undefined;
    actions: string | undefined;
    fields: string | undefined;
    tenantId: number | undefined;
    type: string | undefined;
    organization: string | undefined;
    permission: string | undefined;
    user: string | undefined;

    constructor(data?: ICategoryPermissionOutputDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.categoryId = data["categoryId"];
            this.typeId = data["typeId"];
            this.organizationId = data["organizationId"];
            this.permissionId = data["permissionId"];
            this.userId = data["userId"];
            this.access = data["access"];
            this.actions = data["actions"];
            this.fields = data["fields"];
            this.tenantId = data["tenantId"];
            this.type = data["type"];
            this.organization = data["organization"];
            this.permission = data["permission"];
            this.user = data["user"];
        }
    }

    static fromJS(data: any): CategoryPermissionOutputDto {
        data = typeof data === 'object' ? data : {};
        let result = new CategoryPermissionOutputDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["categoryId"] = this.categoryId;
        data["typeId"] = this.typeId;
        data["organizationId"] = this.organizationId;
        data["permissionId"] = this.permissionId;
        data["userId"] = this.userId;
        data["access"] = this.access;
        data["actions"] = this.actions;
        data["fields"] = this.fields;
        data["tenantId"] = this.tenantId;
        data["type"] = this.type;
        data["organization"] = this.organization;
        data["permission"] = this.permission;
        data["user"] = this.user;
        return data; 
    }

    clone(): CategoryPermissionOutputDto {
        const json = this.toJSON();
        let result = new CategoryPermissionOutputDto();
        result.init(json);
        return result;
    }
}

export interface ICategoryPermissionOutputDto {
    id: string;
    categoryId: string;
    typeId: string | undefined;
    organizationId: string | undefined;
    permissionId: string | undefined;
    userId: number | undefined;
    access: string | undefined;
    actions: string | undefined;
    fields: string | undefined;
    tenantId: number | undefined;
    type: string | undefined;
    organization: string | undefined;
    permission: string | undefined;
    user: string | undefined;
}

export class SSOCategoryOutputDto implements ISSOCategoryOutputDto {
    id: string;
    tenantId: number | undefined;
    status: string | undefined;
    search: string | undefined;
    hideValue: string | undefined;
    creatorUserId: number | undefined;
    creationTime: moment.Moment;
    name: string | undefined;
    code: string | undefined;
    codeData: string | undefined;
    valueData: string | undefined;
    category: string | undefined;
    permissions: string | undefined;
    language: string | undefined;
    value1: string | undefined;
    value2: string | undefined;
    value3: string | undefined;
    value4: string | undefined;
    value5: string | undefined;
    value6: string | undefined;
    value7: string | undefined;
    value8: string | undefined;
    value9: string | undefined;
    value10: string | undefined;
    number1: number;
    number2: number;
    number3: number;
    number4: number;
    number5: number;
    number6: number;
    number7: number;
    number8: number;
    number9: number;
    number10: number;
    parentId: string | undefined;
    index: number;
    order: number;
    groupCode: string | undefined;
    hashCode: string | undefined;
    value11: string | undefined;
    value12: string | undefined;
    value13: string | undefined;
    value14: string | undefined;
    value15: string | undefined;
    value16: string | undefined;
    value17: string | undefined;
    value18: string | undefined;
    value19: string | undefined;
    value20: string | undefined;
    listPermission: CategoryPermissionOutputDto[] | undefined;
    parentCode: string | undefined;
    parentName: string | undefined;
    listChild: SSOCategoryOutputDto[] | undefined;

    constructor(data?: ISSOCategoryOutputDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.tenantId = data["tenantId"];
            this.status = data["status"];
            this.search = data["search"];
            this.hideValue = data["hideValue"];
            this.creatorUserId = data["creatorUserId"];
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.name = data["name"];
            this.code = data["code"];
            this.codeData = data["codeData"];
            this.valueData = data["valueData"];
            this.category = data["category"];
            this.permissions = data["permissions"];
            this.language = data["language"];
            this.value1 = data["value1"];
            this.value2 = data["value2"];
            this.value3 = data["value3"];
            this.value4 = data["value4"];
            this.value5 = data["value5"];
            this.value6 = data["value6"];
            this.value7 = data["value7"];
            this.value8 = data["value8"];
            this.value9 = data["value9"];
            this.value10 = data["value10"];
            this.number1 = data["number1"];
            this.number2 = data["number2"];
            this.number3 = data["number3"];
            this.number4 = data["number4"];
            this.number5 = data["number5"];
            this.number6 = data["number6"];
            this.number7 = data["number7"];
            this.number8 = data["number8"];
            this.number9 = data["number9"];
            this.number10 = data["number10"];
            this.parentId = data["parentId"];
            this.index = data["index"];
            this.order = data["order"];
            this.groupCode = data["groupCode"];
            this.hashCode = data["hashCode"];
            this.value11 = data["value11"];
            this.value12 = data["value12"];
            this.value13 = data["value13"];
            this.value14 = data["value14"];
            this.value15 = data["value15"];
            this.value16 = data["value16"];
            this.value17 = data["value17"];
            this.value18 = data["value18"];
            this.value19 = data["value19"];
            this.value20 = data["value20"];
            if (data["listPermission"] && data["listPermission"].constructor === Array) {
                this.listPermission = [] as any;
                for (let item of data["listPermission"])
                    this.listPermission.push(CategoryPermissionOutputDto.fromJS(item));
            }
            this.parentCode = data["parentCode"];
            this.parentName = data["parentName"];
            if (data["listChild"] && data["listChild"].constructor === Array) {
                this.listChild = [] as any;
                for (let item of data["listChild"])
                    this.listChild.push(SSOCategoryOutputDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): SSOCategoryOutputDto {
        data = typeof data === 'object' ? data : {};
        let result = new SSOCategoryOutputDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["tenantId"] = this.tenantId;
        data["status"] = this.status;
        data["search"] = this.search;
        data["hideValue"] = this.hideValue;
        data["creatorUserId"] = this.creatorUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["name"] = this.name;
        data["code"] = this.code;
        data["codeData"] = this.codeData;
        data["valueData"] = this.valueData;
        data["category"] = this.category;
        data["permissions"] = this.permissions;
        data["language"] = this.language;
        data["value1"] = this.value1;
        data["value2"] = this.value2;
        data["value3"] = this.value3;
        data["value4"] = this.value4;
        data["value5"] = this.value5;
        data["value6"] = this.value6;
        data["value7"] = this.value7;
        data["value8"] = this.value8;
        data["value9"] = this.value9;
        data["value10"] = this.value10;
        data["number1"] = this.number1;
        data["number2"] = this.number2;
        data["number3"] = this.number3;
        data["number4"] = this.number4;
        data["number5"] = this.number5;
        data["number6"] = this.number6;
        data["number7"] = this.number7;
        data["number8"] = this.number8;
        data["number9"] = this.number9;
        data["number10"] = this.number10;
        data["parentId"] = this.parentId;
        data["index"] = this.index;
        data["order"] = this.order;
        data["groupCode"] = this.groupCode;
        data["hashCode"] = this.hashCode;
        data["value11"] = this.value11;
        data["value12"] = this.value12;
        data["value13"] = this.value13;
        data["value14"] = this.value14;
        data["value15"] = this.value15;
        data["value16"] = this.value16;
        data["value17"] = this.value17;
        data["value18"] = this.value18;
        data["value19"] = this.value19;
        data["value20"] = this.value20;
        if (this.listPermission && this.listPermission.constructor === Array) {
            data["listPermission"] = [];
            for (let item of this.listPermission)
                data["listPermission"].push(item.toJSON());
        }
        data["parentCode"] = this.parentCode;
        data["parentName"] = this.parentName;
        if (this.listChild && this.listChild.constructor === Array) {
            data["listChild"] = [];
            for (let item of this.listChild)
                data["listChild"].push(item.toJSON());
        }
        return data; 
    }

    clone(): SSOCategoryOutputDto {
        const json = this.toJSON();
        let result = new SSOCategoryOutputDto();
        result.init(json);
        return result;
    }
}

export interface ISSOCategoryOutputDto {
    id: string;
    tenantId: number | undefined;
    status: string | undefined;
    search: string | undefined;
    hideValue: string | undefined;
    creatorUserId: number | undefined;
    creationTime: moment.Moment;
    name: string | undefined;
    code: string | undefined;
    codeData: string | undefined;
    valueData: string | undefined;
    category: string | undefined;
    permissions: string | undefined;
    language: string | undefined;
    value1: string | undefined;
    value2: string | undefined;
    value3: string | undefined;
    value4: string | undefined;
    value5: string | undefined;
    value6: string | undefined;
    value7: string | undefined;
    value8: string | undefined;
    value9: string | undefined;
    value10: string | undefined;
    number1: number;
    number2: number;
    number3: number;
    number4: number;
    number5: number;
    number6: number;
    number7: number;
    number8: number;
    number9: number;
    number10: number;
    parentId: string | undefined;
    index: number;
    order: number;
    groupCode: string | undefined;
    hashCode: string | undefined;
    value11: string | undefined;
    value12: string | undefined;
    value13: string | undefined;
    value14: string | undefined;
    value15: string | undefined;
    value16: string | undefined;
    value17: string | undefined;
    value18: string | undefined;
    value19: string | undefined;
    value20: string | undefined;
    listPermission: CategoryPermissionOutputDto[] | undefined;
    parentCode: string | undefined;
    parentName: string | undefined;
    listChild: SSOCategoryOutputDto[] | undefined;
}

export class GuidEntityDto implements IGuidEntityDto {
    id: string;

    constructor(data?: IGuidEntityDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
        }
    }

    static fromJS(data: any): GuidEntityDto {
        data = typeof data === 'object' ? data : {};
        let result = new GuidEntityDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        return data; 
    }

    clone(): GuidEntityDto {
        const json = this.toJSON();
        let result = new GuidEntityDto();
        result.init(json);
        return result;
    }
}

export interface IGuidEntityDto {
    id: string;
}

export class CategoryPermissionInputDto implements ICategoryPermissionInputDto {
    id: string;
    categoryId: string;
    typeId: string | undefined;
    organizationId: string | undefined;
    permissionId: string | undefined;
    userId: number | undefined;
    access: string | undefined;
    actions: string | undefined;
    fields: string | undefined;

    constructor(data?: ICategoryPermissionInputDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.categoryId = data["categoryId"];
            this.typeId = data["typeId"];
            this.organizationId = data["organizationId"];
            this.permissionId = data["permissionId"];
            this.userId = data["userId"];
            this.access = data["access"];
            this.actions = data["actions"];
            this.fields = data["fields"];
        }
    }

    static fromJS(data: any): CategoryPermissionInputDto {
        data = typeof data === 'object' ? data : {};
        let result = new CategoryPermissionInputDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["categoryId"] = this.categoryId;
        data["typeId"] = this.typeId;
        data["organizationId"] = this.organizationId;
        data["permissionId"] = this.permissionId;
        data["userId"] = this.userId;
        data["access"] = this.access;
        data["actions"] = this.actions;
        data["fields"] = this.fields;
        return data; 
    }

    clone(): CategoryPermissionInputDto {
        const json = this.toJSON();
        let result = new CategoryPermissionInputDto();
        result.init(json);
        return result;
    }
}

export interface ICategoryPermissionInputDto {
    id: string;
    categoryId: string;
    typeId: string | undefined;
    organizationId: string | undefined;
    permissionId: string | undefined;
    userId: number | undefined;
    access: string | undefined;
    actions: string | undefined;
    fields: string | undefined;
}

export class SSOCategoryInputDto implements ISSOCategoryInputDto {
    id: string;
    tenantId: number | undefined;
    status: string | undefined;
    search: string | undefined;
    hideValue: string | undefined;
    creatorUserId: number | undefined;
    creationTime: moment.Moment;
    name: string | undefined;
    code: string | undefined;
    codeData: string | undefined;
    valueData: string | undefined;
    category: string | undefined;
    permissions: string | undefined;
    language: string | undefined;
    value1: string | undefined;
    value2: string | undefined;
    value3: string | undefined;
    value4: string | undefined;
    value5: string | undefined;
    value6: string | undefined;
    value7: string | undefined;
    value8: string | undefined;
    value9: string | undefined;
    value10: string | undefined;
    number1: number;
    number2: number;
    number3: number;
    number4: number;
    number5: number;
    number6: number;
    number7: number;
    number8: number;
    number9: number;
    number10: number;
    parentId: string | undefined;
    index: number;
    order: number;
    groupCode: string | undefined;
    hashCode: string | undefined;
    value11: string | undefined;
    value12: string | undefined;
    value13: string | undefined;
    value14: string | undefined;
    value15: string | undefined;
    value16: string | undefined;
    value17: string | undefined;
    value18: string | undefined;
    value19: string | undefined;
    value20: string | undefined;
    listPermission: CategoryPermissionInputDto[] | undefined;

    constructor(data?: ISSOCategoryInputDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.tenantId = data["tenantId"];
            this.status = data["status"];
            this.search = data["search"];
            this.hideValue = data["hideValue"];
            this.creatorUserId = data["creatorUserId"];
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.name = data["name"];
            this.code = data["code"];
            this.codeData = data["codeData"];
            this.valueData = data["valueData"];
            this.category = data["category"];
            this.permissions = data["permissions"];
            this.language = data["language"];
            this.value1 = data["value1"];
            this.value2 = data["value2"];
            this.value3 = data["value3"];
            this.value4 = data["value4"];
            this.value5 = data["value5"];
            this.value6 = data["value6"];
            this.value7 = data["value7"];
            this.value8 = data["value8"];
            this.value9 = data["value9"];
            this.value10 = data["value10"];
            this.number1 = data["number1"];
            this.number2 = data["number2"];
            this.number3 = data["number3"];
            this.number4 = data["number4"];
            this.number5 = data["number5"];
            this.number6 = data["number6"];
            this.number7 = data["number7"];
            this.number8 = data["number8"];
            this.number9 = data["number9"];
            this.number10 = data["number10"];
            this.parentId = data["parentId"];
            this.index = data["index"];
            this.order = data["order"];
            this.groupCode = data["groupCode"];
            this.hashCode = data["hashCode"];
            this.value11 = data["value11"];
            this.value12 = data["value12"];
            this.value13 = data["value13"];
            this.value14 = data["value14"];
            this.value15 = data["value15"];
            this.value16 = data["value16"];
            this.value17 = data["value17"];
            this.value18 = data["value18"];
            this.value19 = data["value19"];
            this.value20 = data["value20"];
            if (data["listPermission"] && data["listPermission"].constructor === Array) {
                this.listPermission = [] as any;
                for (let item of data["listPermission"])
                    this.listPermission.push(CategoryPermissionInputDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): SSOCategoryInputDto {
        data = typeof data === 'object' ? data : {};
        let result = new SSOCategoryInputDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["tenantId"] = this.tenantId;
        data["status"] = this.status;
        data["search"] = this.search;
        data["hideValue"] = this.hideValue;
        data["creatorUserId"] = this.creatorUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["name"] = this.name;
        data["code"] = this.code;
        data["codeData"] = this.codeData;
        data["valueData"] = this.valueData;
        data["category"] = this.category;
        data["permissions"] = this.permissions;
        data["language"] = this.language;
        data["value1"] = this.value1;
        data["value2"] = this.value2;
        data["value3"] = this.value3;
        data["value4"] = this.value4;
        data["value5"] = this.value5;
        data["value6"] = this.value6;
        data["value7"] = this.value7;
        data["value8"] = this.value8;
        data["value9"] = this.value9;
        data["value10"] = this.value10;
        data["number1"] = this.number1;
        data["number2"] = this.number2;
        data["number3"] = this.number3;
        data["number4"] = this.number4;
        data["number5"] = this.number5;
        data["number6"] = this.number6;
        data["number7"] = this.number7;
        data["number8"] = this.number8;
        data["number9"] = this.number9;
        data["number10"] = this.number10;
        data["parentId"] = this.parentId;
        data["index"] = this.index;
        data["order"] = this.order;
        data["groupCode"] = this.groupCode;
        data["hashCode"] = this.hashCode;
        data["value11"] = this.value11;
        data["value12"] = this.value12;
        data["value13"] = this.value13;
        data["value14"] = this.value14;
        data["value15"] = this.value15;
        data["value16"] = this.value16;
        data["value17"] = this.value17;
        data["value18"] = this.value18;
        data["value19"] = this.value19;
        data["value20"] = this.value20;
        if (this.listPermission && this.listPermission.constructor === Array) {
            data["listPermission"] = [];
            for (let item of this.listPermission)
                data["listPermission"].push(item.toJSON());
        }
        return data; 
    }

    clone(): SSOCategoryInputDto {
        const json = this.toJSON();
        let result = new SSOCategoryInputDto();
        result.init(json);
        return result;
    }
}

export interface ISSOCategoryInputDto {
    id: string;
    tenantId: number | undefined;
    status: string | undefined;
    search: string | undefined;
    hideValue: string | undefined;
    creatorUserId: number | undefined;
    creationTime: moment.Moment;
    name: string | undefined;
    code: string | undefined;
    codeData: string | undefined;
    valueData: string | undefined;
    category: string | undefined;
    permissions: string | undefined;
    language: string | undefined;
    value1: string | undefined;
    value2: string | undefined;
    value3: string | undefined;
    value4: string | undefined;
    value5: string | undefined;
    value6: string | undefined;
    value7: string | undefined;
    value8: string | undefined;
    value9: string | undefined;
    value10: string | undefined;
    number1: number;
    number2: number;
    number3: number;
    number4: number;
    number5: number;
    number6: number;
    number7: number;
    number8: number;
    number9: number;
    number10: number;
    parentId: string | undefined;
    index: number;
    order: number;
    groupCode: string | undefined;
    hashCode: string | undefined;
    value11: string | undefined;
    value12: string | undefined;
    value13: string | undefined;
    value14: string | undefined;
    value15: string | undefined;
    value16: string | undefined;
    value17: string | undefined;
    value18: string | undefined;
    value19: string | undefined;
    value20: string | undefined;
    listPermission: CategoryPermissionInputDto[] | undefined;
}

export class SSOCategoryPermissionsDto implements ISSOCategoryPermissionsDto {
    id: string;
    listPermission: CategoryPermissionInputDto[] | undefined;

    constructor(data?: ISSOCategoryPermissionsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            if (data["listPermission"] && data["listPermission"].constructor === Array) {
                this.listPermission = [] as any;
                for (let item of data["listPermission"])
                    this.listPermission.push(CategoryPermissionInputDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): SSOCategoryPermissionsDto {
        data = typeof data === 'object' ? data : {};
        let result = new SSOCategoryPermissionsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        if (this.listPermission && this.listPermission.constructor === Array) {
            data["listPermission"] = [];
            for (let item of this.listPermission)
                data["listPermission"].push(item.toJSON());
        }
        return data; 
    }

    clone(): SSOCategoryPermissionsDto {
        const json = this.toJSON();
        let result = new SSOCategoryPermissionsDto();
        result.init(json);
        return result;
    }
}

export interface ISSOCategoryPermissionsDto {
    id: string;
    listPermission: CategoryPermissionInputDto[] | undefined;
}

export class SSOCategoryStateOutputDto implements ISSOCategoryStateOutputDto {
    id: string;
    parentId: string | undefined;
    name: string | undefined;
    codeData: string | undefined;
    valueData: string | undefined;
    groupCode: string | undefined;
    order: number;
    hideValue: string | undefined;
    language: string | undefined;
    number1: number;
    number2: number;
    number3: number;
    number4: number;
    number5: number;
    value1: string | undefined;
    value2: string | undefined;
    value3: string | undefined;
    value4: string | undefined;
    value5: string | undefined;
    value6: string | undefined;
    value7: string | undefined;
    value8: string | undefined;
    value9: string | undefined;
    value10: string | undefined;
    value11: string | undefined;
    value12: string | undefined;
    value13: string | undefined;
    value14: string | undefined;
    value15: string | undefined;
    value16: string | undefined;
    value17: string | undefined;
    value18: string | undefined;
    value19: string | undefined;
    value20: string | undefined;
    listChild: SSOCategoryStateOutputDto[] | undefined;

    constructor(data?: ISSOCategoryStateOutputDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.parentId = data["parentId"];
            this.name = data["name"];
            this.codeData = data["codeData"];
            this.valueData = data["valueData"];
            this.groupCode = data["groupCode"];
            this.order = data["order"];
            this.hideValue = data["hideValue"];
            this.language = data["language"];
            this.number1 = data["number1"];
            this.number2 = data["number2"];
            this.number3 = data["number3"];
            this.number4 = data["number4"];
            this.number5 = data["number5"];
            this.value1 = data["value1"];
            this.value2 = data["value2"];
            this.value3 = data["value3"];
            this.value4 = data["value4"];
            this.value5 = data["value5"];
            this.value6 = data["value6"];
            this.value7 = data["value7"];
            this.value8 = data["value8"];
            this.value9 = data["value9"];
            this.value10 = data["value10"];
            this.value11 = data["value11"];
            this.value12 = data["value12"];
            this.value13 = data["value13"];
            this.value14 = data["value14"];
            this.value15 = data["value15"];
            this.value16 = data["value16"];
            this.value17 = data["value17"];
            this.value18 = data["value18"];
            this.value19 = data["value19"];
            this.value20 = data["value20"];
            if (data["listChild"] && data["listChild"].constructor === Array) {
                this.listChild = [] as any;
                for (let item of data["listChild"])
                    this.listChild.push(SSOCategoryStateOutputDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): SSOCategoryStateOutputDto {
        data = typeof data === 'object' ? data : {};
        let result = new SSOCategoryStateOutputDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["parentId"] = this.parentId;
        data["name"] = this.name;
        data["codeData"] = this.codeData;
        data["valueData"] = this.valueData;
        data["groupCode"] = this.groupCode;
        data["order"] = this.order;
        data["hideValue"] = this.hideValue;
        data["language"] = this.language;
        data["number1"] = this.number1;
        data["number2"] = this.number2;
        data["number3"] = this.number3;
        data["number4"] = this.number4;
        data["number5"] = this.number5;
        data["value1"] = this.value1;
        data["value2"] = this.value2;
        data["value3"] = this.value3;
        data["value4"] = this.value4;
        data["value5"] = this.value5;
        data["value6"] = this.value6;
        data["value7"] = this.value7;
        data["value8"] = this.value8;
        data["value9"] = this.value9;
        data["value10"] = this.value10;
        data["value11"] = this.value11;
        data["value12"] = this.value12;
        data["value13"] = this.value13;
        data["value14"] = this.value14;
        data["value15"] = this.value15;
        data["value16"] = this.value16;
        data["value17"] = this.value17;
        data["value18"] = this.value18;
        data["value19"] = this.value19;
        data["value20"] = this.value20;
        if (this.listChild && this.listChild.constructor === Array) {
            data["listChild"] = [];
            for (let item of this.listChild)
                data["listChild"].push(item.toJSON());
        }
        return data; 
    }

    clone(): SSOCategoryStateOutputDto {
        const json = this.toJSON();
        let result = new SSOCategoryStateOutputDto();
        result.init(json);
        return result;
    }
}

export interface ISSOCategoryStateOutputDto {
    id: string;
    parentId: string | undefined;
    name: string | undefined;
    codeData: string | undefined;
    valueData: string | undefined;
    groupCode: string | undefined;
    order: number;
    hideValue: string | undefined;
    language: string | undefined;
    number1: number;
    number2: number;
    number3: number;
    number4: number;
    number5: number;
    value1: string | undefined;
    value2: string | undefined;
    value3: string | undefined;
    value4: string | undefined;
    value5: string | undefined;
    value6: string | undefined;
    value7: string | undefined;
    value8: string | undefined;
    value9: string | undefined;
    value10: string | undefined;
    value11: string | undefined;
    value12: string | undefined;
    value13: string | undefined;
    value14: string | undefined;
    value15: string | undefined;
    value16: string | undefined;
    value17: string | undefined;
    value18: string | undefined;
    value19: string | undefined;
    value20: string | undefined;
    listChild: SSOCategoryStateOutputDto[] | undefined;
}

export class SSOCategoryPermissionDto implements ISSOCategoryPermissionDto {
    id: string;
    categoryId: string;
    typeId: string | undefined;
    organizationId: string | undefined;
    permissionId: string | undefined;
    userId: number | undefined;
    access: string | undefined;
    actions: string | undefined;
    fields: string | undefined;

    constructor(data?: ISSOCategoryPermissionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.categoryId = data["categoryId"];
            this.typeId = data["typeId"];
            this.organizationId = data["organizationId"];
            this.permissionId = data["permissionId"];
            this.userId = data["userId"];
            this.access = data["access"];
            this.actions = data["actions"];
            this.fields = data["fields"];
        }
    }

    static fromJS(data: any): SSOCategoryPermissionDto {
        data = typeof data === 'object' ? data : {};
        let result = new SSOCategoryPermissionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["categoryId"] = this.categoryId;
        data["typeId"] = this.typeId;
        data["organizationId"] = this.organizationId;
        data["permissionId"] = this.permissionId;
        data["userId"] = this.userId;
        data["access"] = this.access;
        data["actions"] = this.actions;
        data["fields"] = this.fields;
        return data; 
    }

    clone(): SSOCategoryPermissionDto {
        const json = this.toJSON();
        let result = new SSOCategoryPermissionDto();
        result.init(json);
        return result;
    }
}

export interface ISSOCategoryPermissionDto {
    id: string;
    categoryId: string;
    typeId: string | undefined;
    organizationId: string | undefined;
    permissionId: string | undefined;
    userId: number | undefined;
    access: string | undefined;
    actions: string | undefined;
    fields: string | undefined;
}

export class OrganizationGuidGetDto implements IOrganizationGuidGetDto {
    maxResultCount: number;
    skipCount: number;
    sorting: string | undefined;
    criterias: CriteriaRequestDto[] | undefined;
    tenantId: number | undefined;
    userId: number | undefined;
    id: string;
    language: string | undefined;
    option: string | undefined;
    search: string | undefined;
    status: string | undefined;
    from: moment.Moment | undefined;
    to: moment.Moment | undefined;
    sValue: string[] | undefined;
    lValue: number[] | undefined;
    gValue: string[] | undefined;
    dValue: number[] | undefined;
    tValue: moment.Moment[] | undefined;

    constructor(data?: IOrganizationGuidGetDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.maxResultCount = data["maxResultCount"];
            this.skipCount = data["skipCount"];
            this.sorting = data["sorting"];
            if (data["criterias"] && data["criterias"].constructor === Array) {
                this.criterias = [] as any;
                for (let item of data["criterias"])
                    this.criterias.push(CriteriaRequestDto.fromJS(item));
            }
            this.tenantId = data["tenantId"];
            this.userId = data["userId"];
            this.id = data["id"];
            this.language = data["language"];
            this.option = data["option"];
            this.search = data["search"];
            this.status = data["status"];
            this.from = data["from"] ? moment(data["from"].toString()) : <any>undefined;
            this.to = data["to"] ? moment(data["to"].toString()) : <any>undefined;
            if (data["sValue"] && data["sValue"].constructor === Array) {
                this.sValue = [] as any;
                for (let item of data["sValue"])
                    this.sValue.push(item);
            }
            if (data["lValue"] && data["lValue"].constructor === Array) {
                this.lValue = [] as any;
                for (let item of data["lValue"])
                    this.lValue.push(item);
            }
            if (data["gValue"] && data["gValue"].constructor === Array) {
                this.gValue = [] as any;
                for (let item of data["gValue"])
                    this.gValue.push(item);
            }
            if (data["dValue"] && data["dValue"].constructor === Array) {
                this.dValue = [] as any;
                for (let item of data["dValue"])
                    this.dValue.push(item);
            }
            if (data["tValue"] && data["tValue"].constructor === Array) {
                this.tValue = [] as any;
                for (let item of data["tValue"])
                    this.tValue.push(moment(item));
            }
        }
    }

    static fromJS(data: any): OrganizationGuidGetDto {
        data = typeof data === 'object' ? data : {};
        let result = new OrganizationGuidGetDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["maxResultCount"] = this.maxResultCount;
        data["skipCount"] = this.skipCount;
        data["sorting"] = this.sorting;
        if (this.criterias && this.criterias.constructor === Array) {
            data["criterias"] = [];
            for (let item of this.criterias)
                data["criterias"].push(item.toJSON());
        }
        data["tenantId"] = this.tenantId;
        data["userId"] = this.userId;
        data["id"] = this.id;
        data["language"] = this.language;
        data["option"] = this.option;
        data["search"] = this.search;
        data["status"] = this.status;
        data["from"] = this.from ? this.from.toISOString() : <any>undefined;
        data["to"] = this.to ? this.to.toISOString() : <any>undefined;
        if (this.sValue && this.sValue.constructor === Array) {
            data["sValue"] = [];
            for (let item of this.sValue)
                data["sValue"].push(item);
        }
        if (this.lValue && this.lValue.constructor === Array) {
            data["lValue"] = [];
            for (let item of this.lValue)
                data["lValue"].push(item);
        }
        if (this.gValue && this.gValue.constructor === Array) {
            data["gValue"] = [];
            for (let item of this.gValue)
                data["gValue"].push(item);
        }
        if (this.dValue && this.dValue.constructor === Array) {
            data["dValue"] = [];
            for (let item of this.dValue)
                data["dValue"].push(item);
        }
        if (this.tValue && this.tValue.constructor === Array) {
            data["tValue"] = [];
            for (let item of this.tValue)
                data["tValue"].push(item.toISOString());
        }
        return data; 
    }

    clone(): OrganizationGuidGetDto {
        const json = this.toJSON();
        let result = new OrganizationGuidGetDto();
        result.init(json);
        return result;
    }
}

export interface IOrganizationGuidGetDto {
    maxResultCount: number;
    skipCount: number;
    sorting: string | undefined;
    criterias: CriteriaRequestDto[] | undefined;
    tenantId: number | undefined;
    userId: number | undefined;
    id: string;
    language: string | undefined;
    option: string | undefined;
    search: string | undefined;
    status: string | undefined;
    from: moment.Moment | undefined;
    to: moment.Moment | undefined;
    sValue: string[] | undefined;
    lValue: number[] | undefined;
    gValue: string[] | undefined;
    dValue: number[] | undefined;
    tValue: moment.Moment[] | undefined;
}

export class ValueCategoryDto implements IValueCategoryDto {
    id: string;
    code: string | undefined;
    securityCode: string | undefined;
    type: string | undefined;

    constructor(data?: IValueCategoryDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.code = data["code"];
            this.securityCode = data["securityCode"];
            this.type = data["type"];
        }
    }

    static fromJS(data: any): ValueCategoryDto {
        data = typeof data === 'object' ? data : {};
        let result = new ValueCategoryDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["code"] = this.code;
        data["securityCode"] = this.securityCode;
        data["type"] = this.type;
        return data; 
    }

    clone(): ValueCategoryDto {
        const json = this.toJSON();
        let result = new ValueCategoryDto();
        result.init(json);
        return result;
    }
}

export interface IValueCategoryDto {
    id: string;
    code: string | undefined;
    securityCode: string | undefined;
    type: string | undefined;
}

export class OrganizationOutputDto implements IOrganizationOutputDto {
    id: string;
    tenantId: number;
    status: string | undefined;
    search: string | undefined;
    hideValue: string | undefined;
    creatorUserId: number | undefined;
    creationTime: moment.Moment;
    name: string | undefined;
    code: string | undefined;
    codeData: string | undefined;
    valueData: string | undefined;
    category: string | undefined;
    permissions: string | undefined;
    language: string | undefined;
    value1: string | undefined;
    value2: string | undefined;
    value3: string | undefined;
    value4: string | undefined;
    value5: string | undefined;
    value6: string | undefined;
    value7: string | undefined;
    value8: string | undefined;
    value9: string | undefined;
    value10: string | undefined;
    number1: number;
    number2: number;
    number3: number;
    number4: number;
    number5: number;
    number6: number;
    number7: number;
    number8: number;
    number9: number;
    number10: number;
    parentId: string | undefined;
    index: number;
    order: number;
    groupCode: string | undefined;
    hashCode: string | undefined;
    token: string | undefined;
    titles: string | undefined;
    profiles: string | undefined;
    listCategory: ValueCategoryDto[] | undefined;
    parentCode: string | undefined;
    parentName: string | undefined;
    securityCode: string | undefined;

    constructor(data?: IOrganizationOutputDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.tenantId = data["tenantId"];
            this.status = data["status"];
            this.search = data["search"];
            this.hideValue = data["hideValue"];
            this.creatorUserId = data["creatorUserId"];
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.name = data["name"];
            this.code = data["code"];
            this.codeData = data["codeData"];
            this.valueData = data["valueData"];
            this.category = data["category"];
            this.permissions = data["permissions"];
            this.language = data["language"];
            this.value1 = data["value1"];
            this.value2 = data["value2"];
            this.value3 = data["value3"];
            this.value4 = data["value4"];
            this.value5 = data["value5"];
            this.value6 = data["value6"];
            this.value7 = data["value7"];
            this.value8 = data["value8"];
            this.value9 = data["value9"];
            this.value10 = data["value10"];
            this.number1 = data["number1"];
            this.number2 = data["number2"];
            this.number3 = data["number3"];
            this.number4 = data["number4"];
            this.number5 = data["number5"];
            this.number6 = data["number6"];
            this.number7 = data["number7"];
            this.number8 = data["number8"];
            this.number9 = data["number9"];
            this.number10 = data["number10"];
            this.parentId = data["parentId"];
            this.index = data["index"];
            this.order = data["order"];
            this.groupCode = data["groupCode"];
            this.hashCode = data["hashCode"];
            this.token = data["token"];
            this.titles = data["titles"];
            this.profiles = data["profiles"];
            if (data["listCategory"] && data["listCategory"].constructor === Array) {
                this.listCategory = [] as any;
                for (let item of data["listCategory"])
                    this.listCategory.push(ValueCategoryDto.fromJS(item));
            }
            this.parentCode = data["parentCode"];
            this.parentName = data["parentName"];
            this.securityCode = data["securityCode"];
        }
    }

    static fromJS(data: any): OrganizationOutputDto {
        data = typeof data === 'object' ? data : {};
        let result = new OrganizationOutputDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["tenantId"] = this.tenantId;
        data["status"] = this.status;
        data["search"] = this.search;
        data["hideValue"] = this.hideValue;
        data["creatorUserId"] = this.creatorUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["name"] = this.name;
        data["code"] = this.code;
        data["codeData"] = this.codeData;
        data["valueData"] = this.valueData;
        data["category"] = this.category;
        data["permissions"] = this.permissions;
        data["language"] = this.language;
        data["value1"] = this.value1;
        data["value2"] = this.value2;
        data["value3"] = this.value3;
        data["value4"] = this.value4;
        data["value5"] = this.value5;
        data["value6"] = this.value6;
        data["value7"] = this.value7;
        data["value8"] = this.value8;
        data["value9"] = this.value9;
        data["value10"] = this.value10;
        data["number1"] = this.number1;
        data["number2"] = this.number2;
        data["number3"] = this.number3;
        data["number4"] = this.number4;
        data["number5"] = this.number5;
        data["number6"] = this.number6;
        data["number7"] = this.number7;
        data["number8"] = this.number8;
        data["number9"] = this.number9;
        data["number10"] = this.number10;
        data["parentId"] = this.parentId;
        data["index"] = this.index;
        data["order"] = this.order;
        data["groupCode"] = this.groupCode;
        data["hashCode"] = this.hashCode;
        data["token"] = this.token;
        data["titles"] = this.titles;
        data["profiles"] = this.profiles;
        if (this.listCategory && this.listCategory.constructor === Array) {
            data["listCategory"] = [];
            for (let item of this.listCategory)
                data["listCategory"].push(item.toJSON());
        }
        data["parentCode"] = this.parentCode;
        data["parentName"] = this.parentName;
        data["securityCode"] = this.securityCode;
        return data; 
    }

    clone(): OrganizationOutputDto {
        const json = this.toJSON();
        let result = new OrganizationOutputDto();
        result.init(json);
        return result;
    }
}

export interface IOrganizationOutputDto {
    id: string;
    tenantId: number;
    status: string | undefined;
    search: string | undefined;
    hideValue: string | undefined;
    creatorUserId: number | undefined;
    creationTime: moment.Moment;
    name: string | undefined;
    code: string | undefined;
    codeData: string | undefined;
    valueData: string | undefined;
    category: string | undefined;
    permissions: string | undefined;
    language: string | undefined;
    value1: string | undefined;
    value2: string | undefined;
    value3: string | undefined;
    value4: string | undefined;
    value5: string | undefined;
    value6: string | undefined;
    value7: string | undefined;
    value8: string | undefined;
    value9: string | undefined;
    value10: string | undefined;
    number1: number;
    number2: number;
    number3: number;
    number4: number;
    number5: number;
    number6: number;
    number7: number;
    number8: number;
    number9: number;
    number10: number;
    parentId: string | undefined;
    index: number;
    order: number;
    groupCode: string | undefined;
    hashCode: string | undefined;
    token: string | undefined;
    titles: string | undefined;
    profiles: string | undefined;
    listCategory: ValueCategoryDto[] | undefined;
    parentCode: string | undefined;
    parentName: string | undefined;
    securityCode: string | undefined;
}

export class OrganizationInputDto implements IOrganizationInputDto {
    id: string;
    tenantId: number;
    status: string | undefined;
    search: string | undefined;
    hideValue: string | undefined;
    creatorUserId: number | undefined;
    creationTime: moment.Moment;
    name: string | undefined;
    code: string | undefined;
    codeData: string | undefined;
    valueData: string | undefined;
    category: string | undefined;
    permissions: string | undefined;
    language: string | undefined;
    value1: string | undefined;
    value2: string | undefined;
    value3: string | undefined;
    value4: string | undefined;
    value5: string | undefined;
    value6: string | undefined;
    value7: string | undefined;
    value8: string | undefined;
    value9: string | undefined;
    value10: string | undefined;
    number1: number;
    number2: number;
    number3: number;
    number4: number;
    number5: number;
    number6: number;
    number7: number;
    number8: number;
    number9: number;
    number10: number;
    parentId: string | undefined;
    index: number;
    order: number;
    groupCode: string | undefined;
    hashCode: string | undefined;
    token: string | undefined;
    titles: string | undefined;
    profiles: string | undefined;
    listCategory: ValueCategoryDto[] | undefined;

    constructor(data?: IOrganizationInputDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.tenantId = data["tenantId"];
            this.status = data["status"];
            this.search = data["search"];
            this.hideValue = data["hideValue"];
            this.creatorUserId = data["creatorUserId"];
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.name = data["name"];
            this.code = data["code"];
            this.codeData = data["codeData"];
            this.valueData = data["valueData"];
            this.category = data["category"];
            this.permissions = data["permissions"];
            this.language = data["language"];
            this.value1 = data["value1"];
            this.value2 = data["value2"];
            this.value3 = data["value3"];
            this.value4 = data["value4"];
            this.value5 = data["value5"];
            this.value6 = data["value6"];
            this.value7 = data["value7"];
            this.value8 = data["value8"];
            this.value9 = data["value9"];
            this.value10 = data["value10"];
            this.number1 = data["number1"];
            this.number2 = data["number2"];
            this.number3 = data["number3"];
            this.number4 = data["number4"];
            this.number5 = data["number5"];
            this.number6 = data["number6"];
            this.number7 = data["number7"];
            this.number8 = data["number8"];
            this.number9 = data["number9"];
            this.number10 = data["number10"];
            this.parentId = data["parentId"];
            this.index = data["index"];
            this.order = data["order"];
            this.groupCode = data["groupCode"];
            this.hashCode = data["hashCode"];
            this.token = data["token"];
            this.titles = data["titles"];
            this.profiles = data["profiles"];
            if (data["listCategory"] && data["listCategory"].constructor === Array) {
                this.listCategory = [] as any;
                for (let item of data["listCategory"])
                    this.listCategory.push(ValueCategoryDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): OrganizationInputDto {
        data = typeof data === 'object' ? data : {};
        let result = new OrganizationInputDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["tenantId"] = this.tenantId;
        data["status"] = this.status;
        data["search"] = this.search;
        data["hideValue"] = this.hideValue;
        data["creatorUserId"] = this.creatorUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["name"] = this.name;
        data["code"] = this.code;
        data["codeData"] = this.codeData;
        data["valueData"] = this.valueData;
        data["category"] = this.category;
        data["permissions"] = this.permissions;
        data["language"] = this.language;
        data["value1"] = this.value1;
        data["value2"] = this.value2;
        data["value3"] = this.value3;
        data["value4"] = this.value4;
        data["value5"] = this.value5;
        data["value6"] = this.value6;
        data["value7"] = this.value7;
        data["value8"] = this.value8;
        data["value9"] = this.value9;
        data["value10"] = this.value10;
        data["number1"] = this.number1;
        data["number2"] = this.number2;
        data["number3"] = this.number3;
        data["number4"] = this.number4;
        data["number5"] = this.number5;
        data["number6"] = this.number6;
        data["number7"] = this.number7;
        data["number8"] = this.number8;
        data["number9"] = this.number9;
        data["number10"] = this.number10;
        data["parentId"] = this.parentId;
        data["index"] = this.index;
        data["order"] = this.order;
        data["groupCode"] = this.groupCode;
        data["hashCode"] = this.hashCode;
        data["token"] = this.token;
        data["titles"] = this.titles;
        data["profiles"] = this.profiles;
        if (this.listCategory && this.listCategory.constructor === Array) {
            data["listCategory"] = [];
            for (let item of this.listCategory)
                data["listCategory"].push(item.toJSON());
        }
        return data; 
    }

    clone(): OrganizationInputDto {
        const json = this.toJSON();
        let result = new OrganizationInputDto();
        result.init(json);
        return result;
    }
}

export interface IOrganizationInputDto {
    id: string;
    tenantId: number;
    status: string | undefined;
    search: string | undefined;
    hideValue: string | undefined;
    creatorUserId: number | undefined;
    creationTime: moment.Moment;
    name: string | undefined;
    code: string | undefined;
    codeData: string | undefined;
    valueData: string | undefined;
    category: string | undefined;
    permissions: string | undefined;
    language: string | undefined;
    value1: string | undefined;
    value2: string | undefined;
    value3: string | undefined;
    value4: string | undefined;
    value5: string | undefined;
    value6: string | undefined;
    value7: string | undefined;
    value8: string | undefined;
    value9: string | undefined;
    value10: string | undefined;
    number1: number;
    number2: number;
    number3: number;
    number4: number;
    number5: number;
    number6: number;
    number7: number;
    number8: number;
    number9: number;
    number10: number;
    parentId: string | undefined;
    index: number;
    order: number;
    groupCode: string | undefined;
    hashCode: string | undefined;
    token: string | undefined;
    titles: string | undefined;
    profiles: string | undefined;
    listCategory: ValueCategoryDto[] | undefined;
}

export class OrganizationategoryDto implements IOrganizationategoryDto {
    id: string;
    listCategory: ValueCategoryDto[] | undefined;

    constructor(data?: IOrganizationategoryDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            if (data["listCategory"] && data["listCategory"].constructor === Array) {
                this.listCategory = [] as any;
                for (let item of data["listCategory"])
                    this.listCategory.push(ValueCategoryDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): OrganizationategoryDto {
        data = typeof data === 'object' ? data : {};
        let result = new OrganizationategoryDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        if (this.listCategory && this.listCategory.constructor === Array) {
            data["listCategory"] = [];
            for (let item of this.listCategory)
                data["listCategory"].push(item.toJSON());
        }
        return data; 
    }

    clone(): OrganizationategoryDto {
        const json = this.toJSON();
        let result = new OrganizationategoryDto();
        result.init(json);
        return result;
    }
}

export interface IOrganizationategoryDto {
    id: string;
    listCategory: ValueCategoryDto[] | undefined;
}

export class OrganizationUserGuidGetDto implements IOrganizationUserGuidGetDto {
    maxResultCount: number;
    skipCount: number;
    sorting: string | undefined;
    criterias: CriteriaRequestDto[] | undefined;
    tenantId: number | undefined;
    userId: number | undefined;
    id: string;
    language: string | undefined;
    option: string | undefined;
    search: string | undefined;
    status: string | undefined;
    from: moment.Moment | undefined;
    to: moment.Moment | undefined;
    sValue: string[] | undefined;
    lValue: number[] | undefined;
    gValue: string[] | undefined;
    dValue: number[] | undefined;
    tValue: moment.Moment[] | undefined;

    constructor(data?: IOrganizationUserGuidGetDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.maxResultCount = data["maxResultCount"];
            this.skipCount = data["skipCount"];
            this.sorting = data["sorting"];
            if (data["criterias"] && data["criterias"].constructor === Array) {
                this.criterias = [] as any;
                for (let item of data["criterias"])
                    this.criterias.push(CriteriaRequestDto.fromJS(item));
            }
            this.tenantId = data["tenantId"];
            this.userId = data["userId"];
            this.id = data["id"];
            this.language = data["language"];
            this.option = data["option"];
            this.search = data["search"];
            this.status = data["status"];
            this.from = data["from"] ? moment(data["from"].toString()) : <any>undefined;
            this.to = data["to"] ? moment(data["to"].toString()) : <any>undefined;
            if (data["sValue"] && data["sValue"].constructor === Array) {
                this.sValue = [] as any;
                for (let item of data["sValue"])
                    this.sValue.push(item);
            }
            if (data["lValue"] && data["lValue"].constructor === Array) {
                this.lValue = [] as any;
                for (let item of data["lValue"])
                    this.lValue.push(item);
            }
            if (data["gValue"] && data["gValue"].constructor === Array) {
                this.gValue = [] as any;
                for (let item of data["gValue"])
                    this.gValue.push(item);
            }
            if (data["dValue"] && data["dValue"].constructor === Array) {
                this.dValue = [] as any;
                for (let item of data["dValue"])
                    this.dValue.push(item);
            }
            if (data["tValue"] && data["tValue"].constructor === Array) {
                this.tValue = [] as any;
                for (let item of data["tValue"])
                    this.tValue.push(moment(item));
            }
        }
    }

    static fromJS(data: any): OrganizationUserGuidGetDto {
        data = typeof data === 'object' ? data : {};
        let result = new OrganizationUserGuidGetDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["maxResultCount"] = this.maxResultCount;
        data["skipCount"] = this.skipCount;
        data["sorting"] = this.sorting;
        if (this.criterias && this.criterias.constructor === Array) {
            data["criterias"] = [];
            for (let item of this.criterias)
                data["criterias"].push(item.toJSON());
        }
        data["tenantId"] = this.tenantId;
        data["userId"] = this.userId;
        data["id"] = this.id;
        data["language"] = this.language;
        data["option"] = this.option;
        data["search"] = this.search;
        data["status"] = this.status;
        data["from"] = this.from ? this.from.toISOString() : <any>undefined;
        data["to"] = this.to ? this.to.toISOString() : <any>undefined;
        if (this.sValue && this.sValue.constructor === Array) {
            data["sValue"] = [];
            for (let item of this.sValue)
                data["sValue"].push(item);
        }
        if (this.lValue && this.lValue.constructor === Array) {
            data["lValue"] = [];
            for (let item of this.lValue)
                data["lValue"].push(item);
        }
        if (this.gValue && this.gValue.constructor === Array) {
            data["gValue"] = [];
            for (let item of this.gValue)
                data["gValue"].push(item);
        }
        if (this.dValue && this.dValue.constructor === Array) {
            data["dValue"] = [];
            for (let item of this.dValue)
                data["dValue"].push(item);
        }
        if (this.tValue && this.tValue.constructor === Array) {
            data["tValue"] = [];
            for (let item of this.tValue)
                data["tValue"].push(item.toISOString());
        }
        return data; 
    }

    clone(): OrganizationUserGuidGetDto {
        const json = this.toJSON();
        let result = new OrganizationUserGuidGetDto();
        result.init(json);
        return result;
    }
}

export interface IOrganizationUserGuidGetDto {
    maxResultCount: number;
    skipCount: number;
    sorting: string | undefined;
    criterias: CriteriaRequestDto[] | undefined;
    tenantId: number | undefined;
    userId: number | undefined;
    id: string;
    language: string | undefined;
    option: string | undefined;
    search: string | undefined;
    status: string | undefined;
    from: moment.Moment | undefined;
    to: moment.Moment | undefined;
    sValue: string[] | undefined;
    lValue: number[] | undefined;
    gValue: string[] | undefined;
    dValue: number[] | undefined;
    tValue: moment.Moment[] | undefined;
}

export class ValueTitleDto implements IValueTitleDto {
    id: string;
    code: string | undefined;
    securityCode: string | undefined;
    name: string | undefined;
    index: number;

    constructor(data?: IValueTitleDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.code = data["code"];
            this.securityCode = data["securityCode"];
            this.name = data["name"];
            this.index = data["index"];
        }
    }

    static fromJS(data: any): ValueTitleDto {
        data = typeof data === 'object' ? data : {};
        let result = new ValueTitleDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["code"] = this.code;
        data["securityCode"] = this.securityCode;
        data["name"] = this.name;
        data["index"] = this.index;
        return data; 
    }

    clone(): ValueTitleDto {
        const json = this.toJSON();
        let result = new ValueTitleDto();
        result.init(json);
        return result;
    }
}

export interface IValueTitleDto {
    id: string;
    code: string | undefined;
    securityCode: string | undefined;
    name: string | undefined;
    index: number;
}

export class ValuePermissionDto implements IValuePermissionDto {
    id: string;
    code: string | undefined;
    securityCode: string | undefined;
    levelCode: string | undefined;
    type: string | undefined;

    constructor(data?: IValuePermissionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.code = data["code"];
            this.securityCode = data["securityCode"];
            this.levelCode = data["levelCode"];
            this.type = data["type"];
        }
    }

    static fromJS(data: any): ValuePermissionDto {
        data = typeof data === 'object' ? data : {};
        let result = new ValuePermissionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["code"] = this.code;
        data["securityCode"] = this.securityCode;
        data["levelCode"] = this.levelCode;
        data["type"] = this.type;
        return data; 
    }

    clone(): ValuePermissionDto {
        const json = this.toJSON();
        let result = new ValuePermissionDto();
        result.init(json);
        return result;
    }
}

export interface IValuePermissionDto {
    id: string;
    code: string | undefined;
    securityCode: string | undefined;
    levelCode: string | undefined;
    type: string | undefined;
}

export class UserOutputDto implements IUserOutputDto {
    id: number;
    userName: string | undefined;
    name: string | undefined;
    surname: string | undefined;
    emailAddress: string | undefined;
    fullName: string | undefined;
    profiles: string | undefined;
    contacts: string | undefined;
    isActive: boolean;

    constructor(data?: IUserOutputDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.userName = data["userName"];
            this.name = data["name"];
            this.surname = data["surname"];
            this.emailAddress = data["emailAddress"];
            this.fullName = data["fullName"];
            this.profiles = data["profiles"];
            this.contacts = data["contacts"];
            this.isActive = data["isActive"];
        }
    }

    static fromJS(data: any): UserOutputDto {
        data = typeof data === 'object' ? data : {};
        let result = new UserOutputDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["userName"] = this.userName;
        data["name"] = this.name;
        data["surname"] = this.surname;
        data["emailAddress"] = this.emailAddress;
        data["fullName"] = this.fullName;
        data["profiles"] = this.profiles;
        data["contacts"] = this.contacts;
        data["isActive"] = this.isActive;
        return data; 
    }

    clone(): UserOutputDto {
        const json = this.toJSON();
        let result = new UserOutputDto();
        result.init(json);
        return result;
    }
}

export interface IUserOutputDto {
    id: number;
    userName: string | undefined;
    name: string | undefined;
    surname: string | undefined;
    emailAddress: string | undefined;
    fullName: string | undefined;
    profiles: string | undefined;
    contacts: string | undefined;
    isActive: boolean;
}

export class OrganizationUserOutputDto implements IOrganizationUserOutputDto {
    id: string;
    tenantId: number;
    status: string | undefined;
    search: string | undefined;
    hideValue: string | undefined;
    creatorUserId: number | undefined;
    creationTime: moment.Moment;
    name: string | undefined;
    code: string | undefined;
    codeData: string | undefined;
    valueData: string | undefined;
    category: string | undefined;
    permissions: string | undefined;
    language: string | undefined;
    organizationId: string;
    userId: number;
    titleIndex: number;
    listTitle: ValueTitleDto[] | undefined;
    listPermission: ValuePermissionDto[] | undefined;
    listCategory: ValueCategoryDto[] | undefined;
    user: UserOutputDto;

    constructor(data?: IOrganizationUserOutputDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.tenantId = data["tenantId"];
            this.status = data["status"];
            this.search = data["search"];
            this.hideValue = data["hideValue"];
            this.creatorUserId = data["creatorUserId"];
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.name = data["name"];
            this.code = data["code"];
            this.codeData = data["codeData"];
            this.valueData = data["valueData"];
            this.category = data["category"];
            this.permissions = data["permissions"];
            this.language = data["language"];
            this.organizationId = data["organizationId"];
            this.userId = data["userId"];
            this.titleIndex = data["titleIndex"];
            if (data["listTitle"] && data["listTitle"].constructor === Array) {
                this.listTitle = [] as any;
                for (let item of data["listTitle"])
                    this.listTitle.push(ValueTitleDto.fromJS(item));
            }
            if (data["listPermission"] && data["listPermission"].constructor === Array) {
                this.listPermission = [] as any;
                for (let item of data["listPermission"])
                    this.listPermission.push(ValuePermissionDto.fromJS(item));
            }
            if (data["listCategory"] && data["listCategory"].constructor === Array) {
                this.listCategory = [] as any;
                for (let item of data["listCategory"])
                    this.listCategory.push(ValueCategoryDto.fromJS(item));
            }
            this.user = data["user"] ? UserOutputDto.fromJS(data["user"]) : <any>undefined;
        }
    }

    static fromJS(data: any): OrganizationUserOutputDto {
        data = typeof data === 'object' ? data : {};
        let result = new OrganizationUserOutputDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["tenantId"] = this.tenantId;
        data["status"] = this.status;
        data["search"] = this.search;
        data["hideValue"] = this.hideValue;
        data["creatorUserId"] = this.creatorUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["name"] = this.name;
        data["code"] = this.code;
        data["codeData"] = this.codeData;
        data["valueData"] = this.valueData;
        data["category"] = this.category;
        data["permissions"] = this.permissions;
        data["language"] = this.language;
        data["organizationId"] = this.organizationId;
        data["userId"] = this.userId;
        data["titleIndex"] = this.titleIndex;
        if (this.listTitle && this.listTitle.constructor === Array) {
            data["listTitle"] = [];
            for (let item of this.listTitle)
                data["listTitle"].push(item.toJSON());
        }
        if (this.listPermission && this.listPermission.constructor === Array) {
            data["listPermission"] = [];
            for (let item of this.listPermission)
                data["listPermission"].push(item.toJSON());
        }
        if (this.listCategory && this.listCategory.constructor === Array) {
            data["listCategory"] = [];
            for (let item of this.listCategory)
                data["listCategory"].push(item.toJSON());
        }
        data["user"] = this.user ? this.user.toJSON() : <any>undefined;
        return data; 
    }

    clone(): OrganizationUserOutputDto {
        const json = this.toJSON();
        let result = new OrganizationUserOutputDto();
        result.init(json);
        return result;
    }
}

export interface IOrganizationUserOutputDto {
    id: string;
    tenantId: number;
    status: string | undefined;
    search: string | undefined;
    hideValue: string | undefined;
    creatorUserId: number | undefined;
    creationTime: moment.Moment;
    name: string | undefined;
    code: string | undefined;
    codeData: string | undefined;
    valueData: string | undefined;
    category: string | undefined;
    permissions: string | undefined;
    language: string | undefined;
    organizationId: string;
    userId: number;
    titleIndex: number;
    listTitle: ValueTitleDto[] | undefined;
    listPermission: ValuePermissionDto[] | undefined;
    listCategory: ValueCategoryDto[] | undefined;
    user: UserOutputDto;
}

export class OrganizationUserInputDto implements IOrganizationUserInputDto {
    id: string;
    tenantId: number;
    status: string | undefined;
    search: string | undefined;
    hideValue: string | undefined;
    creatorUserId: number | undefined;
    creationTime: moment.Moment;
    name: string | undefined;
    code: string | undefined;
    codeData: string | undefined;
    valueData: string | undefined;
    category: string | undefined;
    permissions: string | undefined;
    language: string | undefined;
    organizationId: string;
    userId: number;
    titleIndex: number;
    listTitle: ValueTitleDto[] | undefined;
    listPermission: ValuePermissionDto[] | undefined;
    listCategory: ValueCategoryDto[] | undefined;

    constructor(data?: IOrganizationUserInputDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.tenantId = data["tenantId"];
            this.status = data["status"];
            this.search = data["search"];
            this.hideValue = data["hideValue"];
            this.creatorUserId = data["creatorUserId"];
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.name = data["name"];
            this.code = data["code"];
            this.codeData = data["codeData"];
            this.valueData = data["valueData"];
            this.category = data["category"];
            this.permissions = data["permissions"];
            this.language = data["language"];
            this.organizationId = data["organizationId"];
            this.userId = data["userId"];
            this.titleIndex = data["titleIndex"];
            if (data["listTitle"] && data["listTitle"].constructor === Array) {
                this.listTitle = [] as any;
                for (let item of data["listTitle"])
                    this.listTitle.push(ValueTitleDto.fromJS(item));
            }
            if (data["listPermission"] && data["listPermission"].constructor === Array) {
                this.listPermission = [] as any;
                for (let item of data["listPermission"])
                    this.listPermission.push(ValuePermissionDto.fromJS(item));
            }
            if (data["listCategory"] && data["listCategory"].constructor === Array) {
                this.listCategory = [] as any;
                for (let item of data["listCategory"])
                    this.listCategory.push(ValueCategoryDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): OrganizationUserInputDto {
        data = typeof data === 'object' ? data : {};
        let result = new OrganizationUserInputDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["tenantId"] = this.tenantId;
        data["status"] = this.status;
        data["search"] = this.search;
        data["hideValue"] = this.hideValue;
        data["creatorUserId"] = this.creatorUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["name"] = this.name;
        data["code"] = this.code;
        data["codeData"] = this.codeData;
        data["valueData"] = this.valueData;
        data["category"] = this.category;
        data["permissions"] = this.permissions;
        data["language"] = this.language;
        data["organizationId"] = this.organizationId;
        data["userId"] = this.userId;
        data["titleIndex"] = this.titleIndex;
        if (this.listTitle && this.listTitle.constructor === Array) {
            data["listTitle"] = [];
            for (let item of this.listTitle)
                data["listTitle"].push(item.toJSON());
        }
        if (this.listPermission && this.listPermission.constructor === Array) {
            data["listPermission"] = [];
            for (let item of this.listPermission)
                data["listPermission"].push(item.toJSON());
        }
        if (this.listCategory && this.listCategory.constructor === Array) {
            data["listCategory"] = [];
            for (let item of this.listCategory)
                data["listCategory"].push(item.toJSON());
        }
        return data; 
    }

    clone(): OrganizationUserInputDto {
        const json = this.toJSON();
        let result = new OrganizationUserInputDto();
        result.init(json);
        return result;
    }
}

export interface IOrganizationUserInputDto {
    id: string;
    tenantId: number;
    status: string | undefined;
    search: string | undefined;
    hideValue: string | undefined;
    creatorUserId: number | undefined;
    creationTime: moment.Moment;
    name: string | undefined;
    code: string | undefined;
    codeData: string | undefined;
    valueData: string | undefined;
    category: string | undefined;
    permissions: string | undefined;
    language: string | undefined;
    organizationId: string;
    userId: number;
    titleIndex: number;
    listTitle: ValueTitleDto[] | undefined;
    listPermission: ValuePermissionDto[] | undefined;
    listCategory: ValueCategoryDto[] | undefined;
}

export class TenantPermissionGuidGetDto implements ITenantPermissionGuidGetDto {
    maxResultCount: number;
    skipCount: number;
    sorting: string | undefined;
    criterias: CriteriaRequestDto[] | undefined;
    tenantId: number | undefined;
    userId: number | undefined;
    id: string;
    language: string | undefined;
    option: string | undefined;
    search: string | undefined;
    status: string | undefined;
    from: moment.Moment | undefined;
    to: moment.Moment | undefined;
    sValue: string[] | undefined;
    lValue: number[] | undefined;
    gValue: string[] | undefined;
    dValue: number[] | undefined;
    tValue: moment.Moment[] | undefined;

    constructor(data?: ITenantPermissionGuidGetDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.maxResultCount = data["maxResultCount"];
            this.skipCount = data["skipCount"];
            this.sorting = data["sorting"];
            if (data["criterias"] && data["criterias"].constructor === Array) {
                this.criterias = [] as any;
                for (let item of data["criterias"])
                    this.criterias.push(CriteriaRequestDto.fromJS(item));
            }
            this.tenantId = data["tenantId"];
            this.userId = data["userId"];
            this.id = data["id"];
            this.language = data["language"];
            this.option = data["option"];
            this.search = data["search"];
            this.status = data["status"];
            this.from = data["from"] ? moment(data["from"].toString()) : <any>undefined;
            this.to = data["to"] ? moment(data["to"].toString()) : <any>undefined;
            if (data["sValue"] && data["sValue"].constructor === Array) {
                this.sValue = [] as any;
                for (let item of data["sValue"])
                    this.sValue.push(item);
            }
            if (data["lValue"] && data["lValue"].constructor === Array) {
                this.lValue = [] as any;
                for (let item of data["lValue"])
                    this.lValue.push(item);
            }
            if (data["gValue"] && data["gValue"].constructor === Array) {
                this.gValue = [] as any;
                for (let item of data["gValue"])
                    this.gValue.push(item);
            }
            if (data["dValue"] && data["dValue"].constructor === Array) {
                this.dValue = [] as any;
                for (let item of data["dValue"])
                    this.dValue.push(item);
            }
            if (data["tValue"] && data["tValue"].constructor === Array) {
                this.tValue = [] as any;
                for (let item of data["tValue"])
                    this.tValue.push(moment(item));
            }
        }
    }

    static fromJS(data: any): TenantPermissionGuidGetDto {
        data = typeof data === 'object' ? data : {};
        let result = new TenantPermissionGuidGetDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["maxResultCount"] = this.maxResultCount;
        data["skipCount"] = this.skipCount;
        data["sorting"] = this.sorting;
        if (this.criterias && this.criterias.constructor === Array) {
            data["criterias"] = [];
            for (let item of this.criterias)
                data["criterias"].push(item.toJSON());
        }
        data["tenantId"] = this.tenantId;
        data["userId"] = this.userId;
        data["id"] = this.id;
        data["language"] = this.language;
        data["option"] = this.option;
        data["search"] = this.search;
        data["status"] = this.status;
        data["from"] = this.from ? this.from.toISOString() : <any>undefined;
        data["to"] = this.to ? this.to.toISOString() : <any>undefined;
        if (this.sValue && this.sValue.constructor === Array) {
            data["sValue"] = [];
            for (let item of this.sValue)
                data["sValue"].push(item);
        }
        if (this.lValue && this.lValue.constructor === Array) {
            data["lValue"] = [];
            for (let item of this.lValue)
                data["lValue"].push(item);
        }
        if (this.gValue && this.gValue.constructor === Array) {
            data["gValue"] = [];
            for (let item of this.gValue)
                data["gValue"].push(item);
        }
        if (this.dValue && this.dValue.constructor === Array) {
            data["dValue"] = [];
            for (let item of this.dValue)
                data["dValue"].push(item);
        }
        if (this.tValue && this.tValue.constructor === Array) {
            data["tValue"] = [];
            for (let item of this.tValue)
                data["tValue"].push(item.toISOString());
        }
        return data; 
    }

    clone(): TenantPermissionGuidGetDto {
        const json = this.toJSON();
        let result = new TenantPermissionGuidGetDto();
        result.init(json);
        return result;
    }
}

export interface ITenantPermissionGuidGetDto {
    maxResultCount: number;
    skipCount: number;
    sorting: string | undefined;
    criterias: CriteriaRequestDto[] | undefined;
    tenantId: number | undefined;
    userId: number | undefined;
    id: string;
    language: string | undefined;
    option: string | undefined;
    search: string | undefined;
    status: string | undefined;
    from: moment.Moment | undefined;
    to: moment.Moment | undefined;
    sValue: string[] | undefined;
    lValue: number[] | undefined;
    gValue: string[] | undefined;
    dValue: number[] | undefined;
    tValue: moment.Moment[] | undefined;
}

export class PermissionOutputDto implements IPermissionOutputDto {
    id: string;
    tenantId: number;
    status: string | undefined;
    search: string | undefined;
    hideValue: string | undefined;
    creatorUserId: number | undefined;
    creationTime: moment.Moment;
    name: string | undefined;
    code: string | undefined;
    codeData: string | undefined;
    valueData: string | undefined;
    category: string | undefined;
    permissions: string | undefined;
    language: string | undefined;
    value1: string | undefined;
    value2: string | undefined;
    value3: string | undefined;
    value4: string | undefined;
    value5: string | undefined;
    value6: string | undefined;
    value7: string | undefined;
    value8: string | undefined;
    value9: string | undefined;
    value10: string | undefined;
    number1: number;
    number2: number;
    number3: number;
    number4: number;
    number5: number;
    number6: number;
    number7: number;
    number8: number;
    number9: number;
    number10: number;
    parentId: string | undefined;
    index: number;
    order: number;
    groupCode: string | undefined;
    hashCode: string | undefined;
    securityCode: string | undefined;
    levelCode: string | undefined;
    parentCode: string | undefined;
    parentName: string | undefined;

    constructor(data?: IPermissionOutputDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.tenantId = data["tenantId"];
            this.status = data["status"];
            this.search = data["search"];
            this.hideValue = data["hideValue"];
            this.creatorUserId = data["creatorUserId"];
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.name = data["name"];
            this.code = data["code"];
            this.codeData = data["codeData"];
            this.valueData = data["valueData"];
            this.category = data["category"];
            this.permissions = data["permissions"];
            this.language = data["language"];
            this.value1 = data["value1"];
            this.value2 = data["value2"];
            this.value3 = data["value3"];
            this.value4 = data["value4"];
            this.value5 = data["value5"];
            this.value6 = data["value6"];
            this.value7 = data["value7"];
            this.value8 = data["value8"];
            this.value9 = data["value9"];
            this.value10 = data["value10"];
            this.number1 = data["number1"];
            this.number2 = data["number2"];
            this.number3 = data["number3"];
            this.number4 = data["number4"];
            this.number5 = data["number5"];
            this.number6 = data["number6"];
            this.number7 = data["number7"];
            this.number8 = data["number8"];
            this.number9 = data["number9"];
            this.number10 = data["number10"];
            this.parentId = data["parentId"];
            this.index = data["index"];
            this.order = data["order"];
            this.groupCode = data["groupCode"];
            this.hashCode = data["hashCode"];
            this.securityCode = data["securityCode"];
            this.levelCode = data["levelCode"];
            this.parentCode = data["parentCode"];
            this.parentName = data["parentName"];
        }
    }

    static fromJS(data: any): PermissionOutputDto {
        data = typeof data === 'object' ? data : {};
        let result = new PermissionOutputDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["tenantId"] = this.tenantId;
        data["status"] = this.status;
        data["search"] = this.search;
        data["hideValue"] = this.hideValue;
        data["creatorUserId"] = this.creatorUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["name"] = this.name;
        data["code"] = this.code;
        data["codeData"] = this.codeData;
        data["valueData"] = this.valueData;
        data["category"] = this.category;
        data["permissions"] = this.permissions;
        data["language"] = this.language;
        data["value1"] = this.value1;
        data["value2"] = this.value2;
        data["value3"] = this.value3;
        data["value4"] = this.value4;
        data["value5"] = this.value5;
        data["value6"] = this.value6;
        data["value7"] = this.value7;
        data["value8"] = this.value8;
        data["value9"] = this.value9;
        data["value10"] = this.value10;
        data["number1"] = this.number1;
        data["number2"] = this.number2;
        data["number3"] = this.number3;
        data["number4"] = this.number4;
        data["number5"] = this.number5;
        data["number6"] = this.number6;
        data["number7"] = this.number7;
        data["number8"] = this.number8;
        data["number9"] = this.number9;
        data["number10"] = this.number10;
        data["parentId"] = this.parentId;
        data["index"] = this.index;
        data["order"] = this.order;
        data["groupCode"] = this.groupCode;
        data["hashCode"] = this.hashCode;
        data["securityCode"] = this.securityCode;
        data["levelCode"] = this.levelCode;
        data["parentCode"] = this.parentCode;
        data["parentName"] = this.parentName;
        return data; 
    }

    clone(): PermissionOutputDto {
        const json = this.toJSON();
        let result = new PermissionOutputDto();
        result.init(json);
        return result;
    }
}

export interface IPermissionOutputDto {
    id: string;
    tenantId: number;
    status: string | undefined;
    search: string | undefined;
    hideValue: string | undefined;
    creatorUserId: number | undefined;
    creationTime: moment.Moment;
    name: string | undefined;
    code: string | undefined;
    codeData: string | undefined;
    valueData: string | undefined;
    category: string | undefined;
    permissions: string | undefined;
    language: string | undefined;
    value1: string | undefined;
    value2: string | undefined;
    value3: string | undefined;
    value4: string | undefined;
    value5: string | undefined;
    value6: string | undefined;
    value7: string | undefined;
    value8: string | undefined;
    value9: string | undefined;
    value10: string | undefined;
    number1: number;
    number2: number;
    number3: number;
    number4: number;
    number5: number;
    number6: number;
    number7: number;
    number8: number;
    number9: number;
    number10: number;
    parentId: string | undefined;
    index: number;
    order: number;
    groupCode: string | undefined;
    hashCode: string | undefined;
    securityCode: string | undefined;
    levelCode: string | undefined;
    parentCode: string | undefined;
    parentName: string | undefined;
}

export class CheckValidTenantDto implements ICheckValidTenantDto {
    tenancyName: string;

    constructor(data?: ICheckValidTenantDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.tenancyName = data["tenancyName"];
        }
    }

    static fromJS(data: any): CheckValidTenantDto {
        data = typeof data === 'object' ? data : {};
        let result = new CheckValidTenantDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenancyName"] = this.tenancyName;
        return data; 
    }

    clone(): CheckValidTenantDto {
        const json = this.toJSON();
        let result = new CheckValidTenantDto();
        result.init(json);
        return result;
    }
}

export interface ICheckValidTenantDto {
    tenancyName: string;
}

export class RegisterTenantDto implements IRegisterTenantDto {
    tenantId: number | undefined;
    tenancyName: string;
    name: string;
    emailAddress: string;
    password: string;
    applicationId: string | undefined;
    language: string | undefined;

    constructor(data?: IRegisterTenantDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.tenantId = data["tenantId"];
            this.tenancyName = data["tenancyName"];
            this.name = data["name"];
            this.emailAddress = data["emailAddress"];
            this.password = data["password"];
            this.applicationId = data["applicationId"];
            this.language = data["language"];
        }
    }

    static fromJS(data: any): RegisterTenantDto {
        data = typeof data === 'object' ? data : {};
        let result = new RegisterTenantDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantId"] = this.tenantId;
        data["tenancyName"] = this.tenancyName;
        data["name"] = this.name;
        data["emailAddress"] = this.emailAddress;
        data["password"] = this.password;
        data["applicationId"] = this.applicationId;
        data["language"] = this.language;
        return data; 
    }

    clone(): RegisterTenantDto {
        const json = this.toJSON();
        let result = new RegisterTenantDto();
        result.init(json);
        return result;
    }
}

export interface IRegisterTenantDto {
    tenantId: number | undefined;
    tenancyName: string;
    name: string;
    emailAddress: string;
    password: string;
    applicationId: string | undefined;
    language: string | undefined;
}

export class RegisterResultDto implements IRegisterResultDto {
    id: number;
    canLogin: boolean;
    tenancyName: string | undefined;
    name: string | undefined;
    userName: string | undefined;
    emailAddress: string | undefined;

    constructor(data?: IRegisterResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.canLogin = data["canLogin"];
            this.tenancyName = data["tenancyName"];
            this.name = data["name"];
            this.userName = data["userName"];
            this.emailAddress = data["emailAddress"];
        }
    }

    static fromJS(data: any): RegisterResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new RegisterResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["canLogin"] = this.canLogin;
        data["tenancyName"] = this.tenancyName;
        data["name"] = this.name;
        data["userName"] = this.userName;
        data["emailAddress"] = this.emailAddress;
        return data; 
    }

    clone(): RegisterResultDto {
        const json = this.toJSON();
        let result = new RegisterResultDto();
        result.init(json);
        return result;
    }
}

export interface IRegisterResultDto {
    id: number;
    canLogin: boolean;
    tenancyName: string | undefined;
    name: string | undefined;
    userName: string | undefined;
    emailAddress: string | undefined;
}

export class RegisterUserDto implements IRegisterUserDto {
    id: number;
    tenantId: number | undefined;
    userName: string;
    name: string;
    surname: string;
    password: string;
    isEmailConfirmed: boolean;
    profiles: string | undefined;
    contacts: string | undefined;
    emailAddress: string | undefined;
    language: string | undefined;

    constructor(data?: IRegisterUserDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.tenantId = data["tenantId"];
            this.userName = data["userName"];
            this.name = data["name"];
            this.surname = data["surname"];
            this.password = data["password"];
            this.isEmailConfirmed = data["isEmailConfirmed"];
            this.profiles = data["profiles"];
            this.contacts = data["contacts"];
            this.emailAddress = data["emailAddress"];
            this.language = data["language"];
        }
    }

    static fromJS(data: any): RegisterUserDto {
        data = typeof data === 'object' ? data : {};
        let result = new RegisterUserDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["tenantId"] = this.tenantId;
        data["userName"] = this.userName;
        data["name"] = this.name;
        data["surname"] = this.surname;
        data["password"] = this.password;
        data["isEmailConfirmed"] = this.isEmailConfirmed;
        data["profiles"] = this.profiles;
        data["contacts"] = this.contacts;
        data["emailAddress"] = this.emailAddress;
        data["language"] = this.language;
        return data; 
    }

    clone(): RegisterUserDto {
        const json = this.toJSON();
        let result = new RegisterUserDto();
        result.init(json);
        return result;
    }
}

export interface IRegisterUserDto {
    id: number;
    tenantId: number | undefined;
    userName: string;
    name: string;
    surname: string;
    password: string;
    isEmailConfirmed: boolean;
    profiles: string | undefined;
    contacts: string | undefined;
    emailAddress: string | undefined;
    language: string | undefined;
}

export class TitleGuidGetDto implements ITitleGuidGetDto {
    maxResultCount: number;
    skipCount: number;
    sorting: string | undefined;
    criterias: CriteriaRequestDto[] | undefined;
    tenantId: number | undefined;
    userId: number | undefined;
    id: string;
    language: string | undefined;
    option: string | undefined;
    search: string | undefined;
    status: string | undefined;
    from: moment.Moment | undefined;
    to: moment.Moment | undefined;
    sValue: string[] | undefined;
    lValue: number[] | undefined;
    gValue: string[] | undefined;
    dValue: number[] | undefined;
    tValue: moment.Moment[] | undefined;

    constructor(data?: ITitleGuidGetDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.maxResultCount = data["maxResultCount"];
            this.skipCount = data["skipCount"];
            this.sorting = data["sorting"];
            if (data["criterias"] && data["criterias"].constructor === Array) {
                this.criterias = [] as any;
                for (let item of data["criterias"])
                    this.criterias.push(CriteriaRequestDto.fromJS(item));
            }
            this.tenantId = data["tenantId"];
            this.userId = data["userId"];
            this.id = data["id"];
            this.language = data["language"];
            this.option = data["option"];
            this.search = data["search"];
            this.status = data["status"];
            this.from = data["from"] ? moment(data["from"].toString()) : <any>undefined;
            this.to = data["to"] ? moment(data["to"].toString()) : <any>undefined;
            if (data["sValue"] && data["sValue"].constructor === Array) {
                this.sValue = [] as any;
                for (let item of data["sValue"])
                    this.sValue.push(item);
            }
            if (data["lValue"] && data["lValue"].constructor === Array) {
                this.lValue = [] as any;
                for (let item of data["lValue"])
                    this.lValue.push(item);
            }
            if (data["gValue"] && data["gValue"].constructor === Array) {
                this.gValue = [] as any;
                for (let item of data["gValue"])
                    this.gValue.push(item);
            }
            if (data["dValue"] && data["dValue"].constructor === Array) {
                this.dValue = [] as any;
                for (let item of data["dValue"])
                    this.dValue.push(item);
            }
            if (data["tValue"] && data["tValue"].constructor === Array) {
                this.tValue = [] as any;
                for (let item of data["tValue"])
                    this.tValue.push(moment(item));
            }
        }
    }

    static fromJS(data: any): TitleGuidGetDto {
        data = typeof data === 'object' ? data : {};
        let result = new TitleGuidGetDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["maxResultCount"] = this.maxResultCount;
        data["skipCount"] = this.skipCount;
        data["sorting"] = this.sorting;
        if (this.criterias && this.criterias.constructor === Array) {
            data["criterias"] = [];
            for (let item of this.criterias)
                data["criterias"].push(item.toJSON());
        }
        data["tenantId"] = this.tenantId;
        data["userId"] = this.userId;
        data["id"] = this.id;
        data["language"] = this.language;
        data["option"] = this.option;
        data["search"] = this.search;
        data["status"] = this.status;
        data["from"] = this.from ? this.from.toISOString() : <any>undefined;
        data["to"] = this.to ? this.to.toISOString() : <any>undefined;
        if (this.sValue && this.sValue.constructor === Array) {
            data["sValue"] = [];
            for (let item of this.sValue)
                data["sValue"].push(item);
        }
        if (this.lValue && this.lValue.constructor === Array) {
            data["lValue"] = [];
            for (let item of this.lValue)
                data["lValue"].push(item);
        }
        if (this.gValue && this.gValue.constructor === Array) {
            data["gValue"] = [];
            for (let item of this.gValue)
                data["gValue"].push(item);
        }
        if (this.dValue && this.dValue.constructor === Array) {
            data["dValue"] = [];
            for (let item of this.dValue)
                data["dValue"].push(item);
        }
        if (this.tValue && this.tValue.constructor === Array) {
            data["tValue"] = [];
            for (let item of this.tValue)
                data["tValue"].push(item.toISOString());
        }
        return data; 
    }

    clone(): TitleGuidGetDto {
        const json = this.toJSON();
        let result = new TitleGuidGetDto();
        result.init(json);
        return result;
    }
}

export interface ITitleGuidGetDto {
    maxResultCount: number;
    skipCount: number;
    sorting: string | undefined;
    criterias: CriteriaRequestDto[] | undefined;
    tenantId: number | undefined;
    userId: number | undefined;
    id: string;
    language: string | undefined;
    option: string | undefined;
    search: string | undefined;
    status: string | undefined;
    from: moment.Moment | undefined;
    to: moment.Moment | undefined;
    sValue: string[] | undefined;
    lValue: number[] | undefined;
    gValue: string[] | undefined;
    dValue: number[] | undefined;
    tValue: moment.Moment[] | undefined;
}

export class TitleOutputDto implements ITitleOutputDto {
    id: string;
    tenantId: number;
    status: string | undefined;
    search: string | undefined;
    hideValue: string | undefined;
    creatorUserId: number | undefined;
    creationTime: moment.Moment;
    name: string | undefined;
    code: string | undefined;
    codeData: string | undefined;
    valueData: string | undefined;
    category: string | undefined;
    permissions: string | undefined;
    language: string | undefined;
    value1: string | undefined;
    value2: string | undefined;
    value3: string | undefined;
    value4: string | undefined;
    value5: string | undefined;
    value6: string | undefined;
    value7: string | undefined;
    value8: string | undefined;
    value9: string | undefined;
    value10: string | undefined;
    number1: number;
    number2: number;
    number3: number;
    number4: number;
    number5: number;
    number6: number;
    number7: number;
    number8: number;
    number9: number;
    number10: number;
    parentId: string | undefined;
    index: number;
    order: number;
    groupCode: string | undefined;
    hashCode: string | undefined;
    securityCode: string | undefined;
    listPermission: ValuePermissionDto[] | undefined;
    parentCode: string | undefined;
    parentName: string | undefined;

    constructor(data?: ITitleOutputDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.tenantId = data["tenantId"];
            this.status = data["status"];
            this.search = data["search"];
            this.hideValue = data["hideValue"];
            this.creatorUserId = data["creatorUserId"];
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.name = data["name"];
            this.code = data["code"];
            this.codeData = data["codeData"];
            this.valueData = data["valueData"];
            this.category = data["category"];
            this.permissions = data["permissions"];
            this.language = data["language"];
            this.value1 = data["value1"];
            this.value2 = data["value2"];
            this.value3 = data["value3"];
            this.value4 = data["value4"];
            this.value5 = data["value5"];
            this.value6 = data["value6"];
            this.value7 = data["value7"];
            this.value8 = data["value8"];
            this.value9 = data["value9"];
            this.value10 = data["value10"];
            this.number1 = data["number1"];
            this.number2 = data["number2"];
            this.number3 = data["number3"];
            this.number4 = data["number4"];
            this.number5 = data["number5"];
            this.number6 = data["number6"];
            this.number7 = data["number7"];
            this.number8 = data["number8"];
            this.number9 = data["number9"];
            this.number10 = data["number10"];
            this.parentId = data["parentId"];
            this.index = data["index"];
            this.order = data["order"];
            this.groupCode = data["groupCode"];
            this.hashCode = data["hashCode"];
            this.securityCode = data["securityCode"];
            if (data["listPermission"] && data["listPermission"].constructor === Array) {
                this.listPermission = [] as any;
                for (let item of data["listPermission"])
                    this.listPermission.push(ValuePermissionDto.fromJS(item));
            }
            this.parentCode = data["parentCode"];
            this.parentName = data["parentName"];
        }
    }

    static fromJS(data: any): TitleOutputDto {
        data = typeof data === 'object' ? data : {};
        let result = new TitleOutputDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["tenantId"] = this.tenantId;
        data["status"] = this.status;
        data["search"] = this.search;
        data["hideValue"] = this.hideValue;
        data["creatorUserId"] = this.creatorUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["name"] = this.name;
        data["code"] = this.code;
        data["codeData"] = this.codeData;
        data["valueData"] = this.valueData;
        data["category"] = this.category;
        data["permissions"] = this.permissions;
        data["language"] = this.language;
        data["value1"] = this.value1;
        data["value2"] = this.value2;
        data["value3"] = this.value3;
        data["value4"] = this.value4;
        data["value5"] = this.value5;
        data["value6"] = this.value6;
        data["value7"] = this.value7;
        data["value8"] = this.value8;
        data["value9"] = this.value9;
        data["value10"] = this.value10;
        data["number1"] = this.number1;
        data["number2"] = this.number2;
        data["number3"] = this.number3;
        data["number4"] = this.number4;
        data["number5"] = this.number5;
        data["number6"] = this.number6;
        data["number7"] = this.number7;
        data["number8"] = this.number8;
        data["number9"] = this.number9;
        data["number10"] = this.number10;
        data["parentId"] = this.parentId;
        data["index"] = this.index;
        data["order"] = this.order;
        data["groupCode"] = this.groupCode;
        data["hashCode"] = this.hashCode;
        data["securityCode"] = this.securityCode;
        if (this.listPermission && this.listPermission.constructor === Array) {
            data["listPermission"] = [];
            for (let item of this.listPermission)
                data["listPermission"].push(item.toJSON());
        }
        data["parentCode"] = this.parentCode;
        data["parentName"] = this.parentName;
        return data; 
    }

    clone(): TitleOutputDto {
        const json = this.toJSON();
        let result = new TitleOutputDto();
        result.init(json);
        return result;
    }
}

export interface ITitleOutputDto {
    id: string;
    tenantId: number;
    status: string | undefined;
    search: string | undefined;
    hideValue: string | undefined;
    creatorUserId: number | undefined;
    creationTime: moment.Moment;
    name: string | undefined;
    code: string | undefined;
    codeData: string | undefined;
    valueData: string | undefined;
    category: string | undefined;
    permissions: string | undefined;
    language: string | undefined;
    value1: string | undefined;
    value2: string | undefined;
    value3: string | undefined;
    value4: string | undefined;
    value5: string | undefined;
    value6: string | undefined;
    value7: string | undefined;
    value8: string | undefined;
    value9: string | undefined;
    value10: string | undefined;
    number1: number;
    number2: number;
    number3: number;
    number4: number;
    number5: number;
    number6: number;
    number7: number;
    number8: number;
    number9: number;
    number10: number;
    parentId: string | undefined;
    index: number;
    order: number;
    groupCode: string | undefined;
    hashCode: string | undefined;
    securityCode: string | undefined;
    listPermission: ValuePermissionDto[] | undefined;
    parentCode: string | undefined;
    parentName: string | undefined;
}

export class TitleInputDto implements ITitleInputDto {
    id: string;
    tenantId: number;
    status: string | undefined;
    search: string | undefined;
    hideValue: string | undefined;
    creatorUserId: number | undefined;
    creationTime: moment.Moment;
    name: string | undefined;
    code: string | undefined;
    codeData: string | undefined;
    valueData: string | undefined;
    category: string | undefined;
    permissions: string | undefined;
    language: string | undefined;
    value1: string | undefined;
    value2: string | undefined;
    value3: string | undefined;
    value4: string | undefined;
    value5: string | undefined;
    value6: string | undefined;
    value7: string | undefined;
    value8: string | undefined;
    value9: string | undefined;
    value10: string | undefined;
    number1: number;
    number2: number;
    number3: number;
    number4: number;
    number5: number;
    number6: number;
    number7: number;
    number8: number;
    number9: number;
    number10: number;
    parentId: string | undefined;
    index: number;
    order: number;
    groupCode: string | undefined;
    hashCode: string | undefined;
    securityCode: string | undefined;
    listPermission: ValuePermissionDto[] | undefined;

    constructor(data?: ITitleInputDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.tenantId = data["tenantId"];
            this.status = data["status"];
            this.search = data["search"];
            this.hideValue = data["hideValue"];
            this.creatorUserId = data["creatorUserId"];
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.name = data["name"];
            this.code = data["code"];
            this.codeData = data["codeData"];
            this.valueData = data["valueData"];
            this.category = data["category"];
            this.permissions = data["permissions"];
            this.language = data["language"];
            this.value1 = data["value1"];
            this.value2 = data["value2"];
            this.value3 = data["value3"];
            this.value4 = data["value4"];
            this.value5 = data["value5"];
            this.value6 = data["value6"];
            this.value7 = data["value7"];
            this.value8 = data["value8"];
            this.value9 = data["value9"];
            this.value10 = data["value10"];
            this.number1 = data["number1"];
            this.number2 = data["number2"];
            this.number3 = data["number3"];
            this.number4 = data["number4"];
            this.number5 = data["number5"];
            this.number6 = data["number6"];
            this.number7 = data["number7"];
            this.number8 = data["number8"];
            this.number9 = data["number9"];
            this.number10 = data["number10"];
            this.parentId = data["parentId"];
            this.index = data["index"];
            this.order = data["order"];
            this.groupCode = data["groupCode"];
            this.hashCode = data["hashCode"];
            this.securityCode = data["securityCode"];
            if (data["listPermission"] && data["listPermission"].constructor === Array) {
                this.listPermission = [] as any;
                for (let item of data["listPermission"])
                    this.listPermission.push(ValuePermissionDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): TitleInputDto {
        data = typeof data === 'object' ? data : {};
        let result = new TitleInputDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["tenantId"] = this.tenantId;
        data["status"] = this.status;
        data["search"] = this.search;
        data["hideValue"] = this.hideValue;
        data["creatorUserId"] = this.creatorUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["name"] = this.name;
        data["code"] = this.code;
        data["codeData"] = this.codeData;
        data["valueData"] = this.valueData;
        data["category"] = this.category;
        data["permissions"] = this.permissions;
        data["language"] = this.language;
        data["value1"] = this.value1;
        data["value2"] = this.value2;
        data["value3"] = this.value3;
        data["value4"] = this.value4;
        data["value5"] = this.value5;
        data["value6"] = this.value6;
        data["value7"] = this.value7;
        data["value8"] = this.value8;
        data["value9"] = this.value9;
        data["value10"] = this.value10;
        data["number1"] = this.number1;
        data["number2"] = this.number2;
        data["number3"] = this.number3;
        data["number4"] = this.number4;
        data["number5"] = this.number5;
        data["number6"] = this.number6;
        data["number7"] = this.number7;
        data["number8"] = this.number8;
        data["number9"] = this.number9;
        data["number10"] = this.number10;
        data["parentId"] = this.parentId;
        data["index"] = this.index;
        data["order"] = this.order;
        data["groupCode"] = this.groupCode;
        data["hashCode"] = this.hashCode;
        data["securityCode"] = this.securityCode;
        if (this.listPermission && this.listPermission.constructor === Array) {
            data["listPermission"] = [];
            for (let item of this.listPermission)
                data["listPermission"].push(item.toJSON());
        }
        return data; 
    }

    clone(): TitleInputDto {
        const json = this.toJSON();
        let result = new TitleInputDto();
        result.init(json);
        return result;
    }
}

export interface ITitleInputDto {
    id: string;
    tenantId: number;
    status: string | undefined;
    search: string | undefined;
    hideValue: string | undefined;
    creatorUserId: number | undefined;
    creationTime: moment.Moment;
    name: string | undefined;
    code: string | undefined;
    codeData: string | undefined;
    valueData: string | undefined;
    category: string | undefined;
    permissions: string | undefined;
    language: string | undefined;
    value1: string | undefined;
    value2: string | undefined;
    value3: string | undefined;
    value4: string | undefined;
    value5: string | undefined;
    value6: string | undefined;
    value7: string | undefined;
    value8: string | undefined;
    value9: string | undefined;
    value10: string | undefined;
    number1: number;
    number2: number;
    number3: number;
    number4: number;
    number5: number;
    number6: number;
    number7: number;
    number8: number;
    number9: number;
    number10: number;
    parentId: string | undefined;
    index: number;
    order: number;
    groupCode: string | undefined;
    hashCode: string | undefined;
    securityCode: string | undefined;
    listPermission: ValuePermissionDto[] | undefined;
}

export class TitlePermissionDto implements ITitlePermissionDto {
    id: string;
    listPermission: ValuePermissionDto[] | undefined;

    constructor(data?: ITitlePermissionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            if (data["listPermission"] && data["listPermission"].constructor === Array) {
                this.listPermission = [] as any;
                for (let item of data["listPermission"])
                    this.listPermission.push(ValuePermissionDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): TitlePermissionDto {
        data = typeof data === 'object' ? data : {};
        let result = new TitlePermissionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        if (this.listPermission && this.listPermission.constructor === Array) {
            data["listPermission"] = [];
            for (let item of this.listPermission)
                data["listPermission"].push(item.toJSON());
        }
        return data; 
    }

    clone(): TitlePermissionDto {
        const json = this.toJSON();
        let result = new TitlePermissionDto();
        result.init(json);
        return result;
    }
}

export interface ITitlePermissionDto {
    id: string;
    listPermission: ValuePermissionDto[] | undefined;
}

export class AuthenticateModel implements IAuthenticateModel {
    userNameOrEmailAddress: string;
    password: string;
    rememberClient: boolean;
    otp: number;
    tenantName: string | undefined;
    expriteMinutes: number;
    defaultTenant: boolean;

    constructor(data?: IAuthenticateModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.userNameOrEmailAddress = data["userNameOrEmailAddress"];
            this.password = data["password"];
            this.rememberClient = data["rememberClient"];
            this.otp = data["otp"];
            this.tenantName = data["tenantName"];
            this.expriteMinutes = data["expriteMinutes"];
            this.defaultTenant = data["defaultTenant"];
        }
    }

    static fromJS(data: any): AuthenticateModel {
        data = typeof data === 'object' ? data : {};
        let result = new AuthenticateModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userNameOrEmailAddress"] = this.userNameOrEmailAddress;
        data["password"] = this.password;
        data["rememberClient"] = this.rememberClient;
        data["otp"] = this.otp;
        data["tenantName"] = this.tenantName;
        data["expriteMinutes"] = this.expriteMinutes;
        data["defaultTenant"] = this.defaultTenant;
        return data; 
    }

    clone(): AuthenticateModel {
        const json = this.toJSON();
        let result = new AuthenticateModel();
        result.init(json);
        return result;
    }
}

export interface IAuthenticateModel {
    userNameOrEmailAddress: string;
    password: string;
    rememberClient: boolean;
    otp: number;
    tenantName: string | undefined;
    expriteMinutes: number;
    defaultTenant: boolean;
}

export class AuthenticateResultModel implements IAuthenticateResultModel {
    accessToken: string | undefined;
    encryptedAccessToken: string | undefined;
    expireInSeconds: number;
    userId: number;
    tenantId: number | undefined;

    constructor(data?: IAuthenticateResultModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.accessToken = data["accessToken"];
            this.encryptedAccessToken = data["encryptedAccessToken"];
            this.expireInSeconds = data["expireInSeconds"];
            this.userId = data["userId"];
            this.tenantId = data["tenantId"];
        }
    }

    static fromJS(data: any): AuthenticateResultModel {
        data = typeof data === 'object' ? data : {};
        let result = new AuthenticateResultModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["accessToken"] = this.accessToken;
        data["encryptedAccessToken"] = this.encryptedAccessToken;
        data["expireInSeconds"] = this.expireInSeconds;
        data["userId"] = this.userId;
        data["tenantId"] = this.tenantId;
        return data; 
    }

    clone(): AuthenticateResultModel {
        const json = this.toJSON();
        let result = new AuthenticateResultModel();
        result.init(json);
        return result;
    }
}

export interface IAuthenticateResultModel {
    accessToken: string | undefined;
    encryptedAccessToken: string | undefined;
    expireInSeconds: number;
    userId: number;
    tenantId: number | undefined;
}

export class OTPModel implements IOTPModel {
    userNameOrEmailAddress: string;
    type: string | undefined;

    constructor(data?: IOTPModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.userNameOrEmailAddress = data["userNameOrEmailAddress"];
            this.type = data["type"];
        }
    }

    static fromJS(data: any): OTPModel {
        data = typeof data === 'object' ? data : {};
        let result = new OTPModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userNameOrEmailAddress"] = this.userNameOrEmailAddress;
        data["type"] = this.type;
        return data; 
    }

    clone(): OTPModel {
        const json = this.toJSON();
        let result = new OTPModel();
        result.init(json);
        return result;
    }
}

export interface IOTPModel {
    userNameOrEmailAddress: string;
    type: string | undefined;
}

export class UserDto implements IUserDto {
    id: number;
    userName: string | undefined;
    name: string | undefined;
    surname: string | undefined;
    emailAddress: string | undefined;
    fullName: string | undefined;
    isActive: boolean;
    isEmailConfirmed: boolean;
    profiles: string | undefined;
    contacts: string | undefined;

    constructor(data?: IUserDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.userName = data["userName"];
            this.name = data["name"];
            this.surname = data["surname"];
            this.emailAddress = data["emailAddress"];
            this.fullName = data["fullName"];
            this.isActive = data["isActive"];
            this.isEmailConfirmed = data["isEmailConfirmed"];
            this.profiles = data["profiles"];
            this.contacts = data["contacts"];
        }
    }

    static fromJS(data: any): UserDto {
        data = typeof data === 'object' ? data : {};
        let result = new UserDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["userName"] = this.userName;
        data["name"] = this.name;
        data["surname"] = this.surname;
        data["emailAddress"] = this.emailAddress;
        data["fullName"] = this.fullName;
        data["isActive"] = this.isActive;
        data["isEmailConfirmed"] = this.isEmailConfirmed;
        data["profiles"] = this.profiles;
        data["contacts"] = this.contacts;
        return data; 
    }

    clone(): UserDto {
        const json = this.toJSON();
        let result = new UserDto();
        result.init(json);
        return result;
    }
}

export interface IUserDto {
    id: number;
    userName: string | undefined;
    name: string | undefined;
    surname: string | undefined;
    emailAddress: string | undefined;
    fullName: string | undefined;
    isActive: boolean;
    isEmailConfirmed: boolean;
    profiles: string | undefined;
    contacts: string | undefined;
}

export class UserInt64GetDto implements IUserInt64GetDto {
    maxResultCount: number;
    skipCount: number;
    sorting: string | undefined;
    criterias: CriteriaRequestDto[] | undefined;
    tenantId: number | undefined;
    userId: number | undefined;
    id: number;
    language: string | undefined;
    option: string | undefined;
    search: string | undefined;
    status: string | undefined;
    from: moment.Moment | undefined;
    to: moment.Moment | undefined;
    sValue: string[] | undefined;
    lValue: number[] | undefined;
    gValue: string[] | undefined;
    dValue: number[] | undefined;
    tValue: moment.Moment[] | undefined;

    constructor(data?: IUserInt64GetDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.maxResultCount = data["maxResultCount"];
            this.skipCount = data["skipCount"];
            this.sorting = data["sorting"];
            if (data["criterias"] && data["criterias"].constructor === Array) {
                this.criterias = [] as any;
                for (let item of data["criterias"])
                    this.criterias.push(CriteriaRequestDto.fromJS(item));
            }
            this.tenantId = data["tenantId"];
            this.userId = data["userId"];
            this.id = data["id"];
            this.language = data["language"];
            this.option = data["option"];
            this.search = data["search"];
            this.status = data["status"];
            this.from = data["from"] ? moment(data["from"].toString()) : <any>undefined;
            this.to = data["to"] ? moment(data["to"].toString()) : <any>undefined;
            if (data["sValue"] && data["sValue"].constructor === Array) {
                this.sValue = [] as any;
                for (let item of data["sValue"])
                    this.sValue.push(item);
            }
            if (data["lValue"] && data["lValue"].constructor === Array) {
                this.lValue = [] as any;
                for (let item of data["lValue"])
                    this.lValue.push(item);
            }
            if (data["gValue"] && data["gValue"].constructor === Array) {
                this.gValue = [] as any;
                for (let item of data["gValue"])
                    this.gValue.push(item);
            }
            if (data["dValue"] && data["dValue"].constructor === Array) {
                this.dValue = [] as any;
                for (let item of data["dValue"])
                    this.dValue.push(item);
            }
            if (data["tValue"] && data["tValue"].constructor === Array) {
                this.tValue = [] as any;
                for (let item of data["tValue"])
                    this.tValue.push(moment(item));
            }
        }
    }

    static fromJS(data: any): UserInt64GetDto {
        data = typeof data === 'object' ? data : {};
        let result = new UserInt64GetDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["maxResultCount"] = this.maxResultCount;
        data["skipCount"] = this.skipCount;
        data["sorting"] = this.sorting;
        if (this.criterias && this.criterias.constructor === Array) {
            data["criterias"] = [];
            for (let item of this.criterias)
                data["criterias"].push(item.toJSON());
        }
        data["tenantId"] = this.tenantId;
        data["userId"] = this.userId;
        data["id"] = this.id;
        data["language"] = this.language;
        data["option"] = this.option;
        data["search"] = this.search;
        data["status"] = this.status;
        data["from"] = this.from ? this.from.toISOString() : <any>undefined;
        data["to"] = this.to ? this.to.toISOString() : <any>undefined;
        if (this.sValue && this.sValue.constructor === Array) {
            data["sValue"] = [];
            for (let item of this.sValue)
                data["sValue"].push(item);
        }
        if (this.lValue && this.lValue.constructor === Array) {
            data["lValue"] = [];
            for (let item of this.lValue)
                data["lValue"].push(item);
        }
        if (this.gValue && this.gValue.constructor === Array) {
            data["gValue"] = [];
            for (let item of this.gValue)
                data["gValue"].push(item);
        }
        if (this.dValue && this.dValue.constructor === Array) {
            data["dValue"] = [];
            for (let item of this.dValue)
                data["dValue"].push(item);
        }
        if (this.tValue && this.tValue.constructor === Array) {
            data["tValue"] = [];
            for (let item of this.tValue)
                data["tValue"].push(item.toISOString());
        }
        return data; 
    }

    clone(): UserInt64GetDto {
        const json = this.toJSON();
        let result = new UserInt64GetDto();
        result.init(json);
        return result;
    }
}

export interface IUserInt64GetDto {
    maxResultCount: number;
    skipCount: number;
    sorting: string | undefined;
    criterias: CriteriaRequestDto[] | undefined;
    tenantId: number | undefined;
    userId: number | undefined;
    id: number;
    language: string | undefined;
    option: string | undefined;
    search: string | undefined;
    status: string | undefined;
    from: moment.Moment | undefined;
    to: moment.Moment | undefined;
    sValue: string[] | undefined;
    lValue: number[] | undefined;
    gValue: string[] | undefined;
    dValue: number[] | undefined;
    tValue: moment.Moment[] | undefined;
}

export class UserOutputDtoPagedResultDto implements IUserOutputDtoPagedResultDto {
    items: UserOutputDto[] | undefined;
    totalCount: number;

    constructor(data?: IUserOutputDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items.push(UserOutputDto.fromJS(item));
            }
            this.totalCount = data["totalCount"];
        }
    }

    static fromJS(data: any): UserOutputDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new UserOutputDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data; 
    }

    clone(): UserOutputDtoPagedResultDto {
        const json = this.toJSON();
        let result = new UserOutputDtoPagedResultDto();
        result.init(json);
        return result;
    }
}

export interface IUserOutputDtoPagedResultDto {
    items: UserOutputDto[] | undefined;
    totalCount: number;
}

export class ChangePasswordDto implements IChangePasswordDto {
    id: number;
    oldPass: string | undefined;
    newPass: string | undefined;

    constructor(data?: IChangePasswordDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.oldPass = data["oldPass"];
            this.newPass = data["newPass"];
        }
    }

    static fromJS(data: any): ChangePasswordDto {
        data = typeof data === 'object' ? data : {};
        let result = new ChangePasswordDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["oldPass"] = this.oldPass;
        data["newPass"] = this.newPass;
        return data; 
    }

    clone(): ChangePasswordDto {
        const json = this.toJSON();
        let result = new ChangePasswordDto();
        result.init(json);
        return result;
    }
}

export interface IChangePasswordDto {
    id: number;
    oldPass: string | undefined;
    newPass: string | undefined;
}

export class UserInputDto implements IUserInputDto {
    id: number;
    userName: string | undefined;
    name: string | undefined;
    surname: string | undefined;
    emailAddress: string | undefined;
    fullName: string | undefined;
    profiles: string | undefined;
    contacts: string | undefined;
    isActive: boolean;

    constructor(data?: IUserInputDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.userName = data["userName"];
            this.name = data["name"];
            this.surname = data["surname"];
            this.emailAddress = data["emailAddress"];
            this.fullName = data["fullName"];
            this.profiles = data["profiles"];
            this.contacts = data["contacts"];
            this.isActive = data["isActive"];
        }
    }

    static fromJS(data: any): UserInputDto {
        data = typeof data === 'object' ? data : {};
        let result = new UserInputDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["userName"] = this.userName;
        data["name"] = this.name;
        data["surname"] = this.surname;
        data["emailAddress"] = this.emailAddress;
        data["fullName"] = this.fullName;
        data["profiles"] = this.profiles;
        data["contacts"] = this.contacts;
        data["isActive"] = this.isActive;
        return data; 
    }

    clone(): UserInputDto {
        const json = this.toJSON();
        let result = new UserInputDto();
        result.init(json);
        return result;
    }
}

export interface IUserInputDto {
    id: number;
    userName: string | undefined;
    name: string | undefined;
    surname: string | undefined;
    emailAddress: string | undefined;
    fullName: string | undefined;
    profiles: string | undefined;
    contacts: string | undefined;
    isActive: boolean;
}

export class Int64EntityDto implements IInt64EntityDto {
    id: number;

    constructor(data?: IInt64EntityDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
        }
    }

    static fromJS(data: any): Int64EntityDto {
        data = typeof data === 'object' ? data : {};
        let result = new Int64EntityDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        return data; 
    }

    clone(): Int64EntityDto {
        const json = this.toJSON();
        let result = new Int64EntityDto();
        result.init(json);
        return result;
    }
}

export interface IInt64EntityDto {
    id: number;
}

export class SwaggerException extends Error {
    message: string;
    status: number; 
    response: string; 
    headers: { [key: string]: any; };
    result: any; 

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isSwaggerException = true;

    static isSwaggerException(obj: any): obj is SwaggerException {
        return obj.isSwaggerException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): Observable<any> {
    if(result !== null && result !== undefined)
        return _observableThrow(result);
    else
        return _observableThrow(new SwaggerException(message, status, response, headers, null));
}

function blobToText(blob: any): Observable<string> {
    return new Observable<string>((observer: any) => {
        if (!blob) {
            observer.next("");
            observer.complete();
        } else {
            let reader = new FileReader(); 
            reader.onload = event => { 
                observer.next((<any>event.target).result);
                observer.complete();
            };
            reader.readAsText(blob); 
        }
    });
}