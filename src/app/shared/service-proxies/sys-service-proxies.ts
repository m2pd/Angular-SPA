/* tslint:disable */
/* eslint-disable */
//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v12.3.1.0 (NJsonSchema v9.14.1.0 (Newtonsoft.Json v11.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------
// ReSharper disable InconsistentNaming

import { mergeMap as _observableMergeMap, catchError as _observableCatch } from 'rxjs/operators';
import { Observable, throwError as _observableThrow, of as _observableOf } from 'rxjs';
import { Injectable, Inject, Optional, InjectionToken } from '@angular/core';
import { HttpClient, HttpHeaders, HttpResponse, HttpResponseBase } from '@angular/common/http';

import * as moment from 'moment';

export const SYS_API_BASE_URL = new InjectionToken<string>('SYS_API_BASE_URL');

@Injectable()
export class SysCategoryServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(SYS_API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    getList(body: CategoryGuidGetDto | undefined): Observable<CategoryOutputDto[]> {
        let url_ = this.baseUrl + "/api/services/DATA/read/Category/GetList";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json", 
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetList(<any>response_);
                } catch (e) {
                    return <Observable<CategoryOutputDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<CategoryOutputDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetList(response: HttpResponseBase): Observable<CategoryOutputDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(CategoryOutputDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CategoryOutputDto[]>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    get(body: GuidEntityDto | undefined): Observable<CategoryOutputDto> {
        let url_ = this.baseUrl + "/api/services/DATA/read/Category/Get";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json", 
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(<any>response_);
                } catch (e) {
                    return <Observable<CategoryOutputDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<CategoryOutputDto>><any>_observableThrow(response_);
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<CategoryOutputDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CategoryOutputDto.fromJS(resultData200) : new CategoryOutputDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CategoryOutputDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    create(body: CategoryInputDto | undefined): Observable<CategoryOutputDto> {
        let url_ = this.baseUrl + "/api/services/DATA/write/Category/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json", 
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(<any>response_);
                } catch (e) {
                    return <Observable<CategoryOutputDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<CategoryOutputDto>><any>_observableThrow(response_);
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<CategoryOutputDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CategoryOutputDto.fromJS(resultData200) : new CategoryOutputDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CategoryOutputDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    update(body: CategoryInputDto | undefined): Observable<CategoryOutputDto> {
        let url_ = this.baseUrl + "/api/services/DATA/write/Category/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json", 
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(<any>response_);
                } catch (e) {
                    return <Observable<CategoryOutputDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<CategoryOutputDto>><any>_observableThrow(response_);
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<CategoryOutputDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CategoryOutputDto.fromJS(resultData200) : new CategoryOutputDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CategoryOutputDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    delete(body: GuidEntityDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/DATA/write/Category/Delete";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class SysCategoryClientServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(SYS_API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    getList(body: CategoryGuidGetDto | undefined): Observable<CategoryOutputDto[]> {
        let url_ = this.baseUrl + "/api/services/DATA/read/CategoryClient/GetList";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json", 
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetList(<any>response_);
                } catch (e) {
                    return <Observable<CategoryOutputDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<CategoryOutputDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetList(response: HttpResponseBase): Observable<CategoryOutputDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(CategoryOutputDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CategoryOutputDto[]>(<any>null);
    }
}

@Injectable()
export class SysFieldServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(SYS_API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    getAll(body: FieldGuidGetDto | undefined): Observable<FieldOutputDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/SYS/read/Field/GetAll";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json", 
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<FieldOutputDtoPagedResultDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<FieldOutputDtoPagedResultDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<FieldOutputDtoPagedResultDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? FieldOutputDtoPagedResultDto.fromJS(resultData200) : new FieldOutputDtoPagedResultDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FieldOutputDtoPagedResultDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    getList(body: FieldGuidGetDto | undefined): Observable<FieldOutputDto[]> {
        let url_ = this.baseUrl + "/api/services/SYS/read/Field/GetList";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json", 
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetList(<any>response_);
                } catch (e) {
                    return <Observable<FieldOutputDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<FieldOutputDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetList(response: HttpResponseBase): Observable<FieldOutputDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(FieldOutputDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FieldOutputDto[]>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    create(body: FieldInputDto | undefined): Observable<FieldOutputDto> {
        let url_ = this.baseUrl + "/api/services/SYS/write/Field/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json", 
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(<any>response_);
                } catch (e) {
                    return <Observable<FieldOutputDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<FieldOutputDto>><any>_observableThrow(response_);
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<FieldOutputDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? FieldOutputDto.fromJS(resultData200) : new FieldOutputDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FieldOutputDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    update(body: FieldInputDto | undefined): Observable<FieldOutputDto> {
        let url_ = this.baseUrl + "/api/services/SYS/write/Field/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json", 
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(<any>response_);
                } catch (e) {
                    return <Observable<FieldOutputDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<FieldOutputDto>><any>_observableThrow(response_);
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<FieldOutputDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? FieldOutputDto.fromJS(resultData200) : new FieldOutputDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FieldOutputDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    delete(body: GuidEntityDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/SYS/write/Field/Delete";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class SysFileClientServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(SYS_API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    getFile(body: StringEntityDto | undefined): Observable<FileEntity> {
        let url_ = this.baseUrl + "/api/services/DATA/read/FileClient/GetFile";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json", 
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetFile(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetFile(<any>response_);
                } catch (e) {
                    return <Observable<FileEntity>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileEntity>><any>_observableThrow(response_);
        }));
    }

    protected processGetFile(response: HttpResponseBase): Observable<FileEntity> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? FileEntity.fromJS(resultData200) : new FileEntity();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileEntity>(<any>null);
    }
}

@Injectable()
export class SysFormServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(SYS_API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    getList(body: FormGuidGetDto | undefined): Observable<FormOutputDto[]> {
        let url_ = this.baseUrl + "/api/services/SYS/read/Form/GetList";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json", 
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetList(<any>response_);
                } catch (e) {
                    return <Observable<FormOutputDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<FormOutputDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetList(response: HttpResponseBase): Observable<FormOutputDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(FormOutputDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FormOutputDto[]>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    get(body: GuidEntityDto | undefined): Observable<FormOutputDto> {
        let url_ = this.baseUrl + "/api/services/SYS/read/Form/Get";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json", 
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(<any>response_);
                } catch (e) {
                    return <Observable<FormOutputDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<FormOutputDto>><any>_observableThrow(response_);
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<FormOutputDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? FormOutputDto.fromJS(resultData200) : new FormOutputDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FormOutputDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    create(body: FormInputDto | undefined): Observable<FormOutputDto> {
        let url_ = this.baseUrl + "/api/services/SYS/write/Form/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json", 
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(<any>response_);
                } catch (e) {
                    return <Observable<FormOutputDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<FormOutputDto>><any>_observableThrow(response_);
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<FormOutputDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? FormOutputDto.fromJS(resultData200) : new FormOutputDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FormOutputDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    update(body: FormInputDto | undefined): Observable<FormOutputDto> {
        let url_ = this.baseUrl + "/api/services/SYS/write/Form/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json", 
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(<any>response_);
                } catch (e) {
                    return <Observable<FormOutputDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<FormOutputDto>><any>_observableThrow(response_);
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<FormOutputDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? FormOutputDto.fromJS(resultData200) : new FormOutputDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FormOutputDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    delete(body: GuidEntityDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/SYS/write/Form/Delete";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class SysGroupServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(SYS_API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    getList(body: GroupGuidGetDto | undefined): Observable<GroupOutputDto[]> {
        let url_ = this.baseUrl + "/api/services/SYS/read/Group/GetList";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json", 
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetList(<any>response_);
                } catch (e) {
                    return <Observable<GroupOutputDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<GroupOutputDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetList(response: HttpResponseBase): Observable<GroupOutputDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(GroupOutputDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GroupOutputDto[]>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    get(body: GuidEntityDto | undefined): Observable<GroupOutputDto> {
        let url_ = this.baseUrl + "/api/services/SYS/read/Group/Get";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json", 
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(<any>response_);
                } catch (e) {
                    return <Observable<GroupOutputDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<GroupOutputDto>><any>_observableThrow(response_);
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<GroupOutputDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GroupOutputDto.fromJS(resultData200) : new GroupOutputDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GroupOutputDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    create(body: GroupInputDto | undefined): Observable<GroupOutputDto> {
        let url_ = this.baseUrl + "/api/services/SYS/write/Group/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json", 
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(<any>response_);
                } catch (e) {
                    return <Observable<GroupOutputDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<GroupOutputDto>><any>_observableThrow(response_);
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<GroupOutputDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GroupOutputDto.fromJS(resultData200) : new GroupOutputDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GroupOutputDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    update(body: GroupInputDto | undefined): Observable<GroupOutputDto> {
        let url_ = this.baseUrl + "/api/services/SYS/write/Group/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json", 
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(<any>response_);
                } catch (e) {
                    return <Observable<GroupOutputDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<GroupOutputDto>><any>_observableThrow(response_);
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<GroupOutputDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GroupOutputDto.fromJS(resultData200) : new GroupOutputDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GroupOutputDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    delete(body: GuidEntityDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/SYS/write/Group/Delete";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    creaateField(body: GroupInputDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/SYS/write/Group/CreaateField";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreaateField(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreaateField(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreaateField(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    addField(body: GroupInputDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/SYS/write/Group/AddField";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddField(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddField(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processAddField(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    setField(body: GroupInputDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/SYS/write/Group/SetField";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSetField(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSetField(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processSetField(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class SysMenuServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(SYS_API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    getList(body: MenuGuidGetDto | undefined): Observable<ValueMenuDto[]> {
        let url_ = this.baseUrl + "/api/services/SYS/read/Menu/GetList";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json", 
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetList(<any>response_);
                } catch (e) {
                    return <Observable<ValueMenuDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<ValueMenuDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetList(response: HttpResponseBase): Observable<ValueMenuDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(ValueMenuDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ValueMenuDto[]>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    getAll(body: MenuGuidGetDto | undefined): Observable<MenuOutputDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/SYS/read/Menu/GetAll";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json", 
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<MenuOutputDtoPagedResultDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<MenuOutputDtoPagedResultDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<MenuOutputDtoPagedResultDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? MenuOutputDtoPagedResultDto.fromJS(resultData200) : new MenuOutputDtoPagedResultDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MenuOutputDtoPagedResultDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    get(body: GuidEntityDto | undefined): Observable<MenuOutputDto> {
        let url_ = this.baseUrl + "/api/services/SYS/read/Menu/Get";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json", 
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(<any>response_);
                } catch (e) {
                    return <Observable<MenuOutputDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<MenuOutputDto>><any>_observableThrow(response_);
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<MenuOutputDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? MenuOutputDto.fromJS(resultData200) : new MenuOutputDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MenuOutputDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    create(body: MenuInputDto | undefined): Observable<MenuOutputDto> {
        let url_ = this.baseUrl + "/api/services/SYS/write/Menu/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json", 
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(<any>response_);
                } catch (e) {
                    return <Observable<MenuOutputDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<MenuOutputDto>><any>_observableThrow(response_);
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<MenuOutputDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? MenuOutputDto.fromJS(resultData200) : new MenuOutputDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MenuOutputDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    update(body: MenuInputDto | undefined): Observable<MenuOutputDto> {
        let url_ = this.baseUrl + "/api/services/SYS/write/Menu/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json", 
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(<any>response_);
                } catch (e) {
                    return <Observable<MenuOutputDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<MenuOutputDto>><any>_observableThrow(response_);
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<MenuOutputDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? MenuOutputDto.fromJS(resultData200) : new MenuOutputDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MenuOutputDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    delete(body: GuidEntityDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/SYS/write/Menu/Delete";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class SysMenuClientServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(SYS_API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    getList(body: MenuGuidGetDto | undefined): Observable<ValueMenuDto[]> {
        let url_ = this.baseUrl + "/api/services/SYS/read/MenuClient/GetList";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json", 
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetList(<any>response_);
                } catch (e) {
                    return <Observable<ValueMenuDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<ValueMenuDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetList(response: HttpResponseBase): Observable<ValueMenuDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(ValueMenuDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ValueMenuDto[]>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    checkPermission(body: MenuCheckPermissionDto | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/services/SYS/read/MenuClient/CheckPermission";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json", 
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCheckPermission(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCheckPermission(<any>response_);
                } catch (e) {
                    return <Observable<boolean>><any>_observableThrow(e);
                }
            } else
                return <Observable<boolean>><any>_observableThrow(response_);
        }));
    }

    protected processCheckPermission(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<boolean>(<any>null);
    }
}

@Injectable()
export class SysMethodServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(SYS_API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    getList(body: MethodGuidGetDto | undefined): Observable<MethodOutputDto[]> {
        let url_ = this.baseUrl + "/api/services/SYS/read/Method/GetList";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json", 
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetList(<any>response_);
                } catch (e) {
                    return <Observable<MethodOutputDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<MethodOutputDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetList(response: HttpResponseBase): Observable<MethodOutputDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(MethodOutputDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MethodOutputDto[]>(<any>null);
    }

    /**
     * @return Success
     */
    buildMethod(): Observable<void> {
        let url_ = this.baseUrl + "/api/services/SYS/write/Method/BuildMethod";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processBuildMethod(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processBuildMethod(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processBuildMethod(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updatePermission(body: MethodInputDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/SYS/write/Method/UpdatePermission";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdatePermission(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdatePermission(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdatePermission(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class SysSettingServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(SYS_API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    getList(body: SettingEntityGuidGetDto | undefined): Observable<SettingOutputDto[]> {
        let url_ = this.baseUrl + "/api/services/DATA/read/Setting/GetList";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json", 
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetList(<any>response_);
                } catch (e) {
                    return <Observable<SettingOutputDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<SettingOutputDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetList(response: HttpResponseBase): Observable<SettingOutputDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(SettingOutputDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SettingOutputDto[]>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    getSetting(body: GuidEntityDto | undefined): Observable<SettingOutputDto> {
        let url_ = this.baseUrl + "/api/services/DATA/read/Setting/GetSetting";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json", 
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSetting(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSetting(<any>response_);
                } catch (e) {
                    return <Observable<SettingOutputDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<SettingOutputDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetSetting(response: HttpResponseBase): Observable<SettingOutputDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? SettingOutputDto.fromJS(resultData200) : new SettingOutputDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SettingOutputDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    set(body: SettingInputDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/DATA/write/Setting/Set";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSet(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processSet(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    delete(body: SettingInputDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/DATA/write/Setting/Delete";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class SysSettingClientServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(SYS_API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    getSetting(body: GetSettingDto | undefined): Observable<string> {
        let url_ = this.baseUrl + "/api/services/DATA/read/SettingClient/GetSetting";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json", 
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSetting(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSetting(<any>response_);
                } catch (e) {
                    return <Observable<string>><any>_observableThrow(e);
                }
            } else
                return <Observable<string>><any>_observableThrow(response_);
        }));
    }

    protected processGetSetting(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    getUserSetting(body: GetSettingDto | undefined): Observable<string> {
        let url_ = this.baseUrl + "/api/services/DATA/read/SettingClient/GetUserSetting";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json", 
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetUserSetting(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUserSetting(<any>response_);
                } catch (e) {
                    return <Observable<string>><any>_observableThrow(e);
                }
            } else
                return <Observable<string>><any>_observableThrow(response_);
        }));
    }

    protected processGetUserSetting(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    getSettings(body: GetSettingDto | undefined): Observable<string[]> {
        let url_ = this.baseUrl + "/api/services/DATA/read/SettingClient/GetSettings";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json", 
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSettings(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSettings(<any>response_);
                } catch (e) {
                    return <Observable<string[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<string[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetSettings(response: HttpResponseBase): Observable<string[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(item);
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string[]>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    getUserSettings(body: GetSettingDto | undefined): Observable<string[]> {
        let url_ = this.baseUrl + "/api/services/DATA/read/SettingClient/GetUserSettings";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json", 
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetUserSettings(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUserSettings(<any>response_);
                } catch (e) {
                    return <Observable<string[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<string[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetUserSettings(response: HttpResponseBase): Observable<string[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(item);
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string[]>(<any>null);
    }
}

export enum OperationCriteria {
    _0 = 0, 
    _1 = 1, 
    _2 = 2, 
    _3 = 3, 
    _4 = 4, 
    _5 = 5, 
    _6 = 6, 
    _7 = 7, 
    _8 = 8, 
    _9 = 9, 
    _10 = 10, 
}

export class CriteriaRequestDto implements ICriteriaRequestDto {
    propertyName: string | undefined;
    operation: OperationCriteria;
    value: string | undefined;

    constructor(data?: ICriteriaRequestDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.propertyName = data["propertyName"];
            this.operation = data["operation"];
            this.value = data["value"];
        }
    }

    static fromJS(data: any): CriteriaRequestDto {
        data = typeof data === 'object' ? data : {};
        let result = new CriteriaRequestDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["propertyName"] = this.propertyName;
        data["operation"] = this.operation;
        data["value"] = this.value;
        return data; 
    }

    clone(): CriteriaRequestDto {
        const json = this.toJSON();
        let result = new CriteriaRequestDto();
        result.init(json);
        return result;
    }
}

export interface ICriteriaRequestDto {
    propertyName: string | undefined;
    operation: OperationCriteria;
    value: string | undefined;
}

export class CategoryGuidGetDto implements ICategoryGuidGetDto {
    maxResultCount: number;
    skipCount: number;
    sorting: string | undefined;
    criterias: CriteriaRequestDto[] | undefined;
    tenantId: number | undefined;
    userId: number | undefined;
    id: string;
    language: string | undefined;
    option: string | undefined;
    search: string | undefined;
    status: string | undefined;
    from: moment.Moment | undefined;
    to: moment.Moment | undefined;
    sValue: string[] | undefined;
    lValue: number[] | undefined;
    gValue: string[] | undefined;
    dValue: number[] | undefined;
    tValue: moment.Moment[] | undefined;

    constructor(data?: ICategoryGuidGetDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.maxResultCount = data["maxResultCount"];
            this.skipCount = data["skipCount"];
            this.sorting = data["sorting"];
            if (data["criterias"] && data["criterias"].constructor === Array) {
                this.criterias = [] as any;
                for (let item of data["criterias"])
                    this.criterias.push(CriteriaRequestDto.fromJS(item));
            }
            this.tenantId = data["tenantId"];
            this.userId = data["userId"];
            this.id = data["id"];
            this.language = data["language"];
            this.option = data["option"];
            this.search = data["search"];
            this.status = data["status"];
            this.from = data["from"] ? moment(data["from"].toString()) : <any>undefined;
            this.to = data["to"] ? moment(data["to"].toString()) : <any>undefined;
            if (data["sValue"] && data["sValue"].constructor === Array) {
                this.sValue = [] as any;
                for (let item of data["sValue"])
                    this.sValue.push(item);
            }
            if (data["lValue"] && data["lValue"].constructor === Array) {
                this.lValue = [] as any;
                for (let item of data["lValue"])
                    this.lValue.push(item);
            }
            if (data["gValue"] && data["gValue"].constructor === Array) {
                this.gValue = [] as any;
                for (let item of data["gValue"])
                    this.gValue.push(item);
            }
            if (data["dValue"] && data["dValue"].constructor === Array) {
                this.dValue = [] as any;
                for (let item of data["dValue"])
                    this.dValue.push(item);
            }
            if (data["tValue"] && data["tValue"].constructor === Array) {
                this.tValue = [] as any;
                for (let item of data["tValue"])
                    this.tValue.push(moment(item));
            }
        }
    }

    static fromJS(data: any): CategoryGuidGetDto {
        data = typeof data === 'object' ? data : {};
        let result = new CategoryGuidGetDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["maxResultCount"] = this.maxResultCount;
        data["skipCount"] = this.skipCount;
        data["sorting"] = this.sorting;
        if (this.criterias && this.criterias.constructor === Array) {
            data["criterias"] = [];
            for (let item of this.criterias)
                data["criterias"].push(item.toJSON());
        }
        data["tenantId"] = this.tenantId;
        data["userId"] = this.userId;
        data["id"] = this.id;
        data["language"] = this.language;
        data["option"] = this.option;
        data["search"] = this.search;
        data["status"] = this.status;
        data["from"] = this.from ? this.from.toISOString() : <any>undefined;
        data["to"] = this.to ? this.to.toISOString() : <any>undefined;
        if (this.sValue && this.sValue.constructor === Array) {
            data["sValue"] = [];
            for (let item of this.sValue)
                data["sValue"].push(item);
        }
        if (this.lValue && this.lValue.constructor === Array) {
            data["lValue"] = [];
            for (let item of this.lValue)
                data["lValue"].push(item);
        }
        if (this.gValue && this.gValue.constructor === Array) {
            data["gValue"] = [];
            for (let item of this.gValue)
                data["gValue"].push(item);
        }
        if (this.dValue && this.dValue.constructor === Array) {
            data["dValue"] = [];
            for (let item of this.dValue)
                data["dValue"].push(item);
        }
        if (this.tValue && this.tValue.constructor === Array) {
            data["tValue"] = [];
            for (let item of this.tValue)
                data["tValue"].push(item.toISOString());
        }
        return data; 
    }

    clone(): CategoryGuidGetDto {
        const json = this.toJSON();
        let result = new CategoryGuidGetDto();
        result.init(json);
        return result;
    }
}

export interface ICategoryGuidGetDto {
    maxResultCount: number;
    skipCount: number;
    sorting: string | undefined;
    criterias: CriteriaRequestDto[] | undefined;
    tenantId: number | undefined;
    userId: number | undefined;
    id: string;
    language: string | undefined;
    option: string | undefined;
    search: string | undefined;
    status: string | undefined;
    from: moment.Moment | undefined;
    to: moment.Moment | undefined;
    sValue: string[] | undefined;
    lValue: number[] | undefined;
    gValue: string[] | undefined;
    dValue: number[] | undefined;
    tValue: moment.Moment[] | undefined;
}

export class CategoryOutputDto implements ICategoryOutputDto {
    id: string;
    tenantId: number | undefined;
    status: string | undefined;
    search: string | undefined;
    hideValue: string | undefined;
    creatorUserId: number | undefined;
    creationTime: moment.Moment;
    name: string | undefined;
    code: string | undefined;
    codeData: string | undefined;
    valueData: string | undefined;
    category: string | undefined;
    permissions: string | undefined;
    language: string | undefined;
    value1: string | undefined;
    value2: string | undefined;
    value3: string | undefined;
    value4: string | undefined;
    value5: string | undefined;
    value6: string | undefined;
    value7: string | undefined;
    value8: string | undefined;
    value9: string | undefined;
    value10: string | undefined;
    number1: number;
    number2: number;
    number3: number;
    number4: number;
    number5: number;
    number6: number;
    number7: number;
    number8: number;
    number9: number;
    number10: number;
    parentId: string | undefined;
    index: number;
    order: number;
    groupCode: string | undefined;
    hashCode: string | undefined;
    group: string | undefined;
    parentCode: string | undefined;
    parentName: string | undefined;

    constructor(data?: ICategoryOutputDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.tenantId = data["tenantId"];
            this.status = data["status"];
            this.search = data["search"];
            this.hideValue = data["hideValue"];
            this.creatorUserId = data["creatorUserId"];
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.name = data["name"];
            this.code = data["code"];
            this.codeData = data["codeData"];
            this.valueData = data["valueData"];
            this.category = data["category"];
            this.permissions = data["permissions"];
            this.language = data["language"];
            this.value1 = data["value1"];
            this.value2 = data["value2"];
            this.value3 = data["value3"];
            this.value4 = data["value4"];
            this.value5 = data["value5"];
            this.value6 = data["value6"];
            this.value7 = data["value7"];
            this.value8 = data["value8"];
            this.value9 = data["value9"];
            this.value10 = data["value10"];
            this.number1 = data["number1"];
            this.number2 = data["number2"];
            this.number3 = data["number3"];
            this.number4 = data["number4"];
            this.number5 = data["number5"];
            this.number6 = data["number6"];
            this.number7 = data["number7"];
            this.number8 = data["number8"];
            this.number9 = data["number9"];
            this.number10 = data["number10"];
            this.parentId = data["parentId"];
            this.index = data["index"];
            this.order = data["order"];
            this.groupCode = data["groupCode"];
            this.hashCode = data["hashCode"];
            this.group = data["group"];
            this.parentCode = data["parentCode"];
            this.parentName = data["parentName"];
        }
    }

    static fromJS(data: any): CategoryOutputDto {
        data = typeof data === 'object' ? data : {};
        let result = new CategoryOutputDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["tenantId"] = this.tenantId;
        data["status"] = this.status;
        data["search"] = this.search;
        data["hideValue"] = this.hideValue;
        data["creatorUserId"] = this.creatorUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["name"] = this.name;
        data["code"] = this.code;
        data["codeData"] = this.codeData;
        data["valueData"] = this.valueData;
        data["category"] = this.category;
        data["permissions"] = this.permissions;
        data["language"] = this.language;
        data["value1"] = this.value1;
        data["value2"] = this.value2;
        data["value3"] = this.value3;
        data["value4"] = this.value4;
        data["value5"] = this.value5;
        data["value6"] = this.value6;
        data["value7"] = this.value7;
        data["value8"] = this.value8;
        data["value9"] = this.value9;
        data["value10"] = this.value10;
        data["number1"] = this.number1;
        data["number2"] = this.number2;
        data["number3"] = this.number3;
        data["number4"] = this.number4;
        data["number5"] = this.number5;
        data["number6"] = this.number6;
        data["number7"] = this.number7;
        data["number8"] = this.number8;
        data["number9"] = this.number9;
        data["number10"] = this.number10;
        data["parentId"] = this.parentId;
        data["index"] = this.index;
        data["order"] = this.order;
        data["groupCode"] = this.groupCode;
        data["hashCode"] = this.hashCode;
        data["group"] = this.group;
        data["parentCode"] = this.parentCode;
        data["parentName"] = this.parentName;
        return data; 
    }

    clone(): CategoryOutputDto {
        const json = this.toJSON();
        let result = new CategoryOutputDto();
        result.init(json);
        return result;
    }
}

export interface ICategoryOutputDto {
    id: string;
    tenantId: number | undefined;
    status: string | undefined;
    search: string | undefined;
    hideValue: string | undefined;
    creatorUserId: number | undefined;
    creationTime: moment.Moment;
    name: string | undefined;
    code: string | undefined;
    codeData: string | undefined;
    valueData: string | undefined;
    category: string | undefined;
    permissions: string | undefined;
    language: string | undefined;
    value1: string | undefined;
    value2: string | undefined;
    value3: string | undefined;
    value4: string | undefined;
    value5: string | undefined;
    value6: string | undefined;
    value7: string | undefined;
    value8: string | undefined;
    value9: string | undefined;
    value10: string | undefined;
    number1: number;
    number2: number;
    number3: number;
    number4: number;
    number5: number;
    number6: number;
    number7: number;
    number8: number;
    number9: number;
    number10: number;
    parentId: string | undefined;
    index: number;
    order: number;
    groupCode: string | undefined;
    hashCode: string | undefined;
    group: string | undefined;
    parentCode: string | undefined;
    parentName: string | undefined;
}

export class GuidEntityDto implements IGuidEntityDto {
    id: string;

    constructor(data?: IGuidEntityDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
        }
    }

    static fromJS(data: any): GuidEntityDto {
        data = typeof data === 'object' ? data : {};
        let result = new GuidEntityDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        return data; 
    }

    clone(): GuidEntityDto {
        const json = this.toJSON();
        let result = new GuidEntityDto();
        result.init(json);
        return result;
    }
}

export interface IGuidEntityDto {
    id: string;
}

export class CategoryInputDto implements ICategoryInputDto {
    id: string;
    tenantId: number | undefined;
    status: string | undefined;
    search: string | undefined;
    hideValue: string | undefined;
    creatorUserId: number | undefined;
    creationTime: moment.Moment;
    name: string | undefined;
    code: string | undefined;
    codeData: string | undefined;
    valueData: string | undefined;
    category: string | undefined;
    permissions: string | undefined;
    language: string | undefined;
    value1: string | undefined;
    value2: string | undefined;
    value3: string | undefined;
    value4: string | undefined;
    value5: string | undefined;
    value6: string | undefined;
    value7: string | undefined;
    value8: string | undefined;
    value9: string | undefined;
    value10: string | undefined;
    number1: number;
    number2: number;
    number3: number;
    number4: number;
    number5: number;
    number6: number;
    number7: number;
    number8: number;
    number9: number;
    number10: number;
    parentId: string | undefined;
    index: number;
    order: number;
    groupCode: string | undefined;
    hashCode: string | undefined;
    group: string | undefined;

    constructor(data?: ICategoryInputDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.tenantId = data["tenantId"];
            this.status = data["status"];
            this.search = data["search"];
            this.hideValue = data["hideValue"];
            this.creatorUserId = data["creatorUserId"];
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.name = data["name"];
            this.code = data["code"];
            this.codeData = data["codeData"];
            this.valueData = data["valueData"];
            this.category = data["category"];
            this.permissions = data["permissions"];
            this.language = data["language"];
            this.value1 = data["value1"];
            this.value2 = data["value2"];
            this.value3 = data["value3"];
            this.value4 = data["value4"];
            this.value5 = data["value5"];
            this.value6 = data["value6"];
            this.value7 = data["value7"];
            this.value8 = data["value8"];
            this.value9 = data["value9"];
            this.value10 = data["value10"];
            this.number1 = data["number1"];
            this.number2 = data["number2"];
            this.number3 = data["number3"];
            this.number4 = data["number4"];
            this.number5 = data["number5"];
            this.number6 = data["number6"];
            this.number7 = data["number7"];
            this.number8 = data["number8"];
            this.number9 = data["number9"];
            this.number10 = data["number10"];
            this.parentId = data["parentId"];
            this.index = data["index"];
            this.order = data["order"];
            this.groupCode = data["groupCode"];
            this.hashCode = data["hashCode"];
            this.group = data["group"];
        }
    }

    static fromJS(data: any): CategoryInputDto {
        data = typeof data === 'object' ? data : {};
        let result = new CategoryInputDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["tenantId"] = this.tenantId;
        data["status"] = this.status;
        data["search"] = this.search;
        data["hideValue"] = this.hideValue;
        data["creatorUserId"] = this.creatorUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["name"] = this.name;
        data["code"] = this.code;
        data["codeData"] = this.codeData;
        data["valueData"] = this.valueData;
        data["category"] = this.category;
        data["permissions"] = this.permissions;
        data["language"] = this.language;
        data["value1"] = this.value1;
        data["value2"] = this.value2;
        data["value3"] = this.value3;
        data["value4"] = this.value4;
        data["value5"] = this.value5;
        data["value6"] = this.value6;
        data["value7"] = this.value7;
        data["value8"] = this.value8;
        data["value9"] = this.value9;
        data["value10"] = this.value10;
        data["number1"] = this.number1;
        data["number2"] = this.number2;
        data["number3"] = this.number3;
        data["number4"] = this.number4;
        data["number5"] = this.number5;
        data["number6"] = this.number6;
        data["number7"] = this.number7;
        data["number8"] = this.number8;
        data["number9"] = this.number9;
        data["number10"] = this.number10;
        data["parentId"] = this.parentId;
        data["index"] = this.index;
        data["order"] = this.order;
        data["groupCode"] = this.groupCode;
        data["hashCode"] = this.hashCode;
        data["group"] = this.group;
        return data; 
    }

    clone(): CategoryInputDto {
        const json = this.toJSON();
        let result = new CategoryInputDto();
        result.init(json);
        return result;
    }
}

export interface ICategoryInputDto {
    id: string;
    tenantId: number | undefined;
    status: string | undefined;
    search: string | undefined;
    hideValue: string | undefined;
    creatorUserId: number | undefined;
    creationTime: moment.Moment;
    name: string | undefined;
    code: string | undefined;
    codeData: string | undefined;
    valueData: string | undefined;
    category: string | undefined;
    permissions: string | undefined;
    language: string | undefined;
    value1: string | undefined;
    value2: string | undefined;
    value3: string | undefined;
    value4: string | undefined;
    value5: string | undefined;
    value6: string | undefined;
    value7: string | undefined;
    value8: string | undefined;
    value9: string | undefined;
    value10: string | undefined;
    number1: number;
    number2: number;
    number3: number;
    number4: number;
    number5: number;
    number6: number;
    number7: number;
    number8: number;
    number9: number;
    number10: number;
    parentId: string | undefined;
    index: number;
    order: number;
    groupCode: string | undefined;
    hashCode: string | undefined;
    group: string | undefined;
}

export class FieldGuidGetDto implements IFieldGuidGetDto {
    maxResultCount: number;
    skipCount: number;
    sorting: string | undefined;
    criterias: CriteriaRequestDto[] | undefined;
    tenantId: number | undefined;
    userId: number | undefined;
    id: string;
    language: string | undefined;
    option: string | undefined;
    search: string | undefined;
    status: string | undefined;
    from: moment.Moment | undefined;
    to: moment.Moment | undefined;
    sValue: string[] | undefined;
    lValue: number[] | undefined;
    gValue: string[] | undefined;
    dValue: number[] | undefined;
    tValue: moment.Moment[] | undefined;

    constructor(data?: IFieldGuidGetDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.maxResultCount = data["maxResultCount"];
            this.skipCount = data["skipCount"];
            this.sorting = data["sorting"];
            if (data["criterias"] && data["criterias"].constructor === Array) {
                this.criterias = [] as any;
                for (let item of data["criterias"])
                    this.criterias.push(CriteriaRequestDto.fromJS(item));
            }
            this.tenantId = data["tenantId"];
            this.userId = data["userId"];
            this.id = data["id"];
            this.language = data["language"];
            this.option = data["option"];
            this.search = data["search"];
            this.status = data["status"];
            this.from = data["from"] ? moment(data["from"].toString()) : <any>undefined;
            this.to = data["to"] ? moment(data["to"].toString()) : <any>undefined;
            if (data["sValue"] && data["sValue"].constructor === Array) {
                this.sValue = [] as any;
                for (let item of data["sValue"])
                    this.sValue.push(item);
            }
            if (data["lValue"] && data["lValue"].constructor === Array) {
                this.lValue = [] as any;
                for (let item of data["lValue"])
                    this.lValue.push(item);
            }
            if (data["gValue"] && data["gValue"].constructor === Array) {
                this.gValue = [] as any;
                for (let item of data["gValue"])
                    this.gValue.push(item);
            }
            if (data["dValue"] && data["dValue"].constructor === Array) {
                this.dValue = [] as any;
                for (let item of data["dValue"])
                    this.dValue.push(item);
            }
            if (data["tValue"] && data["tValue"].constructor === Array) {
                this.tValue = [] as any;
                for (let item of data["tValue"])
                    this.tValue.push(moment(item));
            }
        }
    }

    static fromJS(data: any): FieldGuidGetDto {
        data = typeof data === 'object' ? data : {};
        let result = new FieldGuidGetDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["maxResultCount"] = this.maxResultCount;
        data["skipCount"] = this.skipCount;
        data["sorting"] = this.sorting;
        if (this.criterias && this.criterias.constructor === Array) {
            data["criterias"] = [];
            for (let item of this.criterias)
                data["criterias"].push(item.toJSON());
        }
        data["tenantId"] = this.tenantId;
        data["userId"] = this.userId;
        data["id"] = this.id;
        data["language"] = this.language;
        data["option"] = this.option;
        data["search"] = this.search;
        data["status"] = this.status;
        data["from"] = this.from ? this.from.toISOString() : <any>undefined;
        data["to"] = this.to ? this.to.toISOString() : <any>undefined;
        if (this.sValue && this.sValue.constructor === Array) {
            data["sValue"] = [];
            for (let item of this.sValue)
                data["sValue"].push(item);
        }
        if (this.lValue && this.lValue.constructor === Array) {
            data["lValue"] = [];
            for (let item of this.lValue)
                data["lValue"].push(item);
        }
        if (this.gValue && this.gValue.constructor === Array) {
            data["gValue"] = [];
            for (let item of this.gValue)
                data["gValue"].push(item);
        }
        if (this.dValue && this.dValue.constructor === Array) {
            data["dValue"] = [];
            for (let item of this.dValue)
                data["dValue"].push(item);
        }
        if (this.tValue && this.tValue.constructor === Array) {
            data["tValue"] = [];
            for (let item of this.tValue)
                data["tValue"].push(item.toISOString());
        }
        return data; 
    }

    clone(): FieldGuidGetDto {
        const json = this.toJSON();
        let result = new FieldGuidGetDto();
        result.init(json);
        return result;
    }
}

export interface IFieldGuidGetDto {
    maxResultCount: number;
    skipCount: number;
    sorting: string | undefined;
    criterias: CriteriaRequestDto[] | undefined;
    tenantId: number | undefined;
    userId: number | undefined;
    id: string;
    language: string | undefined;
    option: string | undefined;
    search: string | undefined;
    status: string | undefined;
    from: moment.Moment | undefined;
    to: moment.Moment | undefined;
    sValue: string[] | undefined;
    lValue: number[] | undefined;
    gValue: string[] | undefined;
    dValue: number[] | undefined;
    tValue: moment.Moment[] | undefined;
}

export class FieldOutputDto implements IFieldOutputDto {
    id: string;
    tenantId: number;
    status: string | undefined;
    search: string | undefined;
    hideValue: string | undefined;
    creatorUserId: number | undefined;
    creationTime: moment.Moment;
    name: string | undefined;
    code: string | undefined;
    codeData: string | undefined;
    valueData: string | undefined;
    category: string | undefined;
    permissions: string | undefined;
    language: string | undefined;
    value1: string | undefined;
    value2: string | undefined;
    value3: string | undefined;
    value4: string | undefined;
    value5: string | undefined;
    value6: string | undefined;
    value7: string | undefined;
    value8: string | undefined;
    value9: string | undefined;
    value10: string | undefined;
    number1: number;
    number2: number;
    number3: number;
    number4: number;
    number5: number;
    number6: number;
    number7: number;
    number8: number;
    number9: number;
    number10: number;
    type: string | undefined;
    dependenCodes: string | undefined;
    defaultValue: string | undefined;
    referenceValue: string | undefined;
    required: string | undefined;
    validate: string | undefined;
    format: string | undefined;
    formula: string | undefined;
    css: string | undefined;

    constructor(data?: IFieldOutputDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.tenantId = data["tenantId"];
            this.status = data["status"];
            this.search = data["search"];
            this.hideValue = data["hideValue"];
            this.creatorUserId = data["creatorUserId"];
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.name = data["name"];
            this.code = data["code"];
            this.codeData = data["codeData"];
            this.valueData = data["valueData"];
            this.category = data["category"];
            this.permissions = data["permissions"];
            this.language = data["language"];
            this.value1 = data["value1"];
            this.value2 = data["value2"];
            this.value3 = data["value3"];
            this.value4 = data["value4"];
            this.value5 = data["value5"];
            this.value6 = data["value6"];
            this.value7 = data["value7"];
            this.value8 = data["value8"];
            this.value9 = data["value9"];
            this.value10 = data["value10"];
            this.number1 = data["number1"];
            this.number2 = data["number2"];
            this.number3 = data["number3"];
            this.number4 = data["number4"];
            this.number5 = data["number5"];
            this.number6 = data["number6"];
            this.number7 = data["number7"];
            this.number8 = data["number8"];
            this.number9 = data["number9"];
            this.number10 = data["number10"];
            this.type = data["type"];
            this.dependenCodes = data["dependenCodes"];
            this.defaultValue = data["defaultValue"];
            this.referenceValue = data["referenceValue"];
            this.required = data["required"];
            this.validate = data["validate"];
            this.format = data["format"];
            this.formula = data["formula"];
            this.css = data["css"];
        }
    }

    static fromJS(data: any): FieldOutputDto {
        data = typeof data === 'object' ? data : {};
        let result = new FieldOutputDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["tenantId"] = this.tenantId;
        data["status"] = this.status;
        data["search"] = this.search;
        data["hideValue"] = this.hideValue;
        data["creatorUserId"] = this.creatorUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["name"] = this.name;
        data["code"] = this.code;
        data["codeData"] = this.codeData;
        data["valueData"] = this.valueData;
        data["category"] = this.category;
        data["permissions"] = this.permissions;
        data["language"] = this.language;
        data["value1"] = this.value1;
        data["value2"] = this.value2;
        data["value3"] = this.value3;
        data["value4"] = this.value4;
        data["value5"] = this.value5;
        data["value6"] = this.value6;
        data["value7"] = this.value7;
        data["value8"] = this.value8;
        data["value9"] = this.value9;
        data["value10"] = this.value10;
        data["number1"] = this.number1;
        data["number2"] = this.number2;
        data["number3"] = this.number3;
        data["number4"] = this.number4;
        data["number5"] = this.number5;
        data["number6"] = this.number6;
        data["number7"] = this.number7;
        data["number8"] = this.number8;
        data["number9"] = this.number9;
        data["number10"] = this.number10;
        data["type"] = this.type;
        data["dependenCodes"] = this.dependenCodes;
        data["defaultValue"] = this.defaultValue;
        data["referenceValue"] = this.referenceValue;
        data["required"] = this.required;
        data["validate"] = this.validate;
        data["format"] = this.format;
        data["formula"] = this.formula;
        data["css"] = this.css;
        return data; 
    }

    clone(): FieldOutputDto {
        const json = this.toJSON();
        let result = new FieldOutputDto();
        result.init(json);
        return result;
    }
}

export interface IFieldOutputDto {
    id: string;
    tenantId: number;
    status: string | undefined;
    search: string | undefined;
    hideValue: string | undefined;
    creatorUserId: number | undefined;
    creationTime: moment.Moment;
    name: string | undefined;
    code: string | undefined;
    codeData: string | undefined;
    valueData: string | undefined;
    category: string | undefined;
    permissions: string | undefined;
    language: string | undefined;
    value1: string | undefined;
    value2: string | undefined;
    value3: string | undefined;
    value4: string | undefined;
    value5: string | undefined;
    value6: string | undefined;
    value7: string | undefined;
    value8: string | undefined;
    value9: string | undefined;
    value10: string | undefined;
    number1: number;
    number2: number;
    number3: number;
    number4: number;
    number5: number;
    number6: number;
    number7: number;
    number8: number;
    number9: number;
    number10: number;
    type: string | undefined;
    dependenCodes: string | undefined;
    defaultValue: string | undefined;
    referenceValue: string | undefined;
    required: string | undefined;
    validate: string | undefined;
    format: string | undefined;
    formula: string | undefined;
    css: string | undefined;
}

export class FieldOutputDtoPagedResultDto implements IFieldOutputDtoPagedResultDto {
    items: FieldOutputDto[] | undefined;
    totalCount: number;

    constructor(data?: IFieldOutputDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items.push(FieldOutputDto.fromJS(item));
            }
            this.totalCount = data["totalCount"];
        }
    }

    static fromJS(data: any): FieldOutputDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new FieldOutputDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data; 
    }

    clone(): FieldOutputDtoPagedResultDto {
        const json = this.toJSON();
        let result = new FieldOutputDtoPagedResultDto();
        result.init(json);
        return result;
    }
}

export interface IFieldOutputDtoPagedResultDto {
    items: FieldOutputDto[] | undefined;
    totalCount: number;
}

export class FieldInputDto implements IFieldInputDto {
    id: string;
    tenantId: number;
    status: string | undefined;
    search: string | undefined;
    hideValue: string | undefined;
    creatorUserId: number | undefined;
    creationTime: moment.Moment;
    name: string | undefined;
    code: string | undefined;
    codeData: string | undefined;
    valueData: string | undefined;
    category: string | undefined;
    permissions: string | undefined;
    language: string | undefined;
    value1: string | undefined;
    value2: string | undefined;
    value3: string | undefined;
    value4: string | undefined;
    value5: string | undefined;
    value6: string | undefined;
    value7: string | undefined;
    value8: string | undefined;
    value9: string | undefined;
    value10: string | undefined;
    number1: number;
    number2: number;
    number3: number;
    number4: number;
    number5: number;
    number6: number;
    number7: number;
    number8: number;
    number9: number;
    number10: number;
    type: string | undefined;
    dependenCodes: string | undefined;
    defaultValue: string | undefined;
    referenceValue: string | undefined;
    required: string | undefined;
    validate: string | undefined;
    format: string | undefined;
    formula: string | undefined;
    css: string | undefined;

    constructor(data?: IFieldInputDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.tenantId = data["tenantId"];
            this.status = data["status"];
            this.search = data["search"];
            this.hideValue = data["hideValue"];
            this.creatorUserId = data["creatorUserId"];
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.name = data["name"];
            this.code = data["code"];
            this.codeData = data["codeData"];
            this.valueData = data["valueData"];
            this.category = data["category"];
            this.permissions = data["permissions"];
            this.language = data["language"];
            this.value1 = data["value1"];
            this.value2 = data["value2"];
            this.value3 = data["value3"];
            this.value4 = data["value4"];
            this.value5 = data["value5"];
            this.value6 = data["value6"];
            this.value7 = data["value7"];
            this.value8 = data["value8"];
            this.value9 = data["value9"];
            this.value10 = data["value10"];
            this.number1 = data["number1"];
            this.number2 = data["number2"];
            this.number3 = data["number3"];
            this.number4 = data["number4"];
            this.number5 = data["number5"];
            this.number6 = data["number6"];
            this.number7 = data["number7"];
            this.number8 = data["number8"];
            this.number9 = data["number9"];
            this.number10 = data["number10"];
            this.type = data["type"];
            this.dependenCodes = data["dependenCodes"];
            this.defaultValue = data["defaultValue"];
            this.referenceValue = data["referenceValue"];
            this.required = data["required"];
            this.validate = data["validate"];
            this.format = data["format"];
            this.formula = data["formula"];
            this.css = data["css"];
        }
    }

    static fromJS(data: any): FieldInputDto {
        data = typeof data === 'object' ? data : {};
        let result = new FieldInputDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["tenantId"] = this.tenantId;
        data["status"] = this.status;
        data["search"] = this.search;
        data["hideValue"] = this.hideValue;
        data["creatorUserId"] = this.creatorUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["name"] = this.name;
        data["code"] = this.code;
        data["codeData"] = this.codeData;
        data["valueData"] = this.valueData;
        data["category"] = this.category;
        data["permissions"] = this.permissions;
        data["language"] = this.language;
        data["value1"] = this.value1;
        data["value2"] = this.value2;
        data["value3"] = this.value3;
        data["value4"] = this.value4;
        data["value5"] = this.value5;
        data["value6"] = this.value6;
        data["value7"] = this.value7;
        data["value8"] = this.value8;
        data["value9"] = this.value9;
        data["value10"] = this.value10;
        data["number1"] = this.number1;
        data["number2"] = this.number2;
        data["number3"] = this.number3;
        data["number4"] = this.number4;
        data["number5"] = this.number5;
        data["number6"] = this.number6;
        data["number7"] = this.number7;
        data["number8"] = this.number8;
        data["number9"] = this.number9;
        data["number10"] = this.number10;
        data["type"] = this.type;
        data["dependenCodes"] = this.dependenCodes;
        data["defaultValue"] = this.defaultValue;
        data["referenceValue"] = this.referenceValue;
        data["required"] = this.required;
        data["validate"] = this.validate;
        data["format"] = this.format;
        data["formula"] = this.formula;
        data["css"] = this.css;
        return data; 
    }

    clone(): FieldInputDto {
        const json = this.toJSON();
        let result = new FieldInputDto();
        result.init(json);
        return result;
    }
}

export interface IFieldInputDto {
    id: string;
    tenantId: number;
    status: string | undefined;
    search: string | undefined;
    hideValue: string | undefined;
    creatorUserId: number | undefined;
    creationTime: moment.Moment;
    name: string | undefined;
    code: string | undefined;
    codeData: string | undefined;
    valueData: string | undefined;
    category: string | undefined;
    permissions: string | undefined;
    language: string | undefined;
    value1: string | undefined;
    value2: string | undefined;
    value3: string | undefined;
    value4: string | undefined;
    value5: string | undefined;
    value6: string | undefined;
    value7: string | undefined;
    value8: string | undefined;
    value9: string | undefined;
    value10: string | undefined;
    number1: number;
    number2: number;
    number3: number;
    number4: number;
    number5: number;
    number6: number;
    number7: number;
    number8: number;
    number9: number;
    number10: number;
    type: string | undefined;
    dependenCodes: string | undefined;
    defaultValue: string | undefined;
    referenceValue: string | undefined;
    required: string | undefined;
    validate: string | undefined;
    format: string | undefined;
    formula: string | undefined;
    css: string | undefined;
}

export class StringEntityDto implements IStringEntityDto {
    id: string | undefined;

    constructor(data?: IStringEntityDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
        }
    }

    static fromJS(data: any): StringEntityDto {
        data = typeof data === 'object' ? data : {};
        let result = new StringEntityDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        return data; 
    }

    clone(): StringEntityDto {
        const json = this.toJSON();
        let result = new StringEntityDto();
        result.init(json);
        return result;
    }
}

export interface IStringEntityDto {
    id: string | undefined;
}

export class FileEntity implements IFileEntity {
    id: string | undefined;
    tenantId: number | undefined;
    userId: number | undefined;
    name: string | undefined;
    type: string | undefined;
    data: string | undefined;
    fileUrl: string | undefined;
    typeFile: string | undefined;

    constructor(data?: IFileEntity) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.tenantId = data["tenantId"];
            this.userId = data["userId"];
            this.name = data["name"];
            this.type = data["type"];
            this.data = data["data"];
            this.fileUrl = data["fileUrl"];
            this.typeFile = data["typeFile"];
        }
    }

    static fromJS(data: any): FileEntity {
        data = typeof data === 'object' ? data : {};
        let result = new FileEntity();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["tenantId"] = this.tenantId;
        data["userId"] = this.userId;
        data["name"] = this.name;
        data["type"] = this.type;
        data["data"] = this.data;
        data["fileUrl"] = this.fileUrl;
        data["typeFile"] = this.typeFile;
        return data; 
    }

    clone(): FileEntity {
        const json = this.toJSON();
        let result = new FileEntity();
        result.init(json);
        return result;
    }
}

export interface IFileEntity {
    id: string | undefined;
    tenantId: number | undefined;
    userId: number | undefined;
    name: string | undefined;
    type: string | undefined;
    data: string | undefined;
    fileUrl: string | undefined;
    typeFile: string | undefined;
}

export class FormGuidGetDto implements IFormGuidGetDto {
    maxResultCount: number;
    skipCount: number;
    sorting: string | undefined;
    criterias: CriteriaRequestDto[] | undefined;
    tenantId: number | undefined;
    userId: number | undefined;
    id: string;
    language: string | undefined;
    option: string | undefined;
    search: string | undefined;
    status: string | undefined;
    from: moment.Moment | undefined;
    to: moment.Moment | undefined;
    sValue: string[] | undefined;
    lValue: number[] | undefined;
    gValue: string[] | undefined;
    dValue: number[] | undefined;
    tValue: moment.Moment[] | undefined;

    constructor(data?: IFormGuidGetDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.maxResultCount = data["maxResultCount"];
            this.skipCount = data["skipCount"];
            this.sorting = data["sorting"];
            if (data["criterias"] && data["criterias"].constructor === Array) {
                this.criterias = [] as any;
                for (let item of data["criterias"])
                    this.criterias.push(CriteriaRequestDto.fromJS(item));
            }
            this.tenantId = data["tenantId"];
            this.userId = data["userId"];
            this.id = data["id"];
            this.language = data["language"];
            this.option = data["option"];
            this.search = data["search"];
            this.status = data["status"];
            this.from = data["from"] ? moment(data["from"].toString()) : <any>undefined;
            this.to = data["to"] ? moment(data["to"].toString()) : <any>undefined;
            if (data["sValue"] && data["sValue"].constructor === Array) {
                this.sValue = [] as any;
                for (let item of data["sValue"])
                    this.sValue.push(item);
            }
            if (data["lValue"] && data["lValue"].constructor === Array) {
                this.lValue = [] as any;
                for (let item of data["lValue"])
                    this.lValue.push(item);
            }
            if (data["gValue"] && data["gValue"].constructor === Array) {
                this.gValue = [] as any;
                for (let item of data["gValue"])
                    this.gValue.push(item);
            }
            if (data["dValue"] && data["dValue"].constructor === Array) {
                this.dValue = [] as any;
                for (let item of data["dValue"])
                    this.dValue.push(item);
            }
            if (data["tValue"] && data["tValue"].constructor === Array) {
                this.tValue = [] as any;
                for (let item of data["tValue"])
                    this.tValue.push(moment(item));
            }
        }
    }

    static fromJS(data: any): FormGuidGetDto {
        data = typeof data === 'object' ? data : {};
        let result = new FormGuidGetDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["maxResultCount"] = this.maxResultCount;
        data["skipCount"] = this.skipCount;
        data["sorting"] = this.sorting;
        if (this.criterias && this.criterias.constructor === Array) {
            data["criterias"] = [];
            for (let item of this.criterias)
                data["criterias"].push(item.toJSON());
        }
        data["tenantId"] = this.tenantId;
        data["userId"] = this.userId;
        data["id"] = this.id;
        data["language"] = this.language;
        data["option"] = this.option;
        data["search"] = this.search;
        data["status"] = this.status;
        data["from"] = this.from ? this.from.toISOString() : <any>undefined;
        data["to"] = this.to ? this.to.toISOString() : <any>undefined;
        if (this.sValue && this.sValue.constructor === Array) {
            data["sValue"] = [];
            for (let item of this.sValue)
                data["sValue"].push(item);
        }
        if (this.lValue && this.lValue.constructor === Array) {
            data["lValue"] = [];
            for (let item of this.lValue)
                data["lValue"].push(item);
        }
        if (this.gValue && this.gValue.constructor === Array) {
            data["gValue"] = [];
            for (let item of this.gValue)
                data["gValue"].push(item);
        }
        if (this.dValue && this.dValue.constructor === Array) {
            data["dValue"] = [];
            for (let item of this.dValue)
                data["dValue"].push(item);
        }
        if (this.tValue && this.tValue.constructor === Array) {
            data["tValue"] = [];
            for (let item of this.tValue)
                data["tValue"].push(item.toISOString());
        }
        return data; 
    }

    clone(): FormGuidGetDto {
        const json = this.toJSON();
        let result = new FormGuidGetDto();
        result.init(json);
        return result;
    }
}

export interface IFormGuidGetDto {
    maxResultCount: number;
    skipCount: number;
    sorting: string | undefined;
    criterias: CriteriaRequestDto[] | undefined;
    tenantId: number | undefined;
    userId: number | undefined;
    id: string;
    language: string | undefined;
    option: string | undefined;
    search: string | undefined;
    status: string | undefined;
    from: moment.Moment | undefined;
    to: moment.Moment | undefined;
    sValue: string[] | undefined;
    lValue: number[] | undefined;
    gValue: string[] | undefined;
    dValue: number[] | undefined;
    tValue: moment.Moment[] | undefined;
}

export class FormOutputDto implements IFormOutputDto {
    id: string;
    tenantId: number;
    status: string | undefined;
    search: string | undefined;
    hideValue: string | undefined;
    creatorUserId: number | undefined;
    creationTime: moment.Moment;
    name: string | undefined;
    code: string | undefined;
    codeData: string | undefined;
    valueData: string | undefined;
    category: string | undefined;
    permissions: string | undefined;
    language: string | undefined;
    value1: string | undefined;
    value2: string | undefined;
    value3: string | undefined;
    value4: string | undefined;
    value5: string | undefined;
    value6: string | undefined;
    value7: string | undefined;
    value8: string | undefined;
    value9: string | undefined;
    value10: string | undefined;
    number1: number;
    number2: number;
    number3: number;
    number4: number;
    number5: number;
    number6: number;
    number7: number;
    number8: number;
    number9: number;
    number10: number;

    constructor(data?: IFormOutputDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.tenantId = data["tenantId"];
            this.status = data["status"];
            this.search = data["search"];
            this.hideValue = data["hideValue"];
            this.creatorUserId = data["creatorUserId"];
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.name = data["name"];
            this.code = data["code"];
            this.codeData = data["codeData"];
            this.valueData = data["valueData"];
            this.category = data["category"];
            this.permissions = data["permissions"];
            this.language = data["language"];
            this.value1 = data["value1"];
            this.value2 = data["value2"];
            this.value3 = data["value3"];
            this.value4 = data["value4"];
            this.value5 = data["value5"];
            this.value6 = data["value6"];
            this.value7 = data["value7"];
            this.value8 = data["value8"];
            this.value9 = data["value9"];
            this.value10 = data["value10"];
            this.number1 = data["number1"];
            this.number2 = data["number2"];
            this.number3 = data["number3"];
            this.number4 = data["number4"];
            this.number5 = data["number5"];
            this.number6 = data["number6"];
            this.number7 = data["number7"];
            this.number8 = data["number8"];
            this.number9 = data["number9"];
            this.number10 = data["number10"];
        }
    }

    static fromJS(data: any): FormOutputDto {
        data = typeof data === 'object' ? data : {};
        let result = new FormOutputDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["tenantId"] = this.tenantId;
        data["status"] = this.status;
        data["search"] = this.search;
        data["hideValue"] = this.hideValue;
        data["creatorUserId"] = this.creatorUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["name"] = this.name;
        data["code"] = this.code;
        data["codeData"] = this.codeData;
        data["valueData"] = this.valueData;
        data["category"] = this.category;
        data["permissions"] = this.permissions;
        data["language"] = this.language;
        data["value1"] = this.value1;
        data["value2"] = this.value2;
        data["value3"] = this.value3;
        data["value4"] = this.value4;
        data["value5"] = this.value5;
        data["value6"] = this.value6;
        data["value7"] = this.value7;
        data["value8"] = this.value8;
        data["value9"] = this.value9;
        data["value10"] = this.value10;
        data["number1"] = this.number1;
        data["number2"] = this.number2;
        data["number3"] = this.number3;
        data["number4"] = this.number4;
        data["number5"] = this.number5;
        data["number6"] = this.number6;
        data["number7"] = this.number7;
        data["number8"] = this.number8;
        data["number9"] = this.number9;
        data["number10"] = this.number10;
        return data; 
    }

    clone(): FormOutputDto {
        const json = this.toJSON();
        let result = new FormOutputDto();
        result.init(json);
        return result;
    }
}

export interface IFormOutputDto {
    id: string;
    tenantId: number;
    status: string | undefined;
    search: string | undefined;
    hideValue: string | undefined;
    creatorUserId: number | undefined;
    creationTime: moment.Moment;
    name: string | undefined;
    code: string | undefined;
    codeData: string | undefined;
    valueData: string | undefined;
    category: string | undefined;
    permissions: string | undefined;
    language: string | undefined;
    value1: string | undefined;
    value2: string | undefined;
    value3: string | undefined;
    value4: string | undefined;
    value5: string | undefined;
    value6: string | undefined;
    value7: string | undefined;
    value8: string | undefined;
    value9: string | undefined;
    value10: string | undefined;
    number1: number;
    number2: number;
    number3: number;
    number4: number;
    number5: number;
    number6: number;
    number7: number;
    number8: number;
    number9: number;
    number10: number;
}

export class FieldValueDto implements IFieldValueDto {
    id: string;
    c: string | undefined;
    n: string | undefined;
    t: string | undefined;
    v: string | undefined;
    i: number;
    de: string | undefined;
    d: string | undefined;
    re: string | undefined;
    r: string | undefined;
    va: string | undefined;
    fo: string | undefined;
    fa: string | undefined;
    fv: string | undefined;
    cs: string | undefined;
    p: string | undefined;

    constructor(data?: IFieldValueDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.c = data["c"];
            this.n = data["n"];
            this.t = data["t"];
            this.v = data["v"];
            this.i = data["i"];
            this.de = data["de"];
            this.d = data["d"];
            this.re = data["re"];
            this.r = data["r"];
            this.va = data["va"];
            this.fo = data["fo"];
            this.fa = data["fa"];
            this.fv = data["fv"];
            this.cs = data["cs"];
            this.p = data["p"];
        }
    }

    static fromJS(data: any): FieldValueDto {
        data = typeof data === 'object' ? data : {};
        let result = new FieldValueDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["c"] = this.c;
        data["n"] = this.n;
        data["t"] = this.t;
        data["v"] = this.v;
        data["i"] = this.i;
        data["de"] = this.de;
        data["d"] = this.d;
        data["re"] = this.re;
        data["r"] = this.r;
        data["va"] = this.va;
        data["fo"] = this.fo;
        data["fa"] = this.fa;
        data["fv"] = this.fv;
        data["cs"] = this.cs;
        data["p"] = this.p;
        return data; 
    }

    clone(): FieldValueDto {
        const json = this.toJSON();
        let result = new FieldValueDto();
        result.init(json);
        return result;
    }
}

export interface IFieldValueDto {
    id: string;
    c: string | undefined;
    n: string | undefined;
    t: string | undefined;
    v: string | undefined;
    i: number;
    de: string | undefined;
    d: string | undefined;
    re: string | undefined;
    r: string | undefined;
    va: string | undefined;
    fo: string | undefined;
    fa: string | undefined;
    fv: string | undefined;
    cs: string | undefined;
    p: string | undefined;
}

export class GroupInputDto implements IGroupInputDto {
    id: string;
    tenantId: number;
    status: string | undefined;
    search: string | undefined;
    hideValue: string | undefined;
    creatorUserId: number | undefined;
    creationTime: moment.Moment;
    name: string | undefined;
    code: string | undefined;
    codeData: string | undefined;
    valueData: string | undefined;
    category: string | undefined;
    permissions: string | undefined;
    language: string | undefined;
    value1: string | undefined;
    value2: string | undefined;
    value3: string | undefined;
    value4: string | undefined;
    value5: string | undefined;
    value6: string | undefined;
    value7: string | undefined;
    value8: string | undefined;
    value9: string | undefined;
    value10: string | undefined;
    number1: number;
    number2: number;
    number3: number;
    number4: number;
    number5: number;
    number6: number;
    number7: number;
    number8: number;
    number9: number;
    number10: number;
    formId: string;
    index: number;
    listField: FieldValueDto[] | undefined;

    constructor(data?: IGroupInputDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.tenantId = data["tenantId"];
            this.status = data["status"];
            this.search = data["search"];
            this.hideValue = data["hideValue"];
            this.creatorUserId = data["creatorUserId"];
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.name = data["name"];
            this.code = data["code"];
            this.codeData = data["codeData"];
            this.valueData = data["valueData"];
            this.category = data["category"];
            this.permissions = data["permissions"];
            this.language = data["language"];
            this.value1 = data["value1"];
            this.value2 = data["value2"];
            this.value3 = data["value3"];
            this.value4 = data["value4"];
            this.value5 = data["value5"];
            this.value6 = data["value6"];
            this.value7 = data["value7"];
            this.value8 = data["value8"];
            this.value9 = data["value9"];
            this.value10 = data["value10"];
            this.number1 = data["number1"];
            this.number2 = data["number2"];
            this.number3 = data["number3"];
            this.number4 = data["number4"];
            this.number5 = data["number5"];
            this.number6 = data["number6"];
            this.number7 = data["number7"];
            this.number8 = data["number8"];
            this.number9 = data["number9"];
            this.number10 = data["number10"];
            this.formId = data["formId"];
            this.index = data["index"];
            if (data["listField"] && data["listField"].constructor === Array) {
                this.listField = [] as any;
                for (let item of data["listField"])
                    this.listField.push(FieldValueDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GroupInputDto {
        data = typeof data === 'object' ? data : {};
        let result = new GroupInputDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["tenantId"] = this.tenantId;
        data["status"] = this.status;
        data["search"] = this.search;
        data["hideValue"] = this.hideValue;
        data["creatorUserId"] = this.creatorUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["name"] = this.name;
        data["code"] = this.code;
        data["codeData"] = this.codeData;
        data["valueData"] = this.valueData;
        data["category"] = this.category;
        data["permissions"] = this.permissions;
        data["language"] = this.language;
        data["value1"] = this.value1;
        data["value2"] = this.value2;
        data["value3"] = this.value3;
        data["value4"] = this.value4;
        data["value5"] = this.value5;
        data["value6"] = this.value6;
        data["value7"] = this.value7;
        data["value8"] = this.value8;
        data["value9"] = this.value9;
        data["value10"] = this.value10;
        data["number1"] = this.number1;
        data["number2"] = this.number2;
        data["number3"] = this.number3;
        data["number4"] = this.number4;
        data["number5"] = this.number5;
        data["number6"] = this.number6;
        data["number7"] = this.number7;
        data["number8"] = this.number8;
        data["number9"] = this.number9;
        data["number10"] = this.number10;
        data["formId"] = this.formId;
        data["index"] = this.index;
        if (this.listField && this.listField.constructor === Array) {
            data["listField"] = [];
            for (let item of this.listField)
                data["listField"].push(item.toJSON());
        }
        return data; 
    }

    clone(): GroupInputDto {
        const json = this.toJSON();
        let result = new GroupInputDto();
        result.init(json);
        return result;
    }
}

export interface IGroupInputDto {
    id: string;
    tenantId: number;
    status: string | undefined;
    search: string | undefined;
    hideValue: string | undefined;
    creatorUserId: number | undefined;
    creationTime: moment.Moment;
    name: string | undefined;
    code: string | undefined;
    codeData: string | undefined;
    valueData: string | undefined;
    category: string | undefined;
    permissions: string | undefined;
    language: string | undefined;
    value1: string | undefined;
    value2: string | undefined;
    value3: string | undefined;
    value4: string | undefined;
    value5: string | undefined;
    value6: string | undefined;
    value7: string | undefined;
    value8: string | undefined;
    value9: string | undefined;
    value10: string | undefined;
    number1: number;
    number2: number;
    number3: number;
    number4: number;
    number5: number;
    number6: number;
    number7: number;
    number8: number;
    number9: number;
    number10: number;
    formId: string;
    index: number;
    listField: FieldValueDto[] | undefined;
}

export class FormInputDto implements IFormInputDto {
    id: string;
    tenantId: number;
    status: string | undefined;
    search: string | undefined;
    hideValue: string | undefined;
    creatorUserId: number | undefined;
    creationTime: moment.Moment;
    name: string | undefined;
    code: string | undefined;
    codeData: string | undefined;
    valueData: string | undefined;
    category: string | undefined;
    permissions: string | undefined;
    language: string | undefined;
    value1: string | undefined;
    value2: string | undefined;
    value3: string | undefined;
    value4: string | undefined;
    value5: string | undefined;
    value6: string | undefined;
    value7: string | undefined;
    value8: string | undefined;
    value9: string | undefined;
    value10: string | undefined;
    number1: number;
    number2: number;
    number3: number;
    number4: number;
    number5: number;
    number6: number;
    number7: number;
    number8: number;
    number9: number;
    number10: number;
    listGroup: GroupInputDto[] | undefined;

    constructor(data?: IFormInputDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.tenantId = data["tenantId"];
            this.status = data["status"];
            this.search = data["search"];
            this.hideValue = data["hideValue"];
            this.creatorUserId = data["creatorUserId"];
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.name = data["name"];
            this.code = data["code"];
            this.codeData = data["codeData"];
            this.valueData = data["valueData"];
            this.category = data["category"];
            this.permissions = data["permissions"];
            this.language = data["language"];
            this.value1 = data["value1"];
            this.value2 = data["value2"];
            this.value3 = data["value3"];
            this.value4 = data["value4"];
            this.value5 = data["value5"];
            this.value6 = data["value6"];
            this.value7 = data["value7"];
            this.value8 = data["value8"];
            this.value9 = data["value9"];
            this.value10 = data["value10"];
            this.number1 = data["number1"];
            this.number2 = data["number2"];
            this.number3 = data["number3"];
            this.number4 = data["number4"];
            this.number5 = data["number5"];
            this.number6 = data["number6"];
            this.number7 = data["number7"];
            this.number8 = data["number8"];
            this.number9 = data["number9"];
            this.number10 = data["number10"];
            if (data["listGroup"] && data["listGroup"].constructor === Array) {
                this.listGroup = [] as any;
                for (let item of data["listGroup"])
                    this.listGroup.push(GroupInputDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): FormInputDto {
        data = typeof data === 'object' ? data : {};
        let result = new FormInputDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["tenantId"] = this.tenantId;
        data["status"] = this.status;
        data["search"] = this.search;
        data["hideValue"] = this.hideValue;
        data["creatorUserId"] = this.creatorUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["name"] = this.name;
        data["code"] = this.code;
        data["codeData"] = this.codeData;
        data["valueData"] = this.valueData;
        data["category"] = this.category;
        data["permissions"] = this.permissions;
        data["language"] = this.language;
        data["value1"] = this.value1;
        data["value2"] = this.value2;
        data["value3"] = this.value3;
        data["value4"] = this.value4;
        data["value5"] = this.value5;
        data["value6"] = this.value6;
        data["value7"] = this.value7;
        data["value8"] = this.value8;
        data["value9"] = this.value9;
        data["value10"] = this.value10;
        data["number1"] = this.number1;
        data["number2"] = this.number2;
        data["number3"] = this.number3;
        data["number4"] = this.number4;
        data["number5"] = this.number5;
        data["number6"] = this.number6;
        data["number7"] = this.number7;
        data["number8"] = this.number8;
        data["number9"] = this.number9;
        data["number10"] = this.number10;
        if (this.listGroup && this.listGroup.constructor === Array) {
            data["listGroup"] = [];
            for (let item of this.listGroup)
                data["listGroup"].push(item.toJSON());
        }
        return data; 
    }

    clone(): FormInputDto {
        const json = this.toJSON();
        let result = new FormInputDto();
        result.init(json);
        return result;
    }
}

export interface IFormInputDto {
    id: string;
    tenantId: number;
    status: string | undefined;
    search: string | undefined;
    hideValue: string | undefined;
    creatorUserId: number | undefined;
    creationTime: moment.Moment;
    name: string | undefined;
    code: string | undefined;
    codeData: string | undefined;
    valueData: string | undefined;
    category: string | undefined;
    permissions: string | undefined;
    language: string | undefined;
    value1: string | undefined;
    value2: string | undefined;
    value3: string | undefined;
    value4: string | undefined;
    value5: string | undefined;
    value6: string | undefined;
    value7: string | undefined;
    value8: string | undefined;
    value9: string | undefined;
    value10: string | undefined;
    number1: number;
    number2: number;
    number3: number;
    number4: number;
    number5: number;
    number6: number;
    number7: number;
    number8: number;
    number9: number;
    number10: number;
    listGroup: GroupInputDto[] | undefined;
}

export class GroupGuidGetDto implements IGroupGuidGetDto {
    maxResultCount: number;
    skipCount: number;
    sorting: string | undefined;
    criterias: CriteriaRequestDto[] | undefined;
    tenantId: number | undefined;
    userId: number | undefined;
    id: string;
    language: string | undefined;
    option: string | undefined;
    search: string | undefined;
    status: string | undefined;
    from: moment.Moment | undefined;
    to: moment.Moment | undefined;
    sValue: string[] | undefined;
    lValue: number[] | undefined;
    gValue: string[] | undefined;
    dValue: number[] | undefined;
    tValue: moment.Moment[] | undefined;

    constructor(data?: IGroupGuidGetDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.maxResultCount = data["maxResultCount"];
            this.skipCount = data["skipCount"];
            this.sorting = data["sorting"];
            if (data["criterias"] && data["criterias"].constructor === Array) {
                this.criterias = [] as any;
                for (let item of data["criterias"])
                    this.criterias.push(CriteriaRequestDto.fromJS(item));
            }
            this.tenantId = data["tenantId"];
            this.userId = data["userId"];
            this.id = data["id"];
            this.language = data["language"];
            this.option = data["option"];
            this.search = data["search"];
            this.status = data["status"];
            this.from = data["from"] ? moment(data["from"].toString()) : <any>undefined;
            this.to = data["to"] ? moment(data["to"].toString()) : <any>undefined;
            if (data["sValue"] && data["sValue"].constructor === Array) {
                this.sValue = [] as any;
                for (let item of data["sValue"])
                    this.sValue.push(item);
            }
            if (data["lValue"] && data["lValue"].constructor === Array) {
                this.lValue = [] as any;
                for (let item of data["lValue"])
                    this.lValue.push(item);
            }
            if (data["gValue"] && data["gValue"].constructor === Array) {
                this.gValue = [] as any;
                for (let item of data["gValue"])
                    this.gValue.push(item);
            }
            if (data["dValue"] && data["dValue"].constructor === Array) {
                this.dValue = [] as any;
                for (let item of data["dValue"])
                    this.dValue.push(item);
            }
            if (data["tValue"] && data["tValue"].constructor === Array) {
                this.tValue = [] as any;
                for (let item of data["tValue"])
                    this.tValue.push(moment(item));
            }
        }
    }

    static fromJS(data: any): GroupGuidGetDto {
        data = typeof data === 'object' ? data : {};
        let result = new GroupGuidGetDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["maxResultCount"] = this.maxResultCount;
        data["skipCount"] = this.skipCount;
        data["sorting"] = this.sorting;
        if (this.criterias && this.criterias.constructor === Array) {
            data["criterias"] = [];
            for (let item of this.criterias)
                data["criterias"].push(item.toJSON());
        }
        data["tenantId"] = this.tenantId;
        data["userId"] = this.userId;
        data["id"] = this.id;
        data["language"] = this.language;
        data["option"] = this.option;
        data["search"] = this.search;
        data["status"] = this.status;
        data["from"] = this.from ? this.from.toISOString() : <any>undefined;
        data["to"] = this.to ? this.to.toISOString() : <any>undefined;
        if (this.sValue && this.sValue.constructor === Array) {
            data["sValue"] = [];
            for (let item of this.sValue)
                data["sValue"].push(item);
        }
        if (this.lValue && this.lValue.constructor === Array) {
            data["lValue"] = [];
            for (let item of this.lValue)
                data["lValue"].push(item);
        }
        if (this.gValue && this.gValue.constructor === Array) {
            data["gValue"] = [];
            for (let item of this.gValue)
                data["gValue"].push(item);
        }
        if (this.dValue && this.dValue.constructor === Array) {
            data["dValue"] = [];
            for (let item of this.dValue)
                data["dValue"].push(item);
        }
        if (this.tValue && this.tValue.constructor === Array) {
            data["tValue"] = [];
            for (let item of this.tValue)
                data["tValue"].push(item.toISOString());
        }
        return data; 
    }

    clone(): GroupGuidGetDto {
        const json = this.toJSON();
        let result = new GroupGuidGetDto();
        result.init(json);
        return result;
    }
}

export interface IGroupGuidGetDto {
    maxResultCount: number;
    skipCount: number;
    sorting: string | undefined;
    criterias: CriteriaRequestDto[] | undefined;
    tenantId: number | undefined;
    userId: number | undefined;
    id: string;
    language: string | undefined;
    option: string | undefined;
    search: string | undefined;
    status: string | undefined;
    from: moment.Moment | undefined;
    to: moment.Moment | undefined;
    sValue: string[] | undefined;
    lValue: number[] | undefined;
    gValue: string[] | undefined;
    dValue: number[] | undefined;
    tValue: moment.Moment[] | undefined;
}

export class GroupOutputDto implements IGroupOutputDto {
    id: string;
    tenantId: number;
    status: string | undefined;
    search: string | undefined;
    hideValue: string | undefined;
    creatorUserId: number | undefined;
    creationTime: moment.Moment;
    name: string | undefined;
    code: string | undefined;
    codeData: string | undefined;
    valueData: string | undefined;
    category: string | undefined;
    permissions: string | undefined;
    language: string | undefined;
    value1: string | undefined;
    value2: string | undefined;
    value3: string | undefined;
    value4: string | undefined;
    value5: string | undefined;
    value6: string | undefined;
    value7: string | undefined;
    value8: string | undefined;
    value9: string | undefined;
    value10: string | undefined;
    number1: number;
    number2: number;
    number3: number;
    number4: number;
    number5: number;
    number6: number;
    number7: number;
    number8: number;
    number9: number;
    number10: number;
    formId: string;
    index: number;
    fields: string | undefined;
    listField: FieldValueDto[] | undefined;

    constructor(data?: IGroupOutputDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.tenantId = data["tenantId"];
            this.status = data["status"];
            this.search = data["search"];
            this.hideValue = data["hideValue"];
            this.creatorUserId = data["creatorUserId"];
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.name = data["name"];
            this.code = data["code"];
            this.codeData = data["codeData"];
            this.valueData = data["valueData"];
            this.category = data["category"];
            this.permissions = data["permissions"];
            this.language = data["language"];
            this.value1 = data["value1"];
            this.value2 = data["value2"];
            this.value3 = data["value3"];
            this.value4 = data["value4"];
            this.value5 = data["value5"];
            this.value6 = data["value6"];
            this.value7 = data["value7"];
            this.value8 = data["value8"];
            this.value9 = data["value9"];
            this.value10 = data["value10"];
            this.number1 = data["number1"];
            this.number2 = data["number2"];
            this.number3 = data["number3"];
            this.number4 = data["number4"];
            this.number5 = data["number5"];
            this.number6 = data["number6"];
            this.number7 = data["number7"];
            this.number8 = data["number8"];
            this.number9 = data["number9"];
            this.number10 = data["number10"];
            this.formId = data["formId"];
            this.index = data["index"];
            this.fields = data["fields"];
            if (data["listField"] && data["listField"].constructor === Array) {
                this.listField = [] as any;
                for (let item of data["listField"])
                    this.listField.push(FieldValueDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GroupOutputDto {
        data = typeof data === 'object' ? data : {};
        let result = new GroupOutputDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["tenantId"] = this.tenantId;
        data["status"] = this.status;
        data["search"] = this.search;
        data["hideValue"] = this.hideValue;
        data["creatorUserId"] = this.creatorUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["name"] = this.name;
        data["code"] = this.code;
        data["codeData"] = this.codeData;
        data["valueData"] = this.valueData;
        data["category"] = this.category;
        data["permissions"] = this.permissions;
        data["language"] = this.language;
        data["value1"] = this.value1;
        data["value2"] = this.value2;
        data["value3"] = this.value3;
        data["value4"] = this.value4;
        data["value5"] = this.value5;
        data["value6"] = this.value6;
        data["value7"] = this.value7;
        data["value8"] = this.value8;
        data["value9"] = this.value9;
        data["value10"] = this.value10;
        data["number1"] = this.number1;
        data["number2"] = this.number2;
        data["number3"] = this.number3;
        data["number4"] = this.number4;
        data["number5"] = this.number5;
        data["number6"] = this.number6;
        data["number7"] = this.number7;
        data["number8"] = this.number8;
        data["number9"] = this.number9;
        data["number10"] = this.number10;
        data["formId"] = this.formId;
        data["index"] = this.index;
        data["fields"] = this.fields;
        if (this.listField && this.listField.constructor === Array) {
            data["listField"] = [];
            for (let item of this.listField)
                data["listField"].push(item.toJSON());
        }
        return data; 
    }

    clone(): GroupOutputDto {
        const json = this.toJSON();
        let result = new GroupOutputDto();
        result.init(json);
        return result;
    }
}

export interface IGroupOutputDto {
    id: string;
    tenantId: number;
    status: string | undefined;
    search: string | undefined;
    hideValue: string | undefined;
    creatorUserId: number | undefined;
    creationTime: moment.Moment;
    name: string | undefined;
    code: string | undefined;
    codeData: string | undefined;
    valueData: string | undefined;
    category: string | undefined;
    permissions: string | undefined;
    language: string | undefined;
    value1: string | undefined;
    value2: string | undefined;
    value3: string | undefined;
    value4: string | undefined;
    value5: string | undefined;
    value6: string | undefined;
    value7: string | undefined;
    value8: string | undefined;
    value9: string | undefined;
    value10: string | undefined;
    number1: number;
    number2: number;
    number3: number;
    number4: number;
    number5: number;
    number6: number;
    number7: number;
    number8: number;
    number9: number;
    number10: number;
    formId: string;
    index: number;
    fields: string | undefined;
    listField: FieldValueDto[] | undefined;
}

export class MenuGuidGetDto implements IMenuGuidGetDto {
    maxResultCount: number;
    skipCount: number;
    sorting: string | undefined;
    criterias: CriteriaRequestDto[] | undefined;
    tenantId: number | undefined;
    userId: number | undefined;
    id: string;
    language: string | undefined;
    option: string | undefined;
    search: string | undefined;
    status: string | undefined;
    from: moment.Moment | undefined;
    to: moment.Moment | undefined;
    sValue: string[] | undefined;
    lValue: number[] | undefined;
    gValue: string[] | undefined;
    dValue: number[] | undefined;
    tValue: moment.Moment[] | undefined;

    constructor(data?: IMenuGuidGetDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.maxResultCount = data["maxResultCount"];
            this.skipCount = data["skipCount"];
            this.sorting = data["sorting"];
            if (data["criterias"] && data["criterias"].constructor === Array) {
                this.criterias = [] as any;
                for (let item of data["criterias"])
                    this.criterias.push(CriteriaRequestDto.fromJS(item));
            }
            this.tenantId = data["tenantId"];
            this.userId = data["userId"];
            this.id = data["id"];
            this.language = data["language"];
            this.option = data["option"];
            this.search = data["search"];
            this.status = data["status"];
            this.from = data["from"] ? moment(data["from"].toString()) : <any>undefined;
            this.to = data["to"] ? moment(data["to"].toString()) : <any>undefined;
            if (data["sValue"] && data["sValue"].constructor === Array) {
                this.sValue = [] as any;
                for (let item of data["sValue"])
                    this.sValue.push(item);
            }
            if (data["lValue"] && data["lValue"].constructor === Array) {
                this.lValue = [] as any;
                for (let item of data["lValue"])
                    this.lValue.push(item);
            }
            if (data["gValue"] && data["gValue"].constructor === Array) {
                this.gValue = [] as any;
                for (let item of data["gValue"])
                    this.gValue.push(item);
            }
            if (data["dValue"] && data["dValue"].constructor === Array) {
                this.dValue = [] as any;
                for (let item of data["dValue"])
                    this.dValue.push(item);
            }
            if (data["tValue"] && data["tValue"].constructor === Array) {
                this.tValue = [] as any;
                for (let item of data["tValue"])
                    this.tValue.push(moment(item));
            }
        }
    }

    static fromJS(data: any): MenuGuidGetDto {
        data = typeof data === 'object' ? data : {};
        let result = new MenuGuidGetDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["maxResultCount"] = this.maxResultCount;
        data["skipCount"] = this.skipCount;
        data["sorting"] = this.sorting;
        if (this.criterias && this.criterias.constructor === Array) {
            data["criterias"] = [];
            for (let item of this.criterias)
                data["criterias"].push(item.toJSON());
        }
        data["tenantId"] = this.tenantId;
        data["userId"] = this.userId;
        data["id"] = this.id;
        data["language"] = this.language;
        data["option"] = this.option;
        data["search"] = this.search;
        data["status"] = this.status;
        data["from"] = this.from ? this.from.toISOString() : <any>undefined;
        data["to"] = this.to ? this.to.toISOString() : <any>undefined;
        if (this.sValue && this.sValue.constructor === Array) {
            data["sValue"] = [];
            for (let item of this.sValue)
                data["sValue"].push(item);
        }
        if (this.lValue && this.lValue.constructor === Array) {
            data["lValue"] = [];
            for (let item of this.lValue)
                data["lValue"].push(item);
        }
        if (this.gValue && this.gValue.constructor === Array) {
            data["gValue"] = [];
            for (let item of this.gValue)
                data["gValue"].push(item);
        }
        if (this.dValue && this.dValue.constructor === Array) {
            data["dValue"] = [];
            for (let item of this.dValue)
                data["dValue"].push(item);
        }
        if (this.tValue && this.tValue.constructor === Array) {
            data["tValue"] = [];
            for (let item of this.tValue)
                data["tValue"].push(item.toISOString());
        }
        return data; 
    }

    clone(): MenuGuidGetDto {
        const json = this.toJSON();
        let result = new MenuGuidGetDto();
        result.init(json);
        return result;
    }
}

export interface IMenuGuidGetDto {
    maxResultCount: number;
    skipCount: number;
    sorting: string | undefined;
    criterias: CriteriaRequestDto[] | undefined;
    tenantId: number | undefined;
    userId: number | undefined;
    id: string;
    language: string | undefined;
    option: string | undefined;
    search: string | undefined;
    status: string | undefined;
    from: moment.Moment | undefined;
    to: moment.Moment | undefined;
    sValue: string[] | undefined;
    lValue: number[] | undefined;
    gValue: string[] | undefined;
    dValue: number[] | undefined;
    tValue: moment.Moment[] | undefined;
}

export class ValueMenuDto implements IValueMenuDto {
    id: string;
    parentId: string | undefined;
    name: string | undefined;
    codeData: string | undefined;
    valueData: string | undefined;
    hideValue: string | undefined;
    status: string | undefined;
    order: number;
    code: string | undefined;
    index: number;

    constructor(data?: IValueMenuDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.parentId = data["parentId"];
            this.name = data["name"];
            this.codeData = data["codeData"];
            this.valueData = data["valueData"];
            this.hideValue = data["hideValue"];
            this.status = data["status"];
            this.order = data["order"];
            this.code = data["code"];
            this.index = data["index"];
        }
    }

    static fromJS(data: any): ValueMenuDto {
        data = typeof data === 'object' ? data : {};
        let result = new ValueMenuDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["parentId"] = this.parentId;
        data["name"] = this.name;
        data["codeData"] = this.codeData;
        data["valueData"] = this.valueData;
        data["hideValue"] = this.hideValue;
        data["status"] = this.status;
        data["order"] = this.order;
        data["code"] = this.code;
        data["index"] = this.index;
        return data; 
    }

    clone(): ValueMenuDto {
        const json = this.toJSON();
        let result = new ValueMenuDto();
        result.init(json);
        return result;
    }
}

export interface IValueMenuDto {
    id: string;
    parentId: string | undefined;
    name: string | undefined;
    codeData: string | undefined;
    valueData: string | undefined;
    hideValue: string | undefined;
    status: string | undefined;
    order: number;
    code: string | undefined;
    index: number;
}

export class MenuOutputDto implements IMenuOutputDto {
    id: string;
    tenantId: number | undefined;
    status: string | undefined;
    search: string | undefined;
    hideValue: string | undefined;
    creatorUserId: number | undefined;
    creationTime: moment.Moment;
    name: string | undefined;
    code: string | undefined;
    codeData: string | undefined;
    valueData: string | undefined;
    category: string | undefined;
    permissions: string | undefined;
    language: string | undefined;
    value1: string | undefined;
    value2: string | undefined;
    value3: string | undefined;
    value4: string | undefined;
    value5: string | undefined;
    value6: string | undefined;
    value7: string | undefined;
    value8: string | undefined;
    value9: string | undefined;
    value10: string | undefined;
    number1: number;
    number2: number;
    number3: number;
    number4: number;
    number5: number;
    number6: number;
    number7: number;
    number8: number;
    number9: number;
    number10: number;
    parentId: string | undefined;
    index: number;
    order: number;
    groupCode: string | undefined;
    hashCode: string | undefined;
    parentCode: string | undefined;
    parentName: string | undefined;

    constructor(data?: IMenuOutputDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.tenantId = data["tenantId"];
            this.status = data["status"];
            this.search = data["search"];
            this.hideValue = data["hideValue"];
            this.creatorUserId = data["creatorUserId"];
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.name = data["name"];
            this.code = data["code"];
            this.codeData = data["codeData"];
            this.valueData = data["valueData"];
            this.category = data["category"];
            this.permissions = data["permissions"];
            this.language = data["language"];
            this.value1 = data["value1"];
            this.value2 = data["value2"];
            this.value3 = data["value3"];
            this.value4 = data["value4"];
            this.value5 = data["value5"];
            this.value6 = data["value6"];
            this.value7 = data["value7"];
            this.value8 = data["value8"];
            this.value9 = data["value9"];
            this.value10 = data["value10"];
            this.number1 = data["number1"];
            this.number2 = data["number2"];
            this.number3 = data["number3"];
            this.number4 = data["number4"];
            this.number5 = data["number5"];
            this.number6 = data["number6"];
            this.number7 = data["number7"];
            this.number8 = data["number8"];
            this.number9 = data["number9"];
            this.number10 = data["number10"];
            this.parentId = data["parentId"];
            this.index = data["index"];
            this.order = data["order"];
            this.groupCode = data["groupCode"];
            this.hashCode = data["hashCode"];
            this.parentCode = data["parentCode"];
            this.parentName = data["parentName"];
        }
    }

    static fromJS(data: any): MenuOutputDto {
        data = typeof data === 'object' ? data : {};
        let result = new MenuOutputDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["tenantId"] = this.tenantId;
        data["status"] = this.status;
        data["search"] = this.search;
        data["hideValue"] = this.hideValue;
        data["creatorUserId"] = this.creatorUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["name"] = this.name;
        data["code"] = this.code;
        data["codeData"] = this.codeData;
        data["valueData"] = this.valueData;
        data["category"] = this.category;
        data["permissions"] = this.permissions;
        data["language"] = this.language;
        data["value1"] = this.value1;
        data["value2"] = this.value2;
        data["value3"] = this.value3;
        data["value4"] = this.value4;
        data["value5"] = this.value5;
        data["value6"] = this.value6;
        data["value7"] = this.value7;
        data["value8"] = this.value8;
        data["value9"] = this.value9;
        data["value10"] = this.value10;
        data["number1"] = this.number1;
        data["number2"] = this.number2;
        data["number3"] = this.number3;
        data["number4"] = this.number4;
        data["number5"] = this.number5;
        data["number6"] = this.number6;
        data["number7"] = this.number7;
        data["number8"] = this.number8;
        data["number9"] = this.number9;
        data["number10"] = this.number10;
        data["parentId"] = this.parentId;
        data["index"] = this.index;
        data["order"] = this.order;
        data["groupCode"] = this.groupCode;
        data["hashCode"] = this.hashCode;
        data["parentCode"] = this.parentCode;
        data["parentName"] = this.parentName;
        return data; 
    }

    clone(): MenuOutputDto {
        const json = this.toJSON();
        let result = new MenuOutputDto();
        result.init(json);
        return result;
    }
}

export interface IMenuOutputDto {
    id: string;
    tenantId: number | undefined;
    status: string | undefined;
    search: string | undefined;
    hideValue: string | undefined;
    creatorUserId: number | undefined;
    creationTime: moment.Moment;
    name: string | undefined;
    code: string | undefined;
    codeData: string | undefined;
    valueData: string | undefined;
    category: string | undefined;
    permissions: string | undefined;
    language: string | undefined;
    value1: string | undefined;
    value2: string | undefined;
    value3: string | undefined;
    value4: string | undefined;
    value5: string | undefined;
    value6: string | undefined;
    value7: string | undefined;
    value8: string | undefined;
    value9: string | undefined;
    value10: string | undefined;
    number1: number;
    number2: number;
    number3: number;
    number4: number;
    number5: number;
    number6: number;
    number7: number;
    number8: number;
    number9: number;
    number10: number;
    parentId: string | undefined;
    index: number;
    order: number;
    groupCode: string | undefined;
    hashCode: string | undefined;
    parentCode: string | undefined;
    parentName: string | undefined;
}

export class MenuOutputDtoPagedResultDto implements IMenuOutputDtoPagedResultDto {
    items: MenuOutputDto[] | undefined;
    totalCount: number;

    constructor(data?: IMenuOutputDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items.push(MenuOutputDto.fromJS(item));
            }
            this.totalCount = data["totalCount"];
        }
    }

    static fromJS(data: any): MenuOutputDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new MenuOutputDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data; 
    }

    clone(): MenuOutputDtoPagedResultDto {
        const json = this.toJSON();
        let result = new MenuOutputDtoPagedResultDto();
        result.init(json);
        return result;
    }
}

export interface IMenuOutputDtoPagedResultDto {
    items: MenuOutputDto[] | undefined;
    totalCount: number;
}

export class MenuInputDto implements IMenuInputDto {
    id: string;
    tenantId: number | undefined;
    status: string | undefined;
    search: string | undefined;
    hideValue: string | undefined;
    creatorUserId: number | undefined;
    creationTime: moment.Moment;
    name: string | undefined;
    code: string | undefined;
    codeData: string | undefined;
    valueData: string | undefined;
    category: string | undefined;
    permissions: string | undefined;
    language: string | undefined;
    value1: string | undefined;
    value2: string | undefined;
    value3: string | undefined;
    value4: string | undefined;
    value5: string | undefined;
    value6: string | undefined;
    value7: string | undefined;
    value8: string | undefined;
    value9: string | undefined;
    value10: string | undefined;
    number1: number;
    number2: number;
    number3: number;
    number4: number;
    number5: number;
    number6: number;
    number7: number;
    number8: number;
    number9: number;
    number10: number;
    parentId: string | undefined;
    index: number;
    order: number;
    groupCode: string | undefined;
    hashCode: string | undefined;

    constructor(data?: IMenuInputDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.tenantId = data["tenantId"];
            this.status = data["status"];
            this.search = data["search"];
            this.hideValue = data["hideValue"];
            this.creatorUserId = data["creatorUserId"];
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.name = data["name"];
            this.code = data["code"];
            this.codeData = data["codeData"];
            this.valueData = data["valueData"];
            this.category = data["category"];
            this.permissions = data["permissions"];
            this.language = data["language"];
            this.value1 = data["value1"];
            this.value2 = data["value2"];
            this.value3 = data["value3"];
            this.value4 = data["value4"];
            this.value5 = data["value5"];
            this.value6 = data["value6"];
            this.value7 = data["value7"];
            this.value8 = data["value8"];
            this.value9 = data["value9"];
            this.value10 = data["value10"];
            this.number1 = data["number1"];
            this.number2 = data["number2"];
            this.number3 = data["number3"];
            this.number4 = data["number4"];
            this.number5 = data["number5"];
            this.number6 = data["number6"];
            this.number7 = data["number7"];
            this.number8 = data["number8"];
            this.number9 = data["number9"];
            this.number10 = data["number10"];
            this.parentId = data["parentId"];
            this.index = data["index"];
            this.order = data["order"];
            this.groupCode = data["groupCode"];
            this.hashCode = data["hashCode"];
        }
    }

    static fromJS(data: any): MenuInputDto {
        data = typeof data === 'object' ? data : {};
        let result = new MenuInputDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["tenantId"] = this.tenantId;
        data["status"] = this.status;
        data["search"] = this.search;
        data["hideValue"] = this.hideValue;
        data["creatorUserId"] = this.creatorUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["name"] = this.name;
        data["code"] = this.code;
        data["codeData"] = this.codeData;
        data["valueData"] = this.valueData;
        data["category"] = this.category;
        data["permissions"] = this.permissions;
        data["language"] = this.language;
        data["value1"] = this.value1;
        data["value2"] = this.value2;
        data["value3"] = this.value3;
        data["value4"] = this.value4;
        data["value5"] = this.value5;
        data["value6"] = this.value6;
        data["value7"] = this.value7;
        data["value8"] = this.value8;
        data["value9"] = this.value9;
        data["value10"] = this.value10;
        data["number1"] = this.number1;
        data["number2"] = this.number2;
        data["number3"] = this.number3;
        data["number4"] = this.number4;
        data["number5"] = this.number5;
        data["number6"] = this.number6;
        data["number7"] = this.number7;
        data["number8"] = this.number8;
        data["number9"] = this.number9;
        data["number10"] = this.number10;
        data["parentId"] = this.parentId;
        data["index"] = this.index;
        data["order"] = this.order;
        data["groupCode"] = this.groupCode;
        data["hashCode"] = this.hashCode;
        return data; 
    }

    clone(): MenuInputDto {
        const json = this.toJSON();
        let result = new MenuInputDto();
        result.init(json);
        return result;
    }
}

export interface IMenuInputDto {
    id: string;
    tenantId: number | undefined;
    status: string | undefined;
    search: string | undefined;
    hideValue: string | undefined;
    creatorUserId: number | undefined;
    creationTime: moment.Moment;
    name: string | undefined;
    code: string | undefined;
    codeData: string | undefined;
    valueData: string | undefined;
    category: string | undefined;
    permissions: string | undefined;
    language: string | undefined;
    value1: string | undefined;
    value2: string | undefined;
    value3: string | undefined;
    value4: string | undefined;
    value5: string | undefined;
    value6: string | undefined;
    value7: string | undefined;
    value8: string | undefined;
    value9: string | undefined;
    value10: string | undefined;
    number1: number;
    number2: number;
    number3: number;
    number4: number;
    number5: number;
    number6: number;
    number7: number;
    number8: number;
    number9: number;
    number10: number;
    parentId: string | undefined;
    index: number;
    order: number;
    groupCode: string | undefined;
    hashCode: string | undefined;
}

export class MenuCheckPermissionDto implements IMenuCheckPermissionDto {
    id: string | undefined;
    language: string | undefined;

    constructor(data?: IMenuCheckPermissionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.language = data["language"];
        }
    }

    static fromJS(data: any): MenuCheckPermissionDto {
        data = typeof data === 'object' ? data : {};
        let result = new MenuCheckPermissionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["language"] = this.language;
        return data; 
    }

    clone(): MenuCheckPermissionDto {
        const json = this.toJSON();
        let result = new MenuCheckPermissionDto();
        result.init(json);
        return result;
    }
}

export interface IMenuCheckPermissionDto {
    id: string | undefined;
    language: string | undefined;
}

export class MethodGuidGetDto implements IMethodGuidGetDto {
    maxResultCount: number;
    skipCount: number;
    sorting: string | undefined;
    criterias: CriteriaRequestDto[] | undefined;
    tenantId: number | undefined;
    userId: number | undefined;
    id: string;
    language: string | undefined;
    option: string | undefined;
    search: string | undefined;
    status: string | undefined;
    from: moment.Moment | undefined;
    to: moment.Moment | undefined;
    sValue: string[] | undefined;
    lValue: number[] | undefined;
    gValue: string[] | undefined;
    dValue: number[] | undefined;
    tValue: moment.Moment[] | undefined;

    constructor(data?: IMethodGuidGetDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.maxResultCount = data["maxResultCount"];
            this.skipCount = data["skipCount"];
            this.sorting = data["sorting"];
            if (data["criterias"] && data["criterias"].constructor === Array) {
                this.criterias = [] as any;
                for (let item of data["criterias"])
                    this.criterias.push(CriteriaRequestDto.fromJS(item));
            }
            this.tenantId = data["tenantId"];
            this.userId = data["userId"];
            this.id = data["id"];
            this.language = data["language"];
            this.option = data["option"];
            this.search = data["search"];
            this.status = data["status"];
            this.from = data["from"] ? moment(data["from"].toString()) : <any>undefined;
            this.to = data["to"] ? moment(data["to"].toString()) : <any>undefined;
            if (data["sValue"] && data["sValue"].constructor === Array) {
                this.sValue = [] as any;
                for (let item of data["sValue"])
                    this.sValue.push(item);
            }
            if (data["lValue"] && data["lValue"].constructor === Array) {
                this.lValue = [] as any;
                for (let item of data["lValue"])
                    this.lValue.push(item);
            }
            if (data["gValue"] && data["gValue"].constructor === Array) {
                this.gValue = [] as any;
                for (let item of data["gValue"])
                    this.gValue.push(item);
            }
            if (data["dValue"] && data["dValue"].constructor === Array) {
                this.dValue = [] as any;
                for (let item of data["dValue"])
                    this.dValue.push(item);
            }
            if (data["tValue"] && data["tValue"].constructor === Array) {
                this.tValue = [] as any;
                for (let item of data["tValue"])
                    this.tValue.push(moment(item));
            }
        }
    }

    static fromJS(data: any): MethodGuidGetDto {
        data = typeof data === 'object' ? data : {};
        let result = new MethodGuidGetDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["maxResultCount"] = this.maxResultCount;
        data["skipCount"] = this.skipCount;
        data["sorting"] = this.sorting;
        if (this.criterias && this.criterias.constructor === Array) {
            data["criterias"] = [];
            for (let item of this.criterias)
                data["criterias"].push(item.toJSON());
        }
        data["tenantId"] = this.tenantId;
        data["userId"] = this.userId;
        data["id"] = this.id;
        data["language"] = this.language;
        data["option"] = this.option;
        data["search"] = this.search;
        data["status"] = this.status;
        data["from"] = this.from ? this.from.toISOString() : <any>undefined;
        data["to"] = this.to ? this.to.toISOString() : <any>undefined;
        if (this.sValue && this.sValue.constructor === Array) {
            data["sValue"] = [];
            for (let item of this.sValue)
                data["sValue"].push(item);
        }
        if (this.lValue && this.lValue.constructor === Array) {
            data["lValue"] = [];
            for (let item of this.lValue)
                data["lValue"].push(item);
        }
        if (this.gValue && this.gValue.constructor === Array) {
            data["gValue"] = [];
            for (let item of this.gValue)
                data["gValue"].push(item);
        }
        if (this.dValue && this.dValue.constructor === Array) {
            data["dValue"] = [];
            for (let item of this.dValue)
                data["dValue"].push(item);
        }
        if (this.tValue && this.tValue.constructor === Array) {
            data["tValue"] = [];
            for (let item of this.tValue)
                data["tValue"].push(item.toISOString());
        }
        return data; 
    }

    clone(): MethodGuidGetDto {
        const json = this.toJSON();
        let result = new MethodGuidGetDto();
        result.init(json);
        return result;
    }
}

export interface IMethodGuidGetDto {
    maxResultCount: number;
    skipCount: number;
    sorting: string | undefined;
    criterias: CriteriaRequestDto[] | undefined;
    tenantId: number | undefined;
    userId: number | undefined;
    id: string;
    language: string | undefined;
    option: string | undefined;
    search: string | undefined;
    status: string | undefined;
    from: moment.Moment | undefined;
    to: moment.Moment | undefined;
    sValue: string[] | undefined;
    lValue: number[] | undefined;
    gValue: string[] | undefined;
    dValue: number[] | undefined;
    tValue: moment.Moment[] | undefined;
}

export class MethodOutputDto implements IMethodOutputDto {
    id: string;
    tenantId: number;
    status: string | undefined;
    search: string | undefined;
    hideValue: string | undefined;
    creatorUserId: number | undefined;
    creationTime: moment.Moment;
    name: string | undefined;
    code: string | undefined;
    codeData: string | undefined;
    valueData: string | undefined;
    category: string | undefined;
    permissions: string | undefined;
    language: string | undefined;
    value1: string | undefined;
    value2: string | undefined;
    value3: string | undefined;
    value4: string | undefined;
    value5: string | undefined;
    value6: string | undefined;
    value7: string | undefined;
    value8: string | undefined;
    value9: string | undefined;
    value10: string | undefined;
    number1: number;
    number2: number;
    number3: number;
    number4: number;
    number5: number;
    number6: number;
    number7: number;
    number8: number;
    number9: number;
    number10: number;

    constructor(data?: IMethodOutputDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.tenantId = data["tenantId"];
            this.status = data["status"];
            this.search = data["search"];
            this.hideValue = data["hideValue"];
            this.creatorUserId = data["creatorUserId"];
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.name = data["name"];
            this.code = data["code"];
            this.codeData = data["codeData"];
            this.valueData = data["valueData"];
            this.category = data["category"];
            this.permissions = data["permissions"];
            this.language = data["language"];
            this.value1 = data["value1"];
            this.value2 = data["value2"];
            this.value3 = data["value3"];
            this.value4 = data["value4"];
            this.value5 = data["value5"];
            this.value6 = data["value6"];
            this.value7 = data["value7"];
            this.value8 = data["value8"];
            this.value9 = data["value9"];
            this.value10 = data["value10"];
            this.number1 = data["number1"];
            this.number2 = data["number2"];
            this.number3 = data["number3"];
            this.number4 = data["number4"];
            this.number5 = data["number5"];
            this.number6 = data["number6"];
            this.number7 = data["number7"];
            this.number8 = data["number8"];
            this.number9 = data["number9"];
            this.number10 = data["number10"];
        }
    }

    static fromJS(data: any): MethodOutputDto {
        data = typeof data === 'object' ? data : {};
        let result = new MethodOutputDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["tenantId"] = this.tenantId;
        data["status"] = this.status;
        data["search"] = this.search;
        data["hideValue"] = this.hideValue;
        data["creatorUserId"] = this.creatorUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["name"] = this.name;
        data["code"] = this.code;
        data["codeData"] = this.codeData;
        data["valueData"] = this.valueData;
        data["category"] = this.category;
        data["permissions"] = this.permissions;
        data["language"] = this.language;
        data["value1"] = this.value1;
        data["value2"] = this.value2;
        data["value3"] = this.value3;
        data["value4"] = this.value4;
        data["value5"] = this.value5;
        data["value6"] = this.value6;
        data["value7"] = this.value7;
        data["value8"] = this.value8;
        data["value9"] = this.value9;
        data["value10"] = this.value10;
        data["number1"] = this.number1;
        data["number2"] = this.number2;
        data["number3"] = this.number3;
        data["number4"] = this.number4;
        data["number5"] = this.number5;
        data["number6"] = this.number6;
        data["number7"] = this.number7;
        data["number8"] = this.number8;
        data["number9"] = this.number9;
        data["number10"] = this.number10;
        return data; 
    }

    clone(): MethodOutputDto {
        const json = this.toJSON();
        let result = new MethodOutputDto();
        result.init(json);
        return result;
    }
}

export interface IMethodOutputDto {
    id: string;
    tenantId: number;
    status: string | undefined;
    search: string | undefined;
    hideValue: string | undefined;
    creatorUserId: number | undefined;
    creationTime: moment.Moment;
    name: string | undefined;
    code: string | undefined;
    codeData: string | undefined;
    valueData: string | undefined;
    category: string | undefined;
    permissions: string | undefined;
    language: string | undefined;
    value1: string | undefined;
    value2: string | undefined;
    value3: string | undefined;
    value4: string | undefined;
    value5: string | undefined;
    value6: string | undefined;
    value7: string | undefined;
    value8: string | undefined;
    value9: string | undefined;
    value10: string | undefined;
    number1: number;
    number2: number;
    number3: number;
    number4: number;
    number5: number;
    number6: number;
    number7: number;
    number8: number;
    number9: number;
    number10: number;
}

export class MethodInputDto implements IMethodInputDto {
    id: string;
    tenantId: number;
    status: string | undefined;
    search: string | undefined;
    hideValue: string | undefined;
    creatorUserId: number | undefined;
    creationTime: moment.Moment;
    name: string | undefined;
    code: string | undefined;
    codeData: string | undefined;
    valueData: string | undefined;
    category: string | undefined;
    permissions: string | undefined;
    language: string | undefined;
    value1: string | undefined;
    value2: string | undefined;
    value3: string | undefined;
    value4: string | undefined;
    value5: string | undefined;
    value6: string | undefined;
    value7: string | undefined;
    value8: string | undefined;
    value9: string | undefined;
    value10: string | undefined;
    number1: number;
    number2: number;
    number3: number;
    number4: number;
    number5: number;
    number6: number;
    number7: number;
    number8: number;
    number9: number;
    number10: number;

    constructor(data?: IMethodInputDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.tenantId = data["tenantId"];
            this.status = data["status"];
            this.search = data["search"];
            this.hideValue = data["hideValue"];
            this.creatorUserId = data["creatorUserId"];
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.name = data["name"];
            this.code = data["code"];
            this.codeData = data["codeData"];
            this.valueData = data["valueData"];
            this.category = data["category"];
            this.permissions = data["permissions"];
            this.language = data["language"];
            this.value1 = data["value1"];
            this.value2 = data["value2"];
            this.value3 = data["value3"];
            this.value4 = data["value4"];
            this.value5 = data["value5"];
            this.value6 = data["value6"];
            this.value7 = data["value7"];
            this.value8 = data["value8"];
            this.value9 = data["value9"];
            this.value10 = data["value10"];
            this.number1 = data["number1"];
            this.number2 = data["number2"];
            this.number3 = data["number3"];
            this.number4 = data["number4"];
            this.number5 = data["number5"];
            this.number6 = data["number6"];
            this.number7 = data["number7"];
            this.number8 = data["number8"];
            this.number9 = data["number9"];
            this.number10 = data["number10"];
        }
    }

    static fromJS(data: any): MethodInputDto {
        data = typeof data === 'object' ? data : {};
        let result = new MethodInputDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["tenantId"] = this.tenantId;
        data["status"] = this.status;
        data["search"] = this.search;
        data["hideValue"] = this.hideValue;
        data["creatorUserId"] = this.creatorUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["name"] = this.name;
        data["code"] = this.code;
        data["codeData"] = this.codeData;
        data["valueData"] = this.valueData;
        data["category"] = this.category;
        data["permissions"] = this.permissions;
        data["language"] = this.language;
        data["value1"] = this.value1;
        data["value2"] = this.value2;
        data["value3"] = this.value3;
        data["value4"] = this.value4;
        data["value5"] = this.value5;
        data["value6"] = this.value6;
        data["value7"] = this.value7;
        data["value8"] = this.value8;
        data["value9"] = this.value9;
        data["value10"] = this.value10;
        data["number1"] = this.number1;
        data["number2"] = this.number2;
        data["number3"] = this.number3;
        data["number4"] = this.number4;
        data["number5"] = this.number5;
        data["number6"] = this.number6;
        data["number7"] = this.number7;
        data["number8"] = this.number8;
        data["number9"] = this.number9;
        data["number10"] = this.number10;
        return data; 
    }

    clone(): MethodInputDto {
        const json = this.toJSON();
        let result = new MethodInputDto();
        result.init(json);
        return result;
    }
}

export interface IMethodInputDto {
    id: string;
    tenantId: number;
    status: string | undefined;
    search: string | undefined;
    hideValue: string | undefined;
    creatorUserId: number | undefined;
    creationTime: moment.Moment;
    name: string | undefined;
    code: string | undefined;
    codeData: string | undefined;
    valueData: string | undefined;
    category: string | undefined;
    permissions: string | undefined;
    language: string | undefined;
    value1: string | undefined;
    value2: string | undefined;
    value3: string | undefined;
    value4: string | undefined;
    value5: string | undefined;
    value6: string | undefined;
    value7: string | undefined;
    value8: string | undefined;
    value9: string | undefined;
    value10: string | undefined;
    number1: number;
    number2: number;
    number3: number;
    number4: number;
    number5: number;
    number6: number;
    number7: number;
    number8: number;
    number9: number;
    number10: number;
}

export class SettingEntityGuidGetDto implements ISettingEntityGuidGetDto {
    maxResultCount: number;
    skipCount: number;
    sorting: string | undefined;
    criterias: CriteriaRequestDto[] | undefined;
    tenantId: number | undefined;
    userId: number | undefined;
    id: string;
    language: string | undefined;
    option: string | undefined;
    search: string | undefined;
    status: string | undefined;
    from: moment.Moment | undefined;
    to: moment.Moment | undefined;
    sValue: string[] | undefined;
    lValue: number[] | undefined;
    gValue: string[] | undefined;
    dValue: number[] | undefined;
    tValue: moment.Moment[] | undefined;

    constructor(data?: ISettingEntityGuidGetDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.maxResultCount = data["maxResultCount"];
            this.skipCount = data["skipCount"];
            this.sorting = data["sorting"];
            if (data["criterias"] && data["criterias"].constructor === Array) {
                this.criterias = [] as any;
                for (let item of data["criterias"])
                    this.criterias.push(CriteriaRequestDto.fromJS(item));
            }
            this.tenantId = data["tenantId"];
            this.userId = data["userId"];
            this.id = data["id"];
            this.language = data["language"];
            this.option = data["option"];
            this.search = data["search"];
            this.status = data["status"];
            this.from = data["from"] ? moment(data["from"].toString()) : <any>undefined;
            this.to = data["to"] ? moment(data["to"].toString()) : <any>undefined;
            if (data["sValue"] && data["sValue"].constructor === Array) {
                this.sValue = [] as any;
                for (let item of data["sValue"])
                    this.sValue.push(item);
            }
            if (data["lValue"] && data["lValue"].constructor === Array) {
                this.lValue = [] as any;
                for (let item of data["lValue"])
                    this.lValue.push(item);
            }
            if (data["gValue"] && data["gValue"].constructor === Array) {
                this.gValue = [] as any;
                for (let item of data["gValue"])
                    this.gValue.push(item);
            }
            if (data["dValue"] && data["dValue"].constructor === Array) {
                this.dValue = [] as any;
                for (let item of data["dValue"])
                    this.dValue.push(item);
            }
            if (data["tValue"] && data["tValue"].constructor === Array) {
                this.tValue = [] as any;
                for (let item of data["tValue"])
                    this.tValue.push(moment(item));
            }
        }
    }

    static fromJS(data: any): SettingEntityGuidGetDto {
        data = typeof data === 'object' ? data : {};
        let result = new SettingEntityGuidGetDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["maxResultCount"] = this.maxResultCount;
        data["skipCount"] = this.skipCount;
        data["sorting"] = this.sorting;
        if (this.criterias && this.criterias.constructor === Array) {
            data["criterias"] = [];
            for (let item of this.criterias)
                data["criterias"].push(item.toJSON());
        }
        data["tenantId"] = this.tenantId;
        data["userId"] = this.userId;
        data["id"] = this.id;
        data["language"] = this.language;
        data["option"] = this.option;
        data["search"] = this.search;
        data["status"] = this.status;
        data["from"] = this.from ? this.from.toISOString() : <any>undefined;
        data["to"] = this.to ? this.to.toISOString() : <any>undefined;
        if (this.sValue && this.sValue.constructor === Array) {
            data["sValue"] = [];
            for (let item of this.sValue)
                data["sValue"].push(item);
        }
        if (this.lValue && this.lValue.constructor === Array) {
            data["lValue"] = [];
            for (let item of this.lValue)
                data["lValue"].push(item);
        }
        if (this.gValue && this.gValue.constructor === Array) {
            data["gValue"] = [];
            for (let item of this.gValue)
                data["gValue"].push(item);
        }
        if (this.dValue && this.dValue.constructor === Array) {
            data["dValue"] = [];
            for (let item of this.dValue)
                data["dValue"].push(item);
        }
        if (this.tValue && this.tValue.constructor === Array) {
            data["tValue"] = [];
            for (let item of this.tValue)
                data["tValue"].push(item.toISOString());
        }
        return data; 
    }

    clone(): SettingEntityGuidGetDto {
        const json = this.toJSON();
        let result = new SettingEntityGuidGetDto();
        result.init(json);
        return result;
    }
}

export interface ISettingEntityGuidGetDto {
    maxResultCount: number;
    skipCount: number;
    sorting: string | undefined;
    criterias: CriteriaRequestDto[] | undefined;
    tenantId: number | undefined;
    userId: number | undefined;
    id: string;
    language: string | undefined;
    option: string | undefined;
    search: string | undefined;
    status: string | undefined;
    from: moment.Moment | undefined;
    to: moment.Moment | undefined;
    sValue: string[] | undefined;
    lValue: number[] | undefined;
    gValue: string[] | undefined;
    dValue: number[] | undefined;
    tValue: moment.Moment[] | undefined;
}

export class SettingOutputDto implements ISettingOutputDto {
    id: string;
    tenantId: number | undefined;
    userId: number | undefined;
    key: string | undefined;
    type: string | undefined;
    value: string | undefined;
    language: string | undefined;

    constructor(data?: ISettingOutputDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.tenantId = data["tenantId"];
            this.userId = data["userId"];
            this.key = data["key"];
            this.type = data["type"];
            this.value = data["value"];
            this.language = data["language"];
        }
    }

    static fromJS(data: any): SettingOutputDto {
        data = typeof data === 'object' ? data : {};
        let result = new SettingOutputDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["tenantId"] = this.tenantId;
        data["userId"] = this.userId;
        data["key"] = this.key;
        data["type"] = this.type;
        data["value"] = this.value;
        data["language"] = this.language;
        return data; 
    }

    clone(): SettingOutputDto {
        const json = this.toJSON();
        let result = new SettingOutputDto();
        result.init(json);
        return result;
    }
}

export interface ISettingOutputDto {
    id: string;
    tenantId: number | undefined;
    userId: number | undefined;
    key: string | undefined;
    type: string | undefined;
    value: string | undefined;
    language: string | undefined;
}

export class SettingInputDto implements ISettingInputDto {
    id: string;
    tenantId: number | undefined;
    userId: number | undefined;
    key: string | undefined;
    type: string | undefined;
    value: string | undefined;
    language: string | undefined;

    constructor(data?: ISettingInputDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.tenantId = data["tenantId"];
            this.userId = data["userId"];
            this.key = data["key"];
            this.type = data["type"];
            this.value = data["value"];
            this.language = data["language"];
        }
    }

    static fromJS(data: any): SettingInputDto {
        data = typeof data === 'object' ? data : {};
        let result = new SettingInputDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["tenantId"] = this.tenantId;
        data["userId"] = this.userId;
        data["key"] = this.key;
        data["type"] = this.type;
        data["value"] = this.value;
        data["language"] = this.language;
        return data; 
    }

    clone(): SettingInputDto {
        const json = this.toJSON();
        let result = new SettingInputDto();
        result.init(json);
        return result;
    }
}

export interface ISettingInputDto {
    id: string;
    tenantId: number | undefined;
    userId: number | undefined;
    key: string | undefined;
    type: string | undefined;
    value: string | undefined;
    language: string | undefined;
}

export class GetSettingDto implements IGetSettingDto {
    tenantId: number | undefined;
    key: string | undefined;
    language: string | undefined;
    type: string | undefined;

    constructor(data?: IGetSettingDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.tenantId = data["tenantId"];
            this.key = data["key"];
            this.language = data["language"];
            this.type = data["type"];
        }
    }

    static fromJS(data: any): GetSettingDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetSettingDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantId"] = this.tenantId;
        data["key"] = this.key;
        data["language"] = this.language;
        data["type"] = this.type;
        return data; 
    }

    clone(): GetSettingDto {
        const json = this.toJSON();
        let result = new GetSettingDto();
        result.init(json);
        return result;
    }
}

export interface IGetSettingDto {
    tenantId: number | undefined;
    key: string | undefined;
    language: string | undefined;
    type: string | undefined;
}

export class SwaggerException extends Error {
    message: string;
    status: number; 
    response: string; 
    headers: { [key: string]: any; };
    result: any; 

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isSwaggerException = true;

    static isSwaggerException(obj: any): obj is SwaggerException {
        return obj.isSwaggerException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): Observable<any> {
    if(result !== null && result !== undefined)
        return _observableThrow(result);
    else
        return _observableThrow(new SwaggerException(message, status, response, headers, null));
}

function blobToText(blob: any): Observable<string> {
    return new Observable<string>((observer: any) => {
        if (!blob) {
            observer.next("");
            observer.complete();
        } else {
            let reader = new FileReader(); 
            reader.onload = event => { 
                observer.next((<any>event.target).result);
                observer.complete();
            };
            reader.readAsText(blob); 
        }
    });
}